{"meta":{"title":"litchi","subtitle":"litchi blog","description":null,"author":"litchi","url":""},"pages":[{"title":"404","date":"2020-03-30T13:32:57.615Z","updated":"2017-11-03T08:52:38.000Z","comments":true,"path":"/404.html","permalink":"//404.html","excerpt":"","text":"页面找不到了，回看看吧！"},{"title":"about","date":"2017-11-07T06:59:32.000Z","updated":"2017-11-07T07:00:17.000Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"litchi"}],"posts":[{"title":"时间复杂度和空间复杂度","slug":"时间复杂度和空间复杂度","date":"2020-04-07T13:24:37.000Z","updated":"2020-04-07T15:08:34.445Z","comments":true,"path":"2020/04/07/时间复杂度和空间复杂度/","link":"","permalink":"/2020/04/07/时间复杂度和空间复杂度/","excerpt":"","text":"时间复杂度：执行算法所需要的时间 空间复杂度：执行算法所需要的内存空间 时间复杂度的定义：一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得T(n)/f(n)的极限值（当n趋近于无穷大时）为不等于零的常数，则称f(n)是T(n)的同数量级函数 通常将O(1)、O(n)、O(logn)、O(n2)等分别叫做常量阶、线性阶、对数阶、平方阶等 推导大O阶方法：1.用常数1取代运行时间中的所有加法常数；2.修改后的运行次数函数中，值保留最高阶项；3.如果最高阶向存在且不是1，则去除与这个项相乘的常数 常数阶O(1)： 123int sum=0，n=100；sum=（1+n）*n/2;System.out.println(sum); 线性阶O(n): 123for(int i=0;i&lt;n;i++)&#123;//O(1)的算法&#125; 对数阶O(logn): 12345int num=1;while(num&lt;n)&#123;num=num*2;//O(1)的算法&#125; 平方阶O(n^2): 12345for(int i=0;i&lt;n;i++)&#123; for(int j=i;j++)&#123; //O(1)的算法 &#125;&#125; 常用的时间复杂度按照耗费的时间从小到大依次是： O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"面试积累","slug":"面试积累","date":"2020-02-05T06:20:52.000Z","updated":"2020-04-07T11:19:58.134Z","comments":true,"path":"2020/02/05/面试积累/","link":"","permalink":"/2020/02/05/面试积累/","excerpt":"","text":"要求： 五险一金（全额，非全额要在基础薪资上调整） 技术团队规模 上下班时间 单双休 加班情况 人员配置 发版频率 绩效 年终奖 其他福利 餐补 车补贴 房补贴 项目经验：遇到了什么困难怎么解决的 直播 做了两方面的隔离，一是与其他业务模块的解耦 利用中间控制层 直播模块提供出对其他业务场景的依赖需求 其他业务模块提供这些能力给直播；二是把直播内部分为业务表现层和三方依赖层 具体做法是把三方直播依赖沉淀到baseview 把业务层需要的能力通过统一能力管理输出 （主要是直播画面能力控制和自定义消息协议的控制） 首页 动画控件 级联viewtab java基础： 同步锁同步锁的原理： Arraylist和LinklistArrayList是一个数组实现了RandomAccess接口可以随机访问元素，增删速度相对慢；LinkList是链表，只能顺序访问元素，增删快 线程和进程 位运算常见十进制D、二进制B、八进制Q和十六进制H（逢几进1）n十进制向n进制转化：十进制转化为n进制时 十进制数一直除以n得余数 到一直不能整除为止，小数点部分是将小数部分乘以n 取整 然后小数部分继续乘以n 取整部分倒叙排序就是小数部分的值二进制转n进制：采用r（二进制和n进制之间的位数差 例如八进制是3合1、十六进制时4合1，如果是32进制就是 5合1）合1的方式，然后按照案权展开相加即可得 线程安全 进程保活 HashMap原理 数据结构与算法： 时间复杂度、空间复杂度 网络： tcp的三次握手和四次挥手：第一次：c端发送连接请求 序列号seq=x SYN创建连接状态第二次：b端收到信息后 发送确认码ack=x+1 SYN=1第三次：c端收到后 http2.0 Android下网络优化方案 QUIC协议 Android基础： 三方库： eventbus原理利用反射触发事件函数的执行关键的一个键值对来存储数据 key是eventType（传递的时事件类型）线程模式 posting：处理函数看post在线程就在什么线程执行main：处理函数在主线程执行background：处理函数在子线程 post如果在主线程辉创建子线程 如果在子线程就直接在子线程触发处理async：新建子线程触发处理函数的执行 butterknife原理 okhttp rxjava retrofit Glide Fresco 三级缓冲7.","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"/tags/面试/"}]},{"title":"Android数据的持久化","slug":"Android数据的持久化","date":"2018-06-28T07:28:40.000Z","updated":"2018-06-28T07:51:47.298Z","comments":true,"path":"2018/06/28/Android数据的持久化/","link":"","permalink":"/2018/06/28/Android数据的持久化/","excerpt":"常见的存储的方式为SQlite数据存储、xml存储以及自定义数据格式的存储方式","text":"常见的存储的方式为SQlite数据存储、xml存储以及自定义数据格式的存储方式","categories":[],"tags":[{"name":"Android 存储","slug":"Android-存储","permalink":"/tags/Android-存储/"}]},{"title":"android 中gradle依赖冲突解决","slug":"android-中gradle依赖冲突解决","date":"2017-11-24T07:00:34.000Z","updated":"2020-04-07T14:52:54.168Z","comments":true,"path":"2017/11/24/android-中gradle依赖冲突解决/","link":"","permalink":"/2017/11/24/android-中gradle依赖冲突解决/","excerpt":"","text":"android项目开发中经常会遇到库依赖异常，大多是版本依赖的冲突问题，说明下常见的版本依赖冲突解决方式 首页看下我们项目的依赖关系1./gradlew dependencies :app:dependencies :app表示依赖modulemac下运行可能人别不了命令行，运行+x gradlew ```添加权限1234567可以看到依赖结构是树状结构，各库下又依赖了android的官方提供的一些库，如果依赖的库不是太多的话，可以使用transitive参数，使得依赖库所需的依赖不直接使用，在依赖库的module中同一级上做依赖关系``` implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; compile (&apos;com.alibaba.android:vlayout:1.2.2@aar&apos;) &#123; transitive = false &#125; transitive为false表示单独依赖，true为默认树状依赖 这种解决方式只用于当前的依赖包只是版本导致的，且版本变动不大，起码它的代码package路径一致，如果差异很大可以指定依赖关系中特定包不包含到依赖中1234implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; compile (&apos;com.alibaba.android:vlayout:1.2.2@aar&apos;) &#123; exclude group: &apos;support-v4&apos; &#125;","categories":[],"tags":[{"name":"gradle","slug":"gradle","permalink":"/tags/gradle/"}]},{"title":"git基础知识","slug":"git基础知识","date":"2017-11-07T02:53:40.000Z","updated":"2017-11-16T05:57:00.390Z","comments":true,"path":"2017/11/07/git基础知识/","link":"","permalink":"/2017/11/07/git基础知识/","excerpt":"","text":"git基础知识——创建新的ssh key ssh-keygen -t rsa -C \"793021170@qq.com\"```1234------测试 ssh 链接 github```$ ssh -T git@git.oschina.net ——设置用户名、邮箱 git config --global user.name \"litchi\"```1```$ git config --global user.email &quot;793021170@qq.com&quot; ——提交到远程服务器 git remote add origin ssh://git@dev.lemote.com/rt4ls.git```1```$ git push origin master ——-本地库中缺少md文件时git pull --rebase origin master```1234567-------由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令```$ git push -u origin master ——-关联远程库git remote add origin git@server-name:path/repo-name.git```123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178git checkout master //进入master分支git checkout -b frommaster //以master为源创建分支frommastergit show # 显示某次提交的内容 git show $idgit co -- &lt;file&gt; # 抛弃工作区修改git co . # 抛弃工作区修改git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci &lt;file&gt; git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci -am &quot;some comments&quot;git ci --amend # 修改最后一次提交记录git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象git revert HEAD # 恢复最后一次提交的状态查看文件diffgit diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diffgit diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较git diff --staged # 比较暂存区和版本库差异git diff --cached # 比较暂存区和版本库差异git diff --stat # 仅仅比较统计信息查看提交记录git log git log &lt;file&gt; # 查看该文件每次提交记录git log -p &lt;file&gt; # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log --stat #查看提交统计信息tigMac上可以使用tig代替diff和log，brew install tigGit 本地分支管理查看、切换、创建和删除分支git br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br --merged # 查看已经被合并到当前分支的分支git br --no-merged # 查看尚未被合并到当前分支的分支git co &lt;branch&gt; # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d &lt;branch&gt; # 删除某个分支git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebasegit merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; Git补丁管理(方便在多台机器上开发同步时用)git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch # 打补丁git apply --check ../sync.patch #测试补丁能否成功 Git暂存管理git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支Git远程仓库管理GitHubgit remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm &lt;repository&gt; # 删除远程仓库创建远程仓库git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支也可以命令设置跟踪远程库和本地库git branch --set-upstream master origin/mastergit branch --set-upstream develop origin/develop--------显示command的help```git help &lt;command&gt; # 异常处理：1.如果出现remote origin already exists.需要删除远程库后在执行git remote add origin 具体执行：git remote rm origin git remote add origin git@git.oschina.net:jichengliu/SilkMarke","categories":[],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}]},{"title":"设计模式之工厂模式","slug":"设计模式之工厂模式","date":"2017-11-06T03:10:35.000Z","updated":"2017-11-16T05:50:54.645Z","comments":true,"path":"2017/11/06/设计模式之工厂模式/","link":"","permalink":"/2017/11/06/设计模式之工厂模式/","excerpt":"","text":"设计模式之工厂模式前言最近在看设计模式相关的一些知识，看了一些感觉还是要做一些记录的，一方面用来记录当前情况下个人对设计模式的理解程度，使得这块知识更加深刻，另一方面也是方便把自己的一些拙见拿出来希望能够共同进步，得到众人的指正。 引入工厂模式应该说最常见的模式，看一些介绍模式的书里工厂模式基本都是第一个被提到的，它应用场景比较多，也容易被理解。它是名如其模式，先来分析下它的名字，“工厂”用来生产各种产品，我们可以直接通过工厂来获得需要的各种产品，而不需要来考虑其具体的实现，所谓的“工厂”就类似于“商店”，提供我们需要所需产品。那么“工厂”的产品是怎么样获得的呢，“工厂”会根据我们具体的需求来利用具体的“材料”来“生产”具体的产品，到这里来看图说话。 上图就是对上面文字的一个概括，这里先又了这个概念就OK了，下面深入到代码层面来说明。 代码实现这里用引入中最原始的提到的工厂、产品和消费者举例。例子在android studio中android项目中开发。 工厂、产品和消费者 创建一个工厂类(Factory),提供一个获得产品的方法 123456789101112131415161718192021222324public class Factory &#123; /** * 获得产品对象实例 * * @param clazz clazz * @param &lt;P extends BaseProduct&gt; p * @return p */ public static &lt;P extends BaseProduct&gt; P getProduct(Class&lt;P&gt; clazz) &#123; P p = null; try &#123; p = (P) Class.forName(clazz.getName()).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return p; &#125;&#125; 创建一个接口(IProduct)，商品类将实现produce()方法 12345public interface IProduct &#123; public BaseProduct produce();&#125; 分别创建商品类(BaseProduct、ProductOne、ProductTwo、ProductThree和ProductFour) 123456public abstract class BaseProduct implements IProduct &#123; public void makeBaseComponents() &#123; //制作基础组件 &#125;&#125; 123456789public class ProductOne extends BaseProduct implements IProduct &#123; @Override public BaseProduct produce() &#123; makeBaseComponents(); Log.d(\"ProductOne\", \"make ProductOne\"); return this; &#125;&#125; 123456789public class ProductTwo extends BaseProduct implements IProduct &#123; @Override public BaseProduct produce() &#123; makeBaseComponents(); Log.d(\"ProductTwo\", \"make ProductTwo\"); return this; &#125;&#125; 123456789public class ProductThree extends BaseProduct implements IProduct &#123; @Override public BaseProduct produce() &#123; makeBaseComponents(); Log.d(\"ProductThree\", \"make ProductThree\"); return this; &#125;&#125; 123456789public class ProductFour extends BaseProduct implements IProduct &#123; @Override public BaseProduct produce() &#123; makeBaseComponents(); Log.d(\"ProductFour\", \"make ProductFour\"); return this; &#125;&#125; 在MainActivity类中获得需要的商品类实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void onGetProduct(int productType) &#123; Class&lt;? extends BaseProduct&gt; clazz = null; switch (productType) &#123; case 1: clazz = ProductOne.class; break; case 2: clazz = ProductTwo.class; break; case 3: clazz = ProductThree.class; break; case 4: clazz = ProductFour.class; break; &#125; BaseProduct product = Factory.getProduct(clazz); Toast.makeText(this, product.produce(), Toast.LENGTH_LONG).show(); &#125; public void onGetProductThree(View view) &#123; onGetProduct(3); &#125; public void onGetProductTwo(View view) &#123; onGetProduct(2); &#125; public void onGetProductOne(View view) &#123; onGetProduct(1); &#125; public void onGetProductFour(View view) &#123; onGetProduct(4); &#125;&#125; 最终我们实现在activity中获得了产品的实例对象 github 为什么要用工厂模式在开发过程中常常会独立做一些模块供其他的开发者来用，这种情况下，其实对于其他的开发者来说要求在使用功能时尽量的简单、调用方便，他们不需要去了解里面的具体实现，只要简单调用就可以拿到对应的实例，这个时候对于工厂模式时一个可行的方案，当然在实际开发中可以会和其他的模式混用来达到效果，这个还要具问具析。对于我们可以在什么场景下利用工厂模式，这里列出一些它的利弊，以便在考虑使用时参考： 利: 多类型扩展好，如果新增了一种商品只要实现它的具体类和方法，即可根据类来获取其实例 具体实现是封闭的、不对外的 调用方便，可通过一个类型或者类名就可以获得具体实例 弊产品类创建方式单一，因为是通过类命来创建实例，这样创建不会像常见的直接new灵活不适合单一产品时使用","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}]},{"title":"Markdown常用语法","slug":"Markdown常用语法","date":"2017-11-06T03:01:55.000Z","updated":"2017-11-07T04:49:11.000Z","comments":true,"path":"2017/11/06/Markdown常用语法/","link":"","permalink":"/2017/11/06/Markdown常用语法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"hexo command line","slug":"hexo-command-line","date":"2017-11-03T14:34:03.000Z","updated":"2020-02-05T06:21:38.195Z","comments":true,"path":"2017/11/03/hexo-command-line/","link":"","permalink":"/2017/11/03/hexo-command-line/","excerpt":"Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server","text":"Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"linux环境下jdk安装配置","slug":"linux环境下jdk安装配置","date":"2017-11-03T13:54:47.000Z","updated":"2017-11-03T14:46:49.000Z","comments":true,"path":"2017/11/03/linux环境下jdk安装配置/","link":"","permalink":"/2017/11/03/linux环境下jdk安装配置/","excerpt":"jdk下载 wget -O jdk-8u131-linux-x64.tar.gz jdk-8u131-linux-x64.tar.gzAuthParam=1499664230_984ba136862e0fd6281ac5bc2bee90e2 解压文件 tar xf jdk-8u131-linux-x64.tar.gz 创建要存放的目录并复制解压后的jdk文件到目录下","text":"jdk下载 wget -O jdk-8u131-linux-x64.tar.gz jdk-8u131-linux-x64.tar.gzAuthParam=1499664230_984ba136862e0fd6281ac5bc2bee90e2 解压文件 tar xf jdk-8u131-linux-x64.tar.gz 创建要存放的目录并复制解压后的jdk文件到目录下 修改配置文件，指向存放jdk的目录 cd etc(进入etc目录) vi profile（打开profile文件并修改环境变量 source profile（使文件生效) 测试 java -version 能够打印java 版本号信息就表示安装或升级成功","categories":[],"tags":[{"name":"java linux","slug":"java-linux","permalink":"/tags/java-linux/"}]},{"title":"linux环境下Jenkins搭建","slug":"linux环境下Jenkins搭建","date":"2017-11-03T13:46:06.000Z","updated":"2017-11-03T14:30:32.000Z","comments":true,"path":"2017/11/03/linux环境下Jenkins搭建/","link":"","permalink":"/2017/11/03/linux环境下Jenkins搭建/","excerpt":"安装java环境具体查看Linux java环境安装 安装tomcat从tomcat官网上下载最新的安装压缩包，注意区分选择不同操作环境下的压缩包.（Linux一般是 tar.gz，Windows一般用zip压缩包），选择对应的压缩包能保证系统可以直接解压，避免不支持时还需安转压缩工具。 下载压缩包 wget http://apache.fayea.com/tomcat/tomcat-8/v8.5.16/bin/apache-tomcat-8.5.16.tar.gz 解压压缩包 tar xf apache-tomcat-8.5.16.tar.gz 进入解压后的文件夹并将所有的复制到自己要安装的目录下 cd apache-tomcat-8.5.16 cp -rf ./* /usr/local/tomcat/","text":"安装java环境具体查看Linux java环境安装 安装tomcat从tomcat官网上下载最新的安装压缩包，注意区分选择不同操作环境下的压缩包.（Linux一般是 tar.gz，Windows一般用zip压缩包），选择对应的压缩包能保证系统可以直接解压，避免不支持时还需安转压缩工具。 下载压缩包 wget http://apache.fayea.com/tomcat/tomcat-8/v8.5.16/bin/apache-tomcat-8.5.16.tar.gz 解压压缩包 tar xf apache-tomcat-8.5.16.tar.gz 进入解压后的文件夹并将所有的复制到自己要安装的目录下 cd apache-tomcat-8.5.16 cp -rf ./* /usr/local/tomcat/ 安装SDK根据镜像下载sdk包即可，注意最新的sdk可能没有platform tools文件夹，可下在低版本的将platform tolls文件夹移动到最新的sdk文件夹下即可。 有一些插件也可以在没有sdk时自动在Jenkins搭建好后构建时自动下载sdk，如Android Emulator Plugin在配置好后它自己会根据配置参数自动去下载对应的sdk版本，这里后面会说到。 安装Jenkins从Jenkins官网下载并复制jenkins.war到tomcat目录下webapps下。 wget http://mirrors.jenkins.io/war/latest/jenkins.war cp ./jenkins.war /usr/local/tomcat/webapps 启动Tomcat在浏览器中打开http://网址:8080/jenkins/就可以打开Jenkins网页，接下来就可以创建项目，Jenkins玩起来了。 注： 如果要使用其他端口来使用Jenkins可以运行命令： java -jar jenkins.war --httpPort=端口号 java -jar jenkins.war --httpPort=8899 --daemon --logfile=日志路径/jenkins/jenkins.log(在后台运行) 在打开Jenkins网页前要保证对应的端口号可访问，aliyun要配置安全组，开放对应端口。","categories":[],"tags":[{"name":"Jenkins tomcat Linux","slug":"Jenkins-tomcat-Linux","permalink":"/tags/Jenkins-tomcat-Linux/"}]},{"title":"note","slug":"note","date":"2017-11-03T08:56:19.000Z","updated":"2017-12-04T03:24:38.104Z","comments":true,"path":"2017/11/03/note/","link":"","permalink":"/2017/11/03/note/","excerpt":"","text":"hexo官方教程地址http:https://hexo.io/zh-cn/ markdown 教程http:http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-8/","categories":[],"tags":[]},{"title":"Jenkins参数化构建android项目","slug":"Jenkins参数化构建android项目","date":"2017-11-03T01:59:37.000Z","updated":"2017-11-03T15:28:17.000Z","comments":true,"path":"2017/11/03/Jenkins参数化构建android项目/","link":"","permalink":"/2017/11/03/Jenkins参数化构建android项目/","excerpt":"达到的目标： 根据版本类型(release、beta or debug)、版本号、渠道、服务器请求地址等参数进行构建； 构建完成后显示相关构建信息； 展示apk下载二维码、下载地址供直接安装和下载apk 需要的插件： Dynamic Extended Choice Parameter plugin参数化选择需要 Description Setter Plugin构建的信息显示需要 GIt Plugingit 插件","text":"达到的目标： 根据版本类型(release、beta or debug)、版本号、渠道、服务器请求地址等参数进行构建； 构建完成后显示相关构建信息； 展示apk下载二维码、下载地址供直接安装和下载apk 需要的插件： Dynamic Extended Choice Parameter plugin参数化选择需要 Description Setter Plugin构建的信息显示需要 GIt Plugingit 插件 配置项目参数： 设置构建类型参数： 在general模块中复选‘参数化构建过程’，‘添加参数‘中选择’Choice Parameter‘; Name添加参数名，按照Jenkins已有的默认参数集来定义都以大写字母和下划线组成，例：ENVIRONMENT_BUILD，Choices输入item的选项，第一项会变成默认项。 设置列表型参数渠道、版本号、服务器请求地址等： 列表型参数和构建类型一样，设置name、Choices和Description。 配置git参数： 这里首先要保证我们的代码在每个版本都有独立的版本分支，通过不同的版本名来拉取对应的代码，来实现分版本构建。 配置构建命令参数： Tasks输入框输入构建命令行 clean assemble${PRODUCT_FLAVOR_BUILD}${ENVIRONMENT_BUILD}，${参数}表示参数应用，‘PRODUCT_FLAVOR_BUILD’是自定义的参数用来表示构建渠道，‘ENVIRONMENT_BUILD’表示构建类型。 配置构建后描述参数： 在‘构建’模块‘增加构建步骤’列表中选择‘set build description’，在Description输入框输入html代码，例如下，其中的‘${参数}’表示自定义的一些参数，用‘${参数}’来取对应的值。 请求环境：${JENKINS_SERVER_HOST}构建类型：${ENVIRONMENT_BUILD}构建渠道：${PRODUCT_FLAVOR_BUILD}构建版本：${APP_BUILD_VERSION}点击查看二维码点击下载apk 注：如果在构建完后显示还是按照文本显示的，修改一下系统管理／安全配置中‘Markup Formatter‘选择为Safe HTML，来支持html。 配置效果：","categories":[],"tags":[{"name":"Jenkins Android","slug":"Jenkins-Android","permalink":"/tags/Jenkins-Android/"}]}]}