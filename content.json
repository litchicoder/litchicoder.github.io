{"meta":{"title":"litchi","subtitle":"litchi blog","description":null,"author":"litchi","url":""},"pages":[{"title":"404","date":"2020-03-30T13:32:57.615Z","updated":"2017-11-03T08:52:38.000Z","comments":true,"path":"/404.html","permalink":"//404.html","excerpt":"","text":"页面找不到了，回看看吧！"},{"title":"about","date":"2017-11-07T06:59:32.000Z","updated":"2017-11-07T07:00:17.000Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"litchi"}],"posts":[{"title":"一问一答之okhttp篇","slug":"一问一答之okhttp篇","date":"2021-02-05T13:18:01.000Z","updated":"2021-02-07T03:39:11.577Z","comments":true,"path":"2021/02/05/一问一答之okhttp篇/","link":"","permalink":"/2021/02/05/一问一答之okhttp篇/","excerpt":"简单说下OkHttp。 OkHttp默认支持1共享一个scoket完成相同主机的请求，支持Http2.0，头部压缩、连接复用、服务端push，同一主机所有请求共用一个scoket连接；2.连接池，减少请求延迟（https http协议下）3.透明gzip压缩4.响应缓冲，减少不必要的网络请求。","text":"简单说下OkHttp。 OkHttp默认支持1共享一个scoket完成相同主机的请求，支持Http2.0，头部压缩、连接复用、服务端push，同一主机所有请求共用一个scoket连接；2.连接池，减少请求延迟（https http协议下）3.透明gzip压缩4.响应缓冲，减少不必要的网络请求。 网络请求调用流程大致是：首先创建request对象，设置请求地址，方法，header信息，接着OkHttp调用newCall方法传入创建好的request对象，newCall返回RealCall，RealCall执行enqueue执行异步请求，同时传入回调， 请求完成拿到数据，同步请求执行execute方法并返回response对象。 OKHttp中线程池是怎么设置的？Dispatcher.ececuteService()创建了线程池。 1234567public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(\"OkHttp Dispatcher\", false)); &#125; return executorService; &#125; ThreadPoolExecutor参数含义： corePoolSize：0 –核心线程数 即一直保持在线程池中的线程数，即使它们闲置也不会被回收，除非设置了核心线程数超时时间allowCoreThreadTimeOut，设置allowCoreThreadTimeOut后核心线程在闲置时达到超时时间就会被回收。maximumPoolSize：Integer.MAX_VALUE–线程数池中允许的最大线程数；keepAliveTime：60–线程池中非核心线程闲置等待任务时的超时时间；unit：TimeUnit.SECONDS– keepAliveTime的时间单位；workQueue：AsynchronousQueue –工作队列是任务在执行前的容器，任务通过execute方法提交；threadFactory：Util.threadFactory(“OkHttp Dispatcher”, false) –该工厂在创建线程时被使用； 所以OkHttp中的线程池创建时没有核心线程，不限制线程的数量，线程在闲置60s后会被回收，那么是不是说线程池中的线程并行是不做限制的增长，显然不是，Dispatcher还维护了异步请求的两个队列（runningAsyncCalls和readyAsyncCalls），在向runningAsyncCalls队列中添加call时最大请求数是64，这样保证同一时刻最多只有64个请求正在执行，使线程池中线程的增量是可控的。另外还可以自定义线程池配置设置给Dispatcher。 Dispatcher（分发器）主要负责什么？Dispatcher内部维护一个线程池，和三个请求队列（runningAsyncCalls、readyAsyncCalls and runningSyncCalls），负责请求的执行和管理。 拦截器（Interceptor）主要负责什么？拦截器的好处？拦截器是OkHttp中最重要的部分，它负责网络重试、重定向、网络监控、缓冲等功能。拦截器的调用流程是从getResponseWithInterceptorChain方法开始，getResponseWithInterceptorChain方法中创建ApplicatinInterceptorChain，接着调用chain.proceed(request),proceed方法中继续创建ApplicatipnInterceptorChain，将chain传入拦截器interceptor方法中，该方法中会执行chain.proceed(),接着每个拦截器依次都会被调用到，最后在CallServerIntercptor拦截器中返回请求服务器得到的response对象。拦截器调用过程中我们可以自定义应用类拦截器和网络类拦截器，应用类拦截器最先被执行，网络类拦截器会在建立连接后被执行，也就是ConnectInterceptor拦截器被调用之后。 拦截器的这种设计使复杂的网络请求操作分层完成，每一层的拦截器完成自身对请求和响应的任务(各司其职)。 OkHttp内置哪些拦截器，具体负责哪个任务？内置拦截器包括：RetryAndFollowupInterceptor：负责网络重试和重定向；BridgeInterceptor：负责将应用层码转化为网络层码，将header中缺失的网络层特有header补充完整（例如User-Agent，keep-alive）；CacheInterceptor：管理缓冲，缓冲读取和更新；ConnectInterceptor：建立网络连接，是请求服务的基本；CallServerInterceptor：真正发送请求和获取响应数据（将请求写入IO流中，从IO流中读取响应）； 实际业务中用自定义拦截器可以做什么？自定义应用类拦截器：添加请求header 签名（Id 参数 md5） 版本 ；验签失败重试（返回内容中会有重试策略）；自定义日志打印。 自定义网络层拦截器：如果需要打印网络重试、重定向等信息可以使用网络 OkHttp中用到了哪些设计模式？1.建造者模式（Builder模式）适合构造函数入参多而杂的情况下使用：说明：使用一个Builder类一步步构建最终的对象。目标对象是由多个“配置”组合构造出来的。OkHttpClient、Request、Response、Headers、HttpUrl都是用了构造者模式。2.工厂模式：说明：创建目标对象不需要对对象使用者暴露创建逻辑，对外屏蔽对象具体实现，使用者只需关注其接口。CacheStrategy.Factory、ThreadFactory、EventListener.Factory（调用create()根据call创建EventListener）。3.外观模式：说明：统一一个类对调用者提供一系列接口，隐藏内部系统的复杂性。OkHttpClient类 调用者的调用接口都是通过OkHttpClient完成。4.策略模式：说明：一个请求需要经过多个处理者进行责任处理才能完成。没有处理者都有一个特点：前一个处理者对象会持有下一个处理者对象的引用形成一条链，请求发生时，沿着这条链传递。拦截器链。5.单例模式：说明：自己创建自己的唯一实例。OkHttpClient在项目中使用需要用单例。 感谢：https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html","categories":[{"name":"Android基础","slug":"Android基础","permalink":"/categories/Android基础/"}],"tags":[]},{"title":"OkHttp3","slug":"OkHttp3","date":"2021-02-01T04:07:22.000Z","updated":"2021-02-05T13:10:03.764Z","comments":true,"path":"2021/02/01/OkHttp3/","link":"","permalink":"/2021/02/01/OkHttp3/","excerpt":"","text":"本文主要以源码形式解读OkHttp内部实现,源码基于okhttp:3.10.0。 同步请求异步请求的例子先看一个异步请求的例子： 123456789101112131415161718192021222324//(1) builder模式配置参数构建request对象 Request request = new Request.Builder() .url(\"http://baidu.com?key=values\") .get() .build(); //(2)builder构建OkHttpClient对象 new OkHttpClient.Builder().build() .newCall(request)//(3)request入参返回RealCall .enqueue(new okhttp3.Callback() &#123;//(4)请求回调 @Override public void onFailure(Call call, IOException e) &#123; System.out.println(e.getMessage()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; System.out.println(\"thread:\"+Thread.currentThread()); if (response.isSuccessful()) &#123; ResponseBody responseBody = response.body(); data.setText(responseBody.string()); &#125; &#125; &#125;); 上面是一个OkHttp异步请求的代码，先构建一个Request对象设置请求地址、请求方式、header以及非GET请求还可设置body，然后创建OkHttpClient对象调用newCall设置request对象得到RealCall，RealCall调用enqueue发起异步请求并设置请求回调完成了一个简单的异步请求，OkHttpClient在实际开发中需要单例，原因会在后面的内容中有答案。 （1）接下来先看下Request内部：1234567891011121314151617181920212223242526272829303132333435/** * An HTTP request. Instances of this class are immutable if their &#123;@link #body&#125; is null or itself * immutable. */public final class Request &#123; final HttpUrl url; final String method; final Headers headers; final @Nullable RequestBody body; final Object tag; private volatile CacheControl cacheControl; // Lazily initialized. Request(Builder builder) &#123; this.url = builder.url; this.method = builder.method; this.headers = builder.headers.build(); this.body = builder.body; this.tag = builder.tag != null ? builder.tag : this; &#125; /** * Attaches &#123;@code tag&#125; to the request. It can be used later to cancel the request. If the tag * is unspecified or null, the request is canceled by using the request itself as the tag. */ public Builder tag(Object tag) &#123; this.tag = tag; return this; &#125; public Request build() &#123; if (url == null) throw new IllegalStateException(\"url == null\"); return new Request(this); &#125; &#125;&#125; Request包含请求的参数url请求地址、method请求方法、header请求头数据、请求body以及tag标签。 （2）OkHttpClient主要暴露给外部调用,OkHttpClient对象的创建也通过builder模式，这里主要关注它的构造方法：123456789101112131415161718192021222324252627282930313233343536373839404142OkHttpClient(Builder builder) &#123; this.dispatcher = builder.dispatcher;//（1）分发器 this.proxy = builder.proxy;//（2）代理类 this.protocols = builder.protocols;//（3）协议类 this.connectionSpecs = builder.connectionSpecs;//（4）连接规模 确定TLS版本和密码套件 this.interceptors = Util.immutableList(builder.interceptors);//（5）自定义应用拦截器 this.networkInterceptors = Util.immutableList(builder.networkInterceptors);//（6）自定义网络拦截器 this.eventListenerFactory = builder.eventListenerFactory;//（7）事件监听工厂 this.proxySelector = builder.proxySelector;//（8）代理选择器 this.cookieJar = builder.cookieJar; this.cache = builder.cache;//（9）缓冲类 this.internalCache = builder.internalCache;//（10） this.socketFactory = builder.socketFactory;//（11）socket工厂 boolean isTLS = false; for (ConnectionSpec spec : connectionSpecs) &#123; isTLS = isTLS || spec.isTls(); &#125; if (builder.sslSocketFactory != null || !isTLS) &#123; this.sslSocketFactory = builder.sslSocketFactory; this.certificateChainCleaner = builder.certificateChainCleaner; &#125; else &#123; X509TrustManager trustManager = systemDefaultTrustManager(); this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager); this.certificateChainCleaner = CertificateChainCleaner.get(trustManager); &#125; this.hostnameVerifier = builder.hostnameVerifier; this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner( certificateChainCleaner); this.proxyAuthenticator = builder.proxyAuthenticator; this.authenticator = builder.authenticator; this.connectionPool = builder.connectionPool;//（12）连接池 this.dns = builder.dns; this.followSslRedirects = builder.followSslRedirects; this.followRedirects = builder.followRedirects; this.retryOnConnectionFailure = builder.retryOnConnectionFailure; this.connectTimeout = builder.connectTimeout; this.readTimeout = builder.readTimeout; this.writeTimeout = builder.writeTimeout; &#125; （12）OkHttp创建了自己的连接池所以在使用过程中要用单例。 （3）接着调用了OkHttpClient.newCall(req):123456/** * Prepares the &#123;@code request&#125; to be executed at some point in the future. */ @Override public Call newCall(Request request) &#123; return RealCall.newRealCall(this, request, false /* for web socket */); &#125; newCall方法内部调用RealCall.newRealCall方法并返回Call对象： 123456static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; // Safely publish the Call instance to the EventListener. RealCall call = new RealCall(client, originalRequest, forWebSocket);//(1) call.eventListener = client.eventListenerFactory().create(call);//(2) return call; &#125; (1)创建RealCall对象；RealCall对象持有OkHttpClient和Request，构造方法中还创建了重试/重定向拦截器RetryAndFollowInterceptor；(2)从OkHttpClient得到evenListener对象， （4）调用异步请求RealCall.enqueue方法:123456789@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already Executed\");（1） executed = true; &#125; captureCallStackTrace();（2） eventListener.callStart(this);（3） client.dispatcher().enqueue(new AsyncCall(responseCallback));//（4） &#125; （1）如果call已经被执行，抛出异常；（2） 捕获RealCall类的栈轨迹；（3）触发监听方法callStart(),表示请求开始；（4）执行dispatcher分发器enqueue方法，创建了AsyncCall类，AsyncCall传入responseCallback。 下面查看dispatcher的enqueue方法： 12345678synchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;//（1） runningAsyncCalls.add(call);//（2） executorService().execute(call);//（3） &#125; else &#123; readyAsyncCalls.add(call);//（4） &#125; &#125; （1）把call添加到正在运行的队列的判断依据：如果正在执行的异步请求数小于最大请求数（默认64），并且同一个主机执行的异步请求小于单个主机运行的最大请求数（默认5）否则添加到准备队列； （2）根据（1）把call添加到正在运行的队列； （3）将call交线程池执行； （4）不满足（1）把call添加到准备队列。AsyncCall是Runnable实现类，execute方法完成请求和返回的执行。AsyncCall. execute(): 1234567891011121314151617181920212223@Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain();//（1） if (retryAndFollowUpInterceptor.isCanceled()) &#123;//（2） signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response);//（3） &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e); &#125; else &#123; eventListener.callFailed(RealCall.this, e);//（4） responseCallback.onFailure(RealCall.this, e);//（5） &#125; &#125; finally &#123; client.dispatcher().finished(this);//（6） &#125; &#125; （1）getResponseWithInterceptorChain方法得到response对象，getResponseWithInterceptorChain是核心实现，后边专门展开说明； （2）请求如果取消返回，调用responseCallback.onFailure通知处理请求失败； （3）否则正常请求返回，调用responseCallback.onResponse返回response对象，调用方就可以拿到请求的数据返回，做具体业务处理； （4）（5）回调执行eventListener.callFailed和responseCallback.onFailure； （6）dispatcher执行finished方法，finish内部会调用promoteCalls方法从readyAsyncCalls队列中取出call 添加到runningAsyncCalls中，executorService().execute(call)加入线程池中执行call。添加到runningAsyncCalls中的条件是小于运行runningAsyncCalls最大call数并且同一主机call数小于maxRequestsPerHost（即同一主机最大请求数）。 接下来分析核心方法getResponseWithInterceptorChain(): 12345678910111213141516171819Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors());//(1) interceptors.add(retryAndFollowUpInterceptor);//(2) interceptors.add(new BridgeInterceptor(client.cookieJar()));//(3) interceptors.add(new CacheInterceptor(client.internalCache()));//(4) interceptors.add(new ConnectInterceptor(client));//(5) if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors());//(6) &#125; interceptors.add(new CallServerInterceptor(forWebSocket));//(7) Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest);//(8) &#125; （1）构建全部拦截器list，先添加自定义应用层拦截器；（2）添加重试/重定向拦截器；（3）添加桥接拦截器；（4）添加缓冲拦截器；（5）添加连接拦截器；（6）如果不是websocket，添加自定义网络拦截器；（7）添加请求服务拦截器；（8）传入拦截器list，请求，call对象，事件监听，连接超时时间以及读写超时时间生成Interceptor.Chain链对象，执行chain.proceed(originalRequest)。 chain.proceed(originalRequest)： 12345678910111213141516171819202122232425262728293031323334353637383940414243public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; // If we already have a stream, confirm that the incoming request will use it. if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123; throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1) + \" must retain the same host and port\"); &#125; // If we already have a stream, confirm that this is the only call to chain.proceed(). if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123; throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1) + \" must call proceed() exactly once\"); &#125; // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next);//(1) // Confirm that the next interceptor made its required call to chain.proceed(). if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123; throw new IllegalStateException(\"network interceptor \" + interceptor + \" must call proceed() exactly once\"); &#125; // Confirm that the intercepted response isn't null. if (response == null) &#123; throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\"); &#125; if (response.body() == null) &#123; throw new IllegalStateException( \"interceptor \" + interceptor + \" returned a response with no body\"); &#125; return response; &#125; (1)创建下一个RealInterceptorChain，将chain传入interceptor.intercept方法，intercept中会执行nextchain.proceed方法，然后再继续创建下一个RealInterceptorChain，intercept再执行下一个nextchain.proceed方法，这样循环调用所有拦截器，到最后一个拦截器CallServerInterceptor停止遍历，返回response，遍历循环流程如下图： 接下来阅读自带的拦截器代码： RetryAndFollowUpInterceptor： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788@Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; Call call = realChain.call(); EventListener eventListener = realChain.eventListener(); StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace);//（1） this.streamAllocation = streamAllocation; int followUpCount = 0; Response priorResponse = null; while (true) &#123; if (canceled) &#123; streamAllocation.release();//（2） throw new IOException(\"Canceled\"); &#125; Response response; boolean releaseConnection = true; try &#123; response = realChain.proceed(request, streamAllocation, null, null);//（3） releaseConnection = false; &#125; catch (RouteException e) &#123; // The attempt to connect via a route failed. The request will not have been sent. if (!recover(e.getLastConnectException(), streamAllocation, false, request)) &#123; throw e.getLastConnectException();//（4） &#125; releaseConnection = false; continue; &#125; catch (IOException e) &#123; // An attempt to communicate with a server failed. The request may have been sent. boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, streamAllocation, requestSendStarted, request)) throw e; releaseConnection = false;//（5） continue; &#125; finally &#123; // We're throwing an unchecked exception. Release any resources. if (releaseConnection) &#123;//（6） streamAllocation.streamFailed(null); streamAllocation.release(); &#125; &#125; // Attach the prior response if it exists. Such responses never have a body. if (priorResponse != null) &#123;//（7） response = response.newBuilder() .priorResponse(priorResponse.newBuilder() .body(null) .build()) .build(); &#125; Request followUp = followUpRequest(response, streamAllocation.route());//（8） if (followUp == null) &#123;//（9） if (!forWebSocket) &#123; streamAllocation.release(); &#125; return response; &#125; closeQuietly(response.body());//（10） if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;//（11） streamAllocation.release(); throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount); &#125; if (followUp.body() instanceof UnrepeatableRequestBody) &#123;//（12） streamAllocation.release(); throw new HttpRetryException(\"Cannot retry streamed HTTP body\", response.code()); &#125; if (!sameConnection(response, followUp.url())) &#123;//（13） streamAllocation.release(); streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(followUp.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; &#125; else if (streamAllocation.codec() != null) &#123;//（14） throw new IllegalStateException(\"Closing the body of \" + response + \" didn't close its backing stream. Bad interceptor?\"); &#125; request = followUp;//（15） priorResponse = response;//（16） &#125;&#125; （1）StreamAllocation用来协调连接（Connections）、流（Screams）和请求队列（Calls）；（2）如果请求取消，调用screamAllocation.release()。release方法会关闭socket，并回调 eventListener.connectionReleased。（3）执行realChain.proceed方法，proceed内部会创建下一个chain，再传入下一个拦截器，拦截器intercept继续执行负责的工作，并调用chain.proceed()。（4）如果realChain.proceed方法抛出RouteException，那么调用recover方法，recover方法返回false则不会重试连接，抛出IOException异常，异常会在Call.execute方法中捕获执行eventListener.callFailed和onFailure方法，返回false的条件如下： 1.应用层禁止重试 ；2.定义了不可重复发送的请求body ；3.捕获的异常严重等级属于致命 ；4.没有更多的路由可重意重试； 如果上述的四种场景，请求会被发起重试。 （5）IOException,同样调用recover方法，按照（4）中逻辑判断是否重连；（6）如果抛出没有catch的异常则执行StreamAllocation.screamFailed()和StreamAllocation.screamFailed；（7）priorResponse是先前得到的响应数据，如果已经先前响应不为空，response会结合先前响应；（8）根据响应码确认请求是否需要重定向，返回null表示不需要；（9）不需要重定向就streamAllocation.release()释放连接并返回response，否则执行下面逻辑；（10）释放response.body对象；（11）当前重定向数大于最大可重定向数，则释放连接，抛出异常；（12）请求不允许重复连接，则释放连接，抛出异常；（13）检查是否是相同的连接，不是就释放当前连接，重新创建ScreamAllocation；（14）codec为空抛出异常；（15）重定向request赋值request，准备执行while循环；（16）保存当前的response。 BridgeInterceptor： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Override public Response intercept(Chain chain) throws IOException &#123; Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); RequestBody body = userRequest.body(); if (body != null) &#123; MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header(\"Content-Type\", contentType.toString());//（1） &#125; long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header(\"Content-Length\", Long.toString(contentLength)); requestBuilder.removeHeader(\"Transfer-Encoding\"); &#125; else &#123; requestBuilder.header(\"Transfer-Encoding\", \"chunked\"); requestBuilder.removeHeader(\"Content-Length\"); &#125; &#125; if (userRequest.header(\"Host\") == null) &#123; requestBuilder.header(\"Host\", hostHeader(userRequest.url(), false)); &#125; if (userRequest.header(\"Connection\") == null) &#123; requestBuilder.header(\"Connection\", \"Keep-Alive\"); &#125; // If we add an \"Accept-Encoding: gzip\" header field we're responsible for also decompressing // the transfer stream. boolean transparentGzip = false; if (userRequest.header(\"Accept-Encoding\") == null &amp;&amp; userRequest.header(\"Range\") == null) &#123; transparentGzip = true; requestBuilder.header(\"Accept-Encoding\", \"gzip\"); &#125; List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) &#123; requestBuilder.header(\"Cookie\", cookieHeader(cookies)); &#125; if (userRequest.header(\"User-Agent\") == null) &#123; requestBuilder.header(\"User-Agent\", Version.userAgent()); &#125; Response networkResponse = chain.proceed(requestBuilder.build()); HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); if (transparentGzip &amp;&amp; \"gzip\".equalsIgnoreCase(networkResponse.header(\"Content-Encoding\")) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll(\"Content-Encoding\") .removeAll(\"Content-Length\") .build(); responseBuilder.headers(strippedHeaders); String contentType = networkResponse.header(\"Content-Type\"); responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody))); &#125; return responseBuilder.build(); &#125; 桥接拦截器主要功能：1.将应用码转为网络码；2.用户请求转为网络请求 CacheInterceptor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596@Override public Response intercept(Chain chain) throws IOException &#123; Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis();//（1） CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; if (cache != null) &#123; cache.trackResponse(strategy); &#125; if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;//（2） closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. &#125; // If we're forbidden from using the network and the cache is insufficient, fail. if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;//（3） return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(\"Unsatisfiable Request (only-if-cached)\") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // If we don't need the network, we're done. if (networkRequest == null) &#123;//（4） return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body());//（5） &#125; &#125; // If we have a cache response too, then we're doing a conditional get. if (cacheResponse != null) &#123;//（6） if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125;//（7） Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response);//（8） return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response; &#125; （1）获取缓冲策略；（2）缓冲策略不为空，缓冲响应为空时，关闭缓冲策略；（3）网络被禁止，缓冲不存在时，返回失败；（4）不需要网络，返回缓冲响应，缓冲生效；（5）执行chain.proceed方法抛出异常时，关闭缓冲；（6）有缓冲时根据条件使用缓冲响应；（7）使用网络响应；（8）给予本请求缓冲（添加到缓冲中）； ConnectInterceptor 123456789101112@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(\"GET\"); HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection();//（1） return realChain.proceed(request, streamAllocation, httpCodec, connection); &#125; （1）获得RealConnection对象，调用下一个chain.proceed。 CallServerInterceptor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 @Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream(); StreamAllocation streamAllocation = realChain.streamAllocation(); RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); realChain.eventListener().requestHeadersStart(realChain.call()); httpCodec.writeRequestHeaders(request);//(1) realChain.eventListener().requestHeadersEnd(realChain.call(), request); Response.Builder responseBuilder = null; if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; // If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100 // Continue\" response before transmitting the request body. If we don't get that, return // what we did get (such as a 4xx response) without ever transmitting the request body. if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) &#123; httpCodec.flushRequest(); realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(true); &#125; if (responseBuilder == null) &#123; // Write the request body if the \"Expect: 100-continue\" expectation was met. realChain.eventListener().requestBodyStart(realChain.call()); long contentLength = request.body().contentLength(); CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, contentLength)); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody);//（2） bufferedRequestBody.close(); realChain.eventListener() .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); &#125; else if (!connection.isMultiplexed()) &#123; // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection // from being reused. Otherwise we're still obligated to transmit the request body to // leave the connection in a consistent state. streamAllocation.noNewStreams(); &#125; &#125; httpCodec.finishRequest(); if (responseBuilder == null) &#123; realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(false);//（3） &#125; Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); int code = response.code(); if (code == 100) &#123; // server sent a 100-continue even though we did not request one. // try again to read the actual response responseBuilder = httpCodec.readResponseHeaders(false); response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); code = response.code(); &#125; realChain.eventListener() .responseHeadersEnd(realChain.call(), response);//（4） if (forWebSocket &amp;&amp; code == 101) &#123; // Connection is upgrading, but we need to ensure interceptors see a non-null response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); &#125; if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\")) || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) &#123; streamAllocation.noNewStreams(); &#125; if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123; throw new ProtocolException( \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength()); &#125; return response; &#125; （1）写入请求头数据；（2）写入请求body数据；（3）读取响应头数据；（4）读取响应body数据。 完整异步请求调用流程：","categories":[{"name":"Android基础","slug":"Android基础","permalink":"/categories/Android基础/"}],"tags":[]},{"title":"Android组件化","slug":"Android组件化","date":"2021-01-30T11:32:57.000Z","updated":"2021-02-01T05:50:03.754Z","comments":true,"path":"2021/01/30/Android组件化/","link":"","permalink":"/2021/01/30/Android组件化/","excerpt":"Android应用达到一定规模后业务会越来越多，所有业务模块在同一module下耦合性会越来越强，这种强耦合带来开发维护成本增加，开发调试效率也会变低，项目组件化就势在必行。","text":"Android应用达到一定规模后业务会越来越多，所有业务模块在同一module下耦合性会越来越强，这种强耦合带来开发维护成本增加，开发调试效率也会变低，项目组件化就势在必行。 组件化带来的优点：1.项目模块清晰，组件向内高聚合，对外低耦合；2.项目成员可以专注于具体组件内业务逻辑，降低开发成本；3.可以独立调试，提升开发调试效率；4.可以产出全局功能组件，服务于整个团队，快速响应新项目，达到功能重用。 要实现组件化需要解决问题：1.组件间页面如何跳转？2.组件间如何实现功能调用？3.如何独立组件或随意组合组件进行调试？4.如何在各个组件间获取Application实例？5.如何实现组件间代码隔离？ 解决方式针对以上五点问题找到以下五个解决方式：1.利用路由框架实现页面也跳转，如ARoute，或者自行定义的路有跳转协议；2.利用依赖注入实现组件间通信，调用方利用接口申明实现调用；3.Android gradle提供两种插件，com.android.application表示App Module，com.android.library表示库Module，通过在gradle.properties中设置参数控制Module的插件类型制定App module，同时配置module的Application和manifest文件，这样就可以独立运行需要调整的module。4.设计module_common组件创建BaseApplication，App壳module工程Application继承至BaseApplication，其他组件依赖module_common这样就拿到了Application实例。5.组件之间不存在相互依赖，不能直接调用，它们都依赖到App壳module，这样就完成了组件间的隔离。 组件化框架结构：","categories":[{"name":"Android基础","slug":"Android基础","permalink":"/categories/Android基础/"}],"tags":[]},{"title":"Handler","slug":"Handler","date":"2021-01-27T13:34:12.000Z","updated":"2021-01-30T05:53:34.485Z","comments":true,"path":"2021/01/27/Handler/","link":"","permalink":"/2021/01/27/Handler/","excerpt":"本篇分为三个部分记录Handler消息机制，第一部分逐一对“四件套”源码（基于Android-29）进行解读；第二部分根据源码总结它们之间的关联；第三部分对Handler涉及到的问题进行解答。","text":"本篇分为三个部分记录Handler消息机制，第一部分逐一对“四件套”源码（基于Android-29）进行解读；第二部分根据源码总结它们之间的关联；第三部分对Handler涉及到的问题进行解答。 四件套Message-消息Message的作用是消息载体本身，Message类内部主要是关键参数和创建方法。官方推荐使用Mesage.obtain()或者Handler.obtainMessage()来创建Message对象，利用缓冲中Message，避免了重复创建对象。这两个方法的内法调用： 1234567891011121314151617/** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */ public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message(); &#125; 1234567891011121314151617181920212223/** * Returns a new &#123;@link android.os.Message Message&#125; from the global message pool. More efficient than * creating and allocating new instances. The retrieved message has its handler set to this instance (Message.target == this). * If you don't want that facility, just call Message.obtain() instead. */ @NonNull public final Message obtainMessage() &#123; return Message.obtain(this); &#125; //Handler.obtainMessage()内部又调用了Message.obtain(handler) /** * Same as &#123;@link #obtain()&#125;, but sets the value for the &lt;em&gt;target&lt;/em&gt; member on the Message returned. * @param h Handler to assign to the returned Message object's &lt;em&gt;target&lt;/em&gt; member. * @return A Message object from the global pool. */ public static Message obtain(Handler h) &#123; Message m = obtain(); m.target = h; return m; &#125; Handler.obtainMessage()其实是调用到了Message中的obtain()区别只是入参handler重新给message的target赋值，所以只需要关注Message.obtain()，sPool以链表形式存储了缓冲的Message对象，缓冲Message的链表不为空时就从尾部取出一个Message，为空直接创建。至于这里sPool中的Message是在什么时机缓冲起来,它其实是在looper的loop方法处理Message后调用msg.recycleUnchecked()加入到sPool缓冲池。 接下来说明Message中几个关键变量。what是Message的唯一标示，来区分发送的Message，what值在不同handler是不需要考虑code冲突。 1234567/** * User-defined message code so that the recipient can identify * what this message is about. Each &#123;@link Handler&#125; has its own name-space * for message codes, so you do not need to worry about yours conflicting * with other handlers. */ public int what; arg1和arg2用来传递数据是int类型的数据，obj是Object类型，可以传递所有继承Object的数据类型，如果Message用在跨进程通信时obj需要进行序列化; 12345678910111213141516171819202122232425/** * arg1 and arg2 are lower-cost alternatives to using * &#123;@link #setData(Bundle) setData()&#125; if you only need to store a * few integer values. */ public int arg1; /** * arg1 and arg2 are lower-cost alternatives to using * &#123;@link #setData(Bundle) setData()&#125; if you only need to store a * few integer values. */ public int arg2; /** * An arbitrary object to send to the recipient. When using * &#123;@link Messenger&#125; to send the message across processes this can only * be non-null if it contains a Parcelable of a framework class (not one * implemented by the application). For other data transfer use * &#123;@link #setData&#125;. * * &lt;p&gt;Note that Parcelable objects here are not supported prior to * the &#123;@link android.os.Build.VERSION_CODES#FROYO&#125; release. */ public Object obj; when字段表示发送消息的时间字段，基准时间是SystemClock.uptimeMillis()，如果设置了发送延时时间when的值就是基准时间加延时时间; 123456/** * The targeted delivery time of this message. The time-base is * &#123;@link SystemClock#uptimeMillis&#125;. * @hide Only for use within the tests. */ public long when; data类型同样用来传递数据，data是Bundle类型，可以像Activity间传递消息一样设置key-values键值对交换数据; 1Bundle data; target是handler的引用, target的主要作用是在Looper的loop方法中用来分发Message; 1Runnable callback; Message还可以设置callback参数，在消息被Looper处理时调用Message的Runnable.run(),用在Message需要一一对应不同的Runnable。 MessageQueue-消息队列维护Message链表MessageQueue是以链表形式存储Message对象，enqueueMessage()插入对象并返回操作结果。next()主要作用是从Queue读取Message并从链表中移除，postSyncBarrier()用于在Queue中添加同步屏障。 MessageQueue.enqueueMessage() ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123;//(1) IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; (1)Looper调用quit()后停止Message插入。接下来的执行流程主要是链表的插入操作还有是否需要唤醒Looper轮询，判断依据是mBlocked（阻塞）和p.isAsynchronous()两个因素。 MessageQueue.next(): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123;(1) return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis);//(2) synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123;//(3) // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse(); return msg;//(4) &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; //(5) // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125; &#125; (1)Looper调用quit()后停止执行。(2)nativePollOnce()用于“等待”消息，知道下一条Message可用为止。(3)这里是一种同步屏障机制，target==null作为同步屏障开启的标志循环找到一个异步消息，下面的操作中优先执行异步消息。同步屏障具体深入会在后面部分说明。(4)链表中删除目标Message并返回。(5)MessageQueue中没有Message时执行Idlehandler（闲时机制），Idlehandler.queueIdle()返回true，Idlehandler回调会在mIdleHandlers中保持存在，false回调执行完成后从mIdleHandlers中移除。 MessageQueue.postSyncBarrier(): 12345678910111213141516171819202122232425262728private int postSyncBarrier(long when) &#123; // Enqueue a new sync barrier token. // We don't need to wake the queue because the purpose of a barrier is to stall it. synchronized (this) &#123; final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) &#123; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; // invariant: p == prev.next msg.next = p; prev.next = msg; &#125; else &#123; msg.next = p; mMessages = msg; &#125; return token; &#125; &#125; 方法内部就是创建一个target为null的Message，在next方法中利用target等于null作为依据来判断是否设置同步屏障。同样对应removeSyncBarrier就是利用Message的token字段找到设置的同步屏障Message移除。 Looper-消息循环器Looper主要职责是创建MessageQueue和处理Message。prepare方法创建looper对象添加到sThreadLocal中，Looper构造方法中同时创建MessageQueue。loop方法通过调用MessageQueue.next方法取出Message，调用msg.target的handleMessage方法交给对应handler处理Message。 prepare()和构造方法: 123456789101112131415161718/** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; //构造方法 private Looper(boolean quitAllowed) &#123;（1） mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; (1)quitAllowed 为true表示允许停止,这里构造方法是私有的，public修饰的无参构造调用这里时传入true，所以我们在日常使用中，在工作线程创建的looper都是允许停止的，只有UI线程的looper是不允许停止。也就是我们不能通过Looper.quit()来停止主线程的looper，可以这样理解，如果主线的looper停止也就相当于应用程序停止工作。 loop(): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start' final int thresholdOverride = SystemProperties.getInt(\"log.looper.\" + Process.myUid() + \".\" + Thread.currentThread().getName() + \".slow\", 0); boolean slowDeliveryDetected = false; for (;;) &#123;//（1） Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; // Make sure the observer won't change while processing a transaction. final Observer observer = sObserver; final long traceTag = me.mTraceTag; long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride &gt; 0) &#123; slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; &#125; final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0); final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; Object token = null; if (observer != null) &#123; token = observer.messageDispatchStarting(); &#125; long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid); try &#123; msg.target.dispatchMessage(msg);//（2) if (observer != null) &#123; observer.messageDispatched(token, msg); &#125; dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; catch (Exception exception) &#123; if (observer != null) &#123; observer.dispatchingThrewException(token, msg, exception); &#125; throw exception; &#125; finally &#123; ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logSlowDelivery) &#123; if (slowDeliveryDetected) &#123; if ((dispatchStart - msg.when) &lt;= 10) &#123; Slog.w(TAG, \"Drained\"); slowDeliveryDetected = false; &#125; &#125; else &#123; if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, \"delivery\", msg)) &#123; // Once we write a slow delivery log, suppress until the queue drains. slowDeliveryDetected = true; &#125; &#125; &#125; if (logSlowDispatch) &#123; showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, \"dispatch\", msg); &#125; if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycleUnchecked();//(3) &#125; &#125; (1)无限循环中queue调用next读取Message对象；(2)调用hanlder.dispachMessage方法将Message交给handler处理；(3)回收Message缓冲池未满时重置数据将Message添加到缓冲池。 Hndler-消息处理器Hndler负责发送Message和处理回调的各种Message，enqueueMessage方法发送消息，将消息添加到queue中，handleMessage方法处理回调回来Message，Handler中的方法在开发中经常会直接使用。removeMessages方法移除当前handler下的Message，内部调用MessageQueue.removeMessages,同样的方法还有removeCallbacks()和 12345678910111213141516171819202122/** public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Remove any pending posts of callbacks and sent messages whose * &lt;var&gt;obj&lt;/var&gt; is &lt;var&gt;token&lt;/var&gt;. If &lt;var&gt;token&lt;/var&gt; is null, * all callbacks and messages will be removed. */ public final void removeCallbacksAndMessages(@Nullable Object token) &#123; mQueue.removeCallbacksAndMessages(this, token); &#125; //MessageQueue.removeCallbacksAndMessages void removeCallbacksAndMessages(Handler h, Object object) &#123; if (h == null) &#123; return; &#125; synchronized (this) &#123; Message p = mMessages; // Remove all messages at front. while (p != null &amp;&amp; p.target == h &amp;&amp; (object == null || p.obj == object)) &#123; Message n = p.next; mMessages = n; p.recycleUnchecked(); p = n; &#125; // Remove all messages after front. while (p != null) &#123; Message n = p.next; if (n != null) &#123; if (n.target == h &amp;&amp; (object == null || n.obj == object)) &#123; Message nn = n.next; n.recycleUnchecked(); p.next = nn; continue; &#125; &#125; p = n; &#125; &#125; &#125; hanlder中的发送Message和移除Message都是调用MessageQueue对链表做操作。 关联上面对源码的解读，大致对各自的职责有了了解，这里对它们之间的联系做说明。 MessageQueue是以Message作为内容的链表结构，可以将Message插入到MessageQueue中，也可以将Message从MessageQueue中删除。Looper负责循环读取MessageQueue中的Message，将Message调用给handler完成Message消息传递。Handler负责将创建好的Message发送给MessageQueue，MessageQueue将其插入到链表中，同时Handler最终接收Looper从MessageQueue中读取的Message执行它的处理方法handleMessage。 为什么？ Handler消息机制的作用？用于跨线程通信，Android中因为UI线程不能执行耗时操作，所以需要将耗时任务在子线程执行，子线程又不能更新UI，此时就需要handler通知UI线程执行UI操作。同样子线程与子线程也可以通过Handler通信。 什么是闲时机制？IdleHandler是一个回调接口，它存储在一个数组中，当MessageQueue中的Message任务暂时停止处理（没有新任务或者下一任务延迟在后），这个时候就会调用这个接口的queueIdle()，方法返回false则会从list中移除，返回true在下次MessageQueue暂停处理时继续调用这个接口的queueIdle方法（代码在MessageQueue.next()）。 什么是同步屏障？同步屏障就是把同步消息先屏蔽优先处理异步消息，调用MessageQueue.postSyncBarrier方法可以将一个target为空的Message插入到MessageQueue中，当Looper调用MessageQueue.next方法读取Message时首先会通过target为空来判断是否设置同步屏障，若存在，会先遍历消息链表跳过同步消息找到异步消息优先将异步消息返回给Looper执行调用。这是一种优先机制，把异步消息的优先级高于同步消息，ViewRootImpl.scheduleTraversals方法就使用了同步屏障，保证UI绘制优先执行(performTraversals())。 12345678910111213void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125; &#125; mTraversalRunnable是一个Runnable对象，run方法中会调用performTraversals()执行UI绘制。 Looper.loop()为什么不会阻塞主线程？loop方法会调用MessageQueue中next方法，next()调用本地方法nativePollOnce，没有新消息时会阻塞到nativePollOnce方法，nativePollOnce方法内部是基于Linux epoll机制实现阻塞，此时主线程会进入休眠状态，不会消耗cpu资源（pip管道当有数据写入时再唤醒主线程工作）。引起ANR的原因是由于执行事件耗时太长，不能及时完成，而loop方法本身只是不停的循环读取消息，当有消息时loop是不会阻塞的，只有loop发送的事件耗时太长才会导致ANR。Activity的onCreate onResume 等生命周期回调方法操作时间太长才会导致卡死主线程掉帧甚至发生ANR（Activity一般超过5s就会发生ANR）。 Thread、Hanlder、Looper和MessageQueue的数量级关系？一个Thread可以有多个Handler，只有有一个Looper和MessageQueue,多个Handler创建的Message都添加到同一个MessageQueue中，Looper从MessageQueue中拿到Message通过Hadnler对象target分发到对应Handler处理回调。Thread(1)==&gt;Looper(1)==&gt;MessageQueue(1)==&gt;Handler(N) 引起内存泄漏的原因以及解决方案？原因：由于java的特性，内部类会持有外部类的引用，所以Handler会持有Activity，Message中target对象又是Handler的引用，所以Message就持有了Activity，Activity调用销毁后如果当前HandlerMessage还在MessageQueue中，导致Activity不能被及时回收。解决方案：将Handler定义为静态内部类，持有Activity的弱引用并在Activity销毁时调用removeCallBacksAndMessages(null)移除所有消息。 Handler发送一个延时消息是怎么更新MessageQueue？如果此时MessageQueue中只有这个延时消息，消息不会被马上发送，而是计算唤醒时间让Looper阻塞，到唤醒时间时再唤醒Looper执行消息发送。如果MessageQueue中还有Message，延时消息被插入到时间排序的对应位置，MessageQueue中对头的when值最小，越往队尾值越大。","categories":[{"name":"Android基础","slug":"Android基础","permalink":"/categories/Android基础/"}],"tags":[]},{"title":"java局部内部类访问局部变量时为什么需要final来修饰？","slug":"java局部内部类访问局部变量时为什么需要final来修饰？","date":"2021-01-12T10:10:41.000Z","updated":"2021-01-12T13:00:52.233Z","comments":true,"path":"2021/01/12/java局部内部类访问局部变量时为什么需要final来修饰？/","link":"","permalink":"/2021/01/12/java局部内部类访问局部变量时为什么需要final来修饰？/","excerpt":"","text":"123456789101112131415161718private void test() &#123; final String str = \"23\"; Thread t= new Thread(new Runnable() &#123; public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"str:\"+str); &#125; &#125;); t.start(); &#125; test()是一个类的方法，Runnable是它的匿名内部类，局部变量str用了final修饰符，如果没有final修饰符将会报错，为什么呢？ test()方法对应虚拟机栈中的一个栈帧，当该栈帧出栈后其局部变量也就销毁，然这时存在内部类的方法需要访问str，就出现了生命周期不一致的情况，所以需要使用final将str变为常量来保证一致性。","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/categories/JAVA基础/"}],"tags":[]},{"title":"2020结","slug":"2020结","date":"2020-12-23T09:55:44.000Z","updated":"2021-01-12T11:19:48.508Z","comments":true,"path":"2020/12/23/2020结/","link":"","permalink":"/2020/12/23/2020结/","excerpt":"","text":"2020年对于社会这个大环境来说是艰难的一年，对于我个人来说更是变动的一年，离开了从实习到如今四年的老东家，开始了一年的漂泊，到了年底还没有稳定下来，不过一年过来庆幸自己没有妥协，一直还在不断调整和思考。 2020就这样写下了记号，工作上这一年是没有成果的，物质和精神都没有，当然这些也不是年初计划太过于关注的点。2020如果说有一点点收获的话那是在生活状态和心理变化上，之前一直唯利，如今停下这个脚步也该看看走的稳不稳，走的累不累，当然也要感谢那几年的累积，才能让现在看的更明了一些，如果比作爬山，我觉得过去的四年我是前两年用力很猛，后两年有些疲软，这一年停下了脚步歇歇脚，有点冷热不均的意思，接下来该怎么走呢？平衡，生活与工作、休息与忙碌、亲情和还没来的爱情，2021年我要尝试去平衡这些，当前生命健康是第一。 过去决定现在，现在影响将来，2021我的生活会是不同以往的，预感会有很大的变化，且拭目以待。 2021伊始，感谢将出现在我生命里的可爱的人们。3q！","categories":[{"name":"年终总结","slug":"年终总结","permalink":"/categories/年终总结/"}],"tags":[]},{"title":"View绘制","slug":"View绘制","date":"2020-06-02T04:55:22.000Z","updated":"2020-12-29T13:29:10.206Z","comments":true,"path":"2020/06/02/View绘制/","link":"","permalink":"/2020/06/02/View绘制/","excerpt":"","text":"View的绘制流程 View的绘制是从ViewRootImpl类的performTraversals方法开始经过measure、layout、draw三个过程将View绘制出来的，measure方法用来测量ViewGroup/View的宽高，layout用来确定View的最终宽高和在容器内的位置，draw绘制View到屏幕上。 performTraversals方法会依次调用perfomrMeasure，performLayout和performDraw，这三个方法依次调用底层View的绘制流程，也就是调用onMeasure、onLayout和onDraw，三个方法通过递归方式完成整个布局的绘制。 MeasureSpecMeasureSpec可以理解为“测量规则”或“测量标准”。MeasureSpec用一个32位的int值来表示，高2位代表SpecMode（测量模式），低30位代表SpecSize（规格大小）。代码定义这样的： 1234567891011121314151617181920212223242526272829303132333435363738394041private static final int MODE_SHIFT = 30;private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The parent has not imposed any constraint * on the child. It can be whatever size it wants. */public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;/** * Measure specification mode: The parent has determined an exact size * for the child. The child is going to be given those bounds regardless * of how big it wants to be. */public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT;/** * Measure specification mode: The child can be as large as it wants up * to the specified size. */public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT;public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size, @MeasureSpecMode int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125;&#125;@MeasureSpecModepublic static int getMode(int measureSpec) &#123; //noinspection ResourceType return (measureSpec &amp; MODE_MASK);&#125;public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK);&#125; 代码里可以看到MeasureSpec将SpecMode和SpecSize打包成一个int值，这样可以避免过多的内存分配，getMode和getSize方法利用MODE_MASK与操作来得到需要的mode和size值。SpecMode有三种模式： UNSPECIFIED：[ʌnˈspesɪfaɪd]未说明的，没有明确的。父容器对于View没有任何限制，想要多大就给多大。 EXACTLY：[ɪɡˈzæktli] 明确的。它对应LayoutParams中的match_parent或指定大小值的两种场景。父容器给出了一个确定的范围，如果view设置了具体值这个具体没有超出给定的范围那么就是这个具体值，如果超出了那view的大小就是父容器给定的限制值或者直接就指定限制值也就是match_parent的场景 AT_MOST:view想要多大就是多大，至到达到指定的值。对应LayoutParams中的wrap_content。 这三个值的设置是站在父容器的角度衡量view的，UNSPECIFIED是父容器没有对view做限制，EXACTLY是父容器给出了一个明确限制值（最大边界）来约束view，AT_MOST则是按照view的想要的来展示，但也有指定值来限定。 对于一个普通的View，它的MeasureSpec是由父容器的MeasureSpec和自身设置的LayoutParam参数来决定的，比如View设置了固定的宽或者高那么它在宽或者高方向上的SpecMode就是EXCATLY，无论它的父容器设置什么测量模式 View的绘制流程和activity的生命周期是不同步的，所以在onresume中直接获得view宽高是错误的，可以痛殴VIewTreeObser监听绘制过程或者通过View.post方法投递一个消息队列到尾部，等待looper调用该runnable时view已经初始化 postscript：getMeasureWidth和getWidth的区别","categories":[{"name":"Android基础","slug":"Android基础","permalink":"/categories/Android基础/"}],"tags":[{"name":"Android基础","slug":"Android基础","permalink":"/tags/Android基础/"}]},{"title":"View事件传递","slug":"View事件传递","date":"2020-06-01T03:52:08.000Z","updated":"2020-06-01T05:44:28.286Z","comments":true,"path":"2020/06/01/View事件传递/","link":"","permalink":"/2020/06/01/View事件传递/","excerpt":"","text":"MotionEventMotionEvent是View的动作事件参数，包含集中常见的时间类型： ACTION_DOWN：手指刚接触到屏幕时； ACTION_MOVE：手指在屏幕上移动； ACTION_UP：手指从屏幕上离开的瞬间；MotionEvent的两组位置方式：getX()/getY()：表示动作相对于View左上角位置的x、y坐标；getRawX()/getRawY()：表示动作相对于屏幕左上角位置的x、y坐标； 事件分发public boolean dispatchTouchEvent(MotionEvent event)用于事件的分发，如果时间传递到了当前的View，那么该方法一定会被调用，boolean类型的返回值受View的onTouchEvent(MotionEvent event)和其子View的dispatchTouchEvent(MotionEvnet event)的影响，返回true表示消耗当前时间。public boolean onInterceptTouchEvent(MotionEvent event)用来判断是否拦截当前事件，返回结果表示是否拦截当前事件。public boolean onTouchEvent(MotionEvent event)在dispatchTouchEvent方法中被调用，用来处理touch事件，返回结果表示是否消耗当前事件。 说明： 一个事件序列表示手指从接触屏幕（ACTION_DOWN）经历一些列动作事件到手指刚离开屏幕（ACTION_UP）。 某个View拦截事件，那么接下来的一个事件序列都有它来处理（时间能到到达的情况下），并且它的onIntercept不会再被调用。 如果View再处理事件过程中，不再消耗ACTION_DOWN事件（onTouch返回false），那么事件序列的其他事件将会被其父元素进行消耗。 ViewGroup默认不拦截事件。 VIew没有onInterveptTouchEvent方法，View默认的onTouchEvent都会消耗事件（默认返回true）。 事件传递是由外向内的，即事件总是先传递给父元素，然后通过父元素分发给子View，通过requestDisallowInterceptTouchEvnet方法来干预父元素的事件分发过程，但是ACTION_DOWN事件除外。","categories":[{"name":"Android基础","slug":"Android基础","permalink":"/categories/Android基础/"}],"tags":[{"name":"Android基础","slug":"Android基础","permalink":"/tags/Android基础/"}]},{"title":"Android系统架构","slug":"Android系统架构","date":"2020-05-31T12:13:09.000Z","updated":"2020-05-31T13:29:00.323Z","comments":true,"path":"2020/05/31/Android系统架构/","link":"","permalink":"/2020/05/31/Android系统架构/","excerpt":"","text":"Android采用分层架构，从上到下分别为应用程序层（apps、System apps）、应用程序框架层（Java API Framework）、系统运行库和运行环境层（Libraries+Android Runtime）和Linux核心层（HAL+Linux Kernel）。 System apps可以理解为内置的系统应用，可以像调用Java APIFramework一样区调用系统应用，例如我们调用日历区添加一个日常提醒。 Java ApI Frameworandroid中常用的组件 Native c/c++ Libraries本地库比Java API Framework更加偏低层，这里包含OpenGl、多媒体框架等内容。 Android RuntimeAndroid运行时环境，也就是Android虚拟机。Android5.0之前是使用Dalvik虚拟机，Dalvik虚拟机是基于JIT（Just in TIme）及时编译的引擎。Android5.0之后采用ART虚拟机，ART虚拟机是基于AOT（Ahead Of Time）作为编译引擎 Hardware Abstrction Layer硬件抽象层主要是媒体、蓝牙、传感器的库模块。 Linux KernelAndroid平台的最底层，直接与硬件交互，负责硬件驱动、进程管理、内存管理、网络管理等功能。 什么是JIT和AOT？在Android中Java代码会被转换成DEX字节码文件，DEX字节码文件是Android虚拟机可以识别的，Android虚拟机把字节码在转化为机器能识别的机器码。Dalvik虚拟机给予JIT编译，JIT也叫及时编译器，JIT工作原理是在应用运行时，首先将一部分DEX字节码转化为机器码，在程序执行的过程中再陆续将更多代码编译并缓冲，这样做的好处是内存占用少，但CPU再应用运行期间相对消耗大。AOT叫做提前编译器，它是在应用的安装期间就将DEX字节码转化为了机器码，并将其存储在设备上。这样做的好处是在应用运行时占用CPu资源少一些，因为已经转化成了机器码，相对内存占用上多一些。","categories":[{"name":"Android基础","slug":"Android基础","permalink":"/categories/Android基础/"}],"tags":[{"name":"Android基础","slug":"Android基础","permalink":"/tags/Android基础/"}]},{"title":"图片加载如何避免OOM","slug":"图片加载如何避免OOM","date":"2020-05-30T14:47:26.000Z","updated":"2020-05-30T15:19:51.691Z","comments":true,"path":"2020/05/30/图片加载如何避免OOM/","link":"","permalink":"/2020/05/30/图片加载如何避免OOM/","excerpt":"","text":"内存中Bitmap大小的计算公式：长占用的像素 宽占用的像素 每个像素占用的内存避免OOM也就是要减小图片在内存中的大小，有两种方式等比缩小长宽和减少每个像素占用的内存。 等比缩小长宽：Bitmap的创建是通过BitmapFactory的工厂方法decodeFile()、decodeStream()、decodeByteArray()、decodeResource()。这些方法在创建Bitmap使都一个参数Options，Options中的属性inSampleSize用来对图片进行长宽的设置，inSampleSize的值是2的幂次方，通过设置合适的值来对图片进行缩放操作。 减少像素内存：Options中的属性inPreferredConfig，通过调整这个值的属性来改变每个像素所占的内存，默认值是ARGB_8888,修改为RGB_565或ARGB_4444可以减少一半的内存。 值 含义 ARGB_8888 A(Alpha)、R(Red)、G(Green)、B(Blue)各占8位的精度，加起来32位的精度（即4个字节），也就是一个像素占4个字节的长度 ARGB_4444 A(Alpha)、R(Red)、G(Green)、B(Blue)各占4位的精度，加起来16位的精度（即2个字节），也就是一个像素占2个字节的长度 RGB_565 R(Red)占5位精度、G(Green)占6位精度、B(Blue)占5位精度，一共16位精度，也就是2个字节，不携带透明度信息 ALPHA_8 每个像素占位（即一个字节），只办函透明度值，不携带颜色信息","categories":[{"name":"Android基础","slug":"Android基础","permalink":"/categories/Android基础/"}],"tags":[{"name":"Android基础","slug":"Android基础","permalink":"/tags/Android基础/"}]},{"title":"IPC机制","slug":"IPC机制","date":"2020-05-29T12:33:15.000Z","updated":"2020-05-30T14:25:20.618Z","comments":true,"path":"2020/05/29/IPC机制/","link":"","permalink":"/2020/05/29/IPC机制/","excerpt":"","text":"进程与线程进程一般指一个执行的单元，也可以称作正在运行的程序实例。线程是CPU进行运算调度的最小单元，它的系统资源是有限的，它是包含在进程之中。所以进程与线程是包含与被包含的关系。 什么是IPC？IPC全称Inter-Process Communication，即进程间通信。一般应用采用多进程有是为了使应用能够获取更多的内存空间。由于一个进程对应分配一个虚拟机，进程与虚拟机的一一对应，造成我们对同一个类的对象在不同进程中就产生了对个副本，例如有processOne和processTwo两个进程，它们都有一个类A.class，那么在两个进程中的A.class是互不干扰的。总结起来对进程会造成一下几个问题：1. 静态成员和单例模式失效；2. 线程同步机制生效；3. SharedPreferences可靠性降低（进程并发写可能异常）4. Application多次创建（可以理解成Application的创建和进程的创建是一致的） Binder机制Binder是android进程间通信的方式，Binder时基于C/S架构，主要有四部分组成：1. Client（客户端进程）2. Server（服务端进程）3. ServiceManager（提供注册、查询和返回代理服务对象的功能）4. Binder驱动（主要进程间的连接，进程间数据交互等基础底层操作） 服务器通过Binder驱动在ServiceManager中注册服务客户端通过Binder驱动查询Servicemanager中注册的服务SreviceManager通过Binder驱动返回服务器代理对象客户端拿到服务器的代理对象后即可进行进程间的通信 IPC方式比较 优 缺 适用场景 Bundle 使用简单 传输Bundle支持的数据类型 四大组件间的数据传递 文件共享 使用简单 不适合高并发，无法进行即时通信 用于实时性不高的场景 AIDL 功能强大 支持一对多并发下的通信，支持实时 使用较复杂，需要做好线程同步问题 一对多通信且有RPC需求 Messenger 功能一般，支持一对多串行通信，支持实时通信 不支持RPC、不能很好处理高并发、数据通过Message进行传输，只能传输Bundle支持的数据类型 低并发的一对多即时通信 ContentProvider 在数据源访问上功能强大，支持一对多的并发数据共享，可通过call操作扩展其他操作 提供数据源的CRUD操作 进程一对多的数据共享 Socket 功能强大，支持网络传输数据流、支持一对多的实时通信 实现较繁琐 网络数据共享","categories":[{"name":"Android基础","slug":"Android基础","permalink":"/categories/Android基础/"}],"tags":[{"name":"Android基础","slug":"Android基础","permalink":"/tags/Android基础/"}]},{"title":"Android性能优化","slug":"Android性能优化","date":"2020-05-27T05:01:02.000Z","updated":"2020-05-30T14:48:46.004Z","comments":true,"path":"2020/05/27/Android性能优化/","link":"","permalink":"/2020/05/27/Android性能优化/","excerpt":"","text":"Android的性能优化主要从四方面入手，内存优化、布局优化、网络优化和安装包优化。 常用检查工具LeakCanary是一个三方检测内存泄漏的工具库 ，集成后会自动检测应用运行期间的内存泄漏，并直观的输出。Android自带的Android Profiler ，可以检测CPU、MEMERY、NETWORK三方的性能。BlockCanary是一个三方用来检测UI卡顿的工具库，像LeakCanary一样集成后当发生UI卡顿现象时会输出卡顿的信息，通过输出的信息可以很方便的来定位导致卡顿的原因。 内存优化内存优化的方式时避免内存泄漏（节流）、增加内存（开源）。常见的内存泄露： 单例导致的泄漏。在创建单例时传入了具体页面的Context，由于单例的静态属性，导致单例一致持有该Context引用，一直到应用程序结束。正确的做法是创建单例时应用传入应用级别的Context，也就是Application的Context，这样就保证了单例生命周期与传入Context的统一。 静态变量导致的内存泄漏。JVM中可以知道静态变量是在方法区的，它的生命周期是从类加载到应用程序结束，如果静态变量中持有了具体页面的Context就会导致页面finish后Context不会被GC，这样就导致了内存泄露。 非静态内部类导致的内存泄露。非静态内部类创建呢的Handle或Thread在执行延时操作时一直持有当前的Activity引用，这时候在Activity finish后就会导致内存泄漏。解决方式是使用静态内部类并用弱引用调用Activity；另外还可以在onDestroy中调用handler.removeCallbacksAndMessages取消所有事件消息。 使用资源没有及时关闭。常见操作有：数据流操作完没有关闭、bitmap没及时Recycle等 三方的没及时接绑。EventBus（unregister）和Rxjava中（dispose）。 动画执行导致的。在Activity finish时动画执行还在进行。解决就是在onDestroy时cacel动画。 WebView导致的泄漏。 WebView即使调用了destroy也会导致内存泄漏。解决方式时使用弱引用WeekReference或者将WebView所在的Activity置于另外一个进程中。 增加内存方案一般会在Application下添加largeHeap=”true”，活着新开进程来时应用的内存总空间增大。 布局优化 16ms 使用RelativeLayout减少View层级 利用抽离常用的布局 使用加载不常用的布局 使用减少布局嵌套 减少多余的背景绘制 canvas.clipRect()裁剪可见区域，其他区域就不会被多余绘制。 网络优化 合理合并网络请求 网络缓存 大数据分页请求 网络数据传输压缩（Gzip） 图片压缩、缩略图 安装包优化apk的构成： assets文件夹：配置文件、资源文件 文件夹内的资源时通过AssetManager类内方法获取。 res：资源文件，文件名会自动生成对应ID映射到.R文件中。 META-INF：保存呢应用的签名信息，保证APK的完整性。 AndroidManifest.xml：描述应用的配置信息。 classes.dex：Dalvik虚拟机可执行的字节码文件，SDK下dx工具将JAVA字节码转化为Dalvik字节码。 resources.arsc：资源文件和资源ID间的映射关系。 根据spk的构成做一下几方面的优化： 混淆：使用proGuard代码混淆工具，它包含了代码的压缩、优化、混淆等功能。 资源优化：利用lint工具删除冗余代码，资源文件的最小化等。 重复功能库：去除一些功能重复库的引用。 插件化：功能模块放在服务器上，按需下载。5.so库优化：保留v7版本，删除armeabi和v8版本的SO库，v7库可以按足市场上绝大多树手机的要求。","categories":[{"name":"Android基础","slug":"Android基础","permalink":"/categories/Android基础/"}],"tags":[{"name":"Android基础","slug":"Android基础","permalink":"/tags/Android基础/"}]},{"title":"Android动画分类","slug":"Android动画分类","date":"2020-05-26T05:26:27.000Z","updated":"2020-05-26T07:04:55.073Z","comments":true,"path":"2020/05/26/Android动画分类/","link":"","permalink":"/2020/05/26/Android动画分类/","excerpt":"","text":"帧动画通过在xml中的一组图片的播放来实现。 补间动画分为旋转、移动、缩放、透明度四类动画，以及他们的组合来实现动画效果。 属性动画属性动画目前使用场景最多，分类两种ViewPropertyAnimator和ObjectAnimator。前者是通用的动画，例如旋转、透明度、位移和缩放,简单通过View.animator()就可得到ViewPropertyAnimator。后者通过ObjectAnimator.of属性()来返回一个ObjectAnimator，ObjectAnimator需要重绘View所以要调用invalidate()来刷新绘制，最后通过start()方法启动动画。 补间动画和属性动画的区别？ 补间动画只是在父VIew层利用Matrix不多绘制View，达到移动的效果，其实View并没有发生变化，还在动画之前的位置。属性动画是真正改变了View的属性值，真正的改变View的具体属性值的。","categories":[{"name":"Android基础","slug":"Android基础","permalink":"/categories/Android基础/"}],"tags":[{"name":"Android基础","slug":"Android基础","permalink":"/tags/Android基础/"}]},{"title":"TCP和UDP","slug":"TCP和UDP","date":"2020-05-25T09:18:41.000Z","updated":"2020-05-25T14:35:50.210Z","comments":true,"path":"2020/05/25/TCP和UDP/","link":"","permalink":"/2020/05/25/TCP和UDP/","excerpt":"","text":"TCP（（Transmission Control Protocol，传输控制协议）） TCP协议是面向连接、可靠的字节流传输服务。TCP协议在C/S间数据交换前，需要先在上方建立一个TCP连接，之后才开始传输数据，并提供超时、重发、丢弃重复数据、数据校验和流量控制等功能。特点：面向连接、可靠通信、面向字节流应用层协议：HTTP、HTTPS、SSH、FTP、SMTP UDP（User Data Protocol，用户数据报协议） UDP是一个面向数据报的传输层协议，不具有可靠性，只是把数据发出去，不保证数据是否能到达S端。因为UDP在传输数据前不需要建立一个连接，所以它的传输效率很快，不能保证数据的可靠。特点：无连接、不可靠、面向数据报应用层协议：DHCP、DNS TCP协议建立连接的三次握手 第一次握手（请求建立连接）C端发送建立连接请求，携带序列号seq=x 标示SYN=1，此时C端处于SYN_SEND状态；第二次握手（确认请求）S端收到后，发出确认信息，确认信息ACK=x+1，同时携带自己的序列号SYN=1，seq=y；第三次握手（建立连接）C端收到S端的确认请求后，向S端发送确认ACK=y+1，S端收到请求后两端都处于Established状态，表示当前的一次TCP连接成功。 TCP断开连接的四次挥手 第一次挥手（请求释放）C端发送释放连接的请求信号FIN=1，seq=u，此时C端处于FIN WAIT状态,不再发送数据给S端；第二次挥手（确认请求）S端收到释放请求后，发送确认收到请求释放，ACK=1,ack=u+1,此时S度啊处于CLOSE EAIT状态，不再接收C端数据，但是需要发送给C端的数据可继续发送；第三次挥手（确认释放）当S端不再有数据需要发送给C端时，发送却是释放连接，携带FIN=1，seq=w，ACK=1，ack=u+1，此时S端处于LAST ACK状态，等待C端的最终确认；第四次挥手（最终释放确认）当C端收到了确认释放后，随即发送最终释放确认，ACK=1，ack=w+1，seq=u+1；此时C端在等待2MSL后关闭连接，S端收到请求后同样关闭。 为什么需要三次握手？如果是两次握手，服务端确认请求后，不知道客户端是否能收到了消息，服务端的消息得不到确认。(服务端消息等不到确认)如果客户端发送的请求网络延迟了，超时后有客户端重新发起请求，倘若在重发请求正常进行完毕后，再收到之前网络拥塞的请求，再和服务端建立连接，这个时候就可能服务端一直等待，导致服务端连接资源浪费。 为什么第三次握手是seq=x+1，而不是x+2？从握手的规律可以看出来seq在确认请求中会变做确认表示即ack，ack会在seq值的基础上加1，同时TCP规定，SYN不携带数据，但会消耗掉一个序列号，SYN=1时会消耗seq的一个值（即加1），第三次握手ACK=1、SYN不等于1，而ACK=1不消耗seq所以seq=x+1而不是x+2，挥手中FIN也和SYN一样 TCP建立连接后客户端出现故障会怎样？服务端有个计数器，一般两小时，两小时如果没有收到任何数据，会发送探测报文段，发了几个报文段如果还是没反应，服务端就会关闭连接。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"/tags/计算机网络/"}]},{"title":"HTTP、HTTPS和HTTP2.0","slug":"HTTP、HTTPS和HTTP2-0","date":"2020-05-23T10:14:51.000Z","updated":"2020-05-25T09:18:10.142Z","comments":true,"path":"2020/05/23/HTTP、HTTPS和HTTP2-0/","link":"","permalink":"/2020/05/23/HTTP、HTTPS和HTTP2-0/","excerpt":"","text":"* 什么是HTTPHTTP（HyperText Transfer Protocol）中文全名超文本传输协议，HTTP是用于客户端与服务器间请求响应的协议。HTTP是应用层的协议，和其他该层协议一样，它是服务于某一类具体应用的协议。 * 什么是HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer）HTTPS是在HTTP的基础上加上了SSL/TLS层TLS（Transport Layer Security，传输层安全协议）、SSL(Secure Sockets Layer 安全套接层) SSL由NetScape公司设计，共有三个版本1、2、3。SSL 3.0得到大规模使用，而TLS是SSL标准化后的升级版 SSL/TLS握手阶段工作流程： 客户端向服务端发出加密通信请求(ClientHello) 携带支持的协议，例如TLS 1.0版客户端生成的随机数random1，后面用于生成“对话密钥”支持的加密方法，比如RSA公钥加密支持的压缩的方法 服务端收到请求，做出响应(ServerHello) 确认加密通信协议，例如TLS 1.0版。如果协议与服务端支持的不一致，则关闭加密通信。服务端生成一个随机数random2，后面用于生成“对话密钥”确认加密方法，例如RSA公钥加密携带服务端证书给客户端 客服端做证书验证和公钥对随机数加密发送给服务端(ClientResponse) 验证证书的安全性验证通过后，客户端生成随机数pre-master secret，然后使用证书中的公钥进行加密，发送给服务端 服务端私钥解密获得随机数(ServerResponse) 服务端收到公钥加密的内容，在服务端使用私钥解密后得到pre-master secret，然后根据random1、random2和pre-master secret通过一定的算法得出对称加密的秘钥，作为后面交互过程中的对称密钥。同时客户端也使用random1、random2和pre-master secret，同样的算法生成对称密钥。 后续操作使用上一步生成的对称密钥对传输的内容加密和解密。 如何保证公钥不被篡改？ 将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。 什么是对称加密？ 加密和解密用的都是相同的密钥，优点是速度快，缺点是安全性低，常见的对称加密DES、AES等 什么是非对称加密？ 非对称加密由一对密钥对，分为公钥和私钥。一般私钥自己持有，公钥可以公开给对方，优点是安全性比对称密钥高，缺点是数据传输效率比对称密钥低。采用公钥加密的数据只能由对应的私钥来解密。常见的非对称加密算法RSA。 HTTPS在传输过程中采用了对称加密和非对称加密结合使用，使用非对称加密传递密钥，然后使用对称密钥进行数据传输的加密和解密。二者的结合既保证了传输的安全性，也保证了数据传输的效率 * HTTP 2.0 （二进制格式）HTTP 2.0采用二进制格式传输，而HTTP1.x使用纯文本的形式传输数据 （Header压缩）HTTP 2.0对已经发送的Header使用键值对建立索引表（两端维护的索引表），相同的Header使用索引表示，即Header压缩。 （服务器推送）服务端可以进行主动推送 （多路复用）一个TCP连接被划分为多个流，客户端借助流和服务端建立全双工通信，且流具有优先级。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"/tags/计算机网络/"}]},{"title":"HTTP状态码","slug":"HTTP状态码","date":"2020-05-22T11:47:10.000Z","updated":"2020-05-22T12:47:04.911Z","comments":true,"path":"2020/05/22/HTTP状态码/","link":"","permalink":"/2020/05/22/HTTP状态码/","excerpt":"","text":"状态码分类： 码 类别 原因 1xx Information（信息性状态码） 接受的请求正在处理 2xx Success（成功状态码） 请求正常处理完成 3xx Redirection 需要进行附加操作来完成请求 4xx Client Error（客户端错误） 客户端请求出错，服务端无法处理 5xx Server Error（服务端出错） 服务端处理请求出错 200 OK 客户端发送给服务器的请求正常处理并返回。 204 No Content 客户端发送给服务端的请求被服务端成功处理，但是在返回的相应报文中没有实体内容（也就是没有资源返回）。 206 Patail Content 客户端进行了范围请求（响应报文中Content-Range制定了范围的实体），并且服务器成功执行了这部分的GET请求。 301 Moved Permanly 请求被永久性重定向，表示请求的资源已经被分配到了新的URI，在今后的请求中使用那个新的URI。可以通过这个响应代码来防止由于URI变更而导致老URI失效。 302 Found 请求临时性重定向，表示请求希望使用新的URI 303 See Other 当前的请求的响应在另外一个URI上被找到，并且客户端应当采用GET请求访问那个资源。 304 Not Modified 客户端发送了一个带条件（if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一）的GET请求且已被允许，而资源内容并未被修改过，则服务端返回该错误码。 307 Temporary Redirect 临时性重定向，与3030类似，但是这里会准照浏览器标准执行。 400 Bad Request 当前请求存在语法错误 401 Unauthorized 未经许可，请求身份验证。 403 Forbidden 服务器拒绝访问（访问权限出现问题） 404 Not Found 服务器找不到请求的资源。 500 Inter Server Error 服务器在执行请求是发生了错误。 503 Server Unavailable 服务不可用，服务器由于超载或停机维护，无法处理请求。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"/tags/计算机网络/"}]},{"title":"OSI网络模型","slug":"OSI网络模型","date":"2020-05-22T09:11:03.000Z","updated":"2020-05-22T11:35:02.983Z","comments":true,"path":"2020/05/22/OSI网络模型/","link":"","permalink":"/2020/05/22/OSI网络模型/","excerpt":"","text":"OSI（Open System Interconnection）全称开放系统互联，它把网络通信的工作分为7层，包括应用层、表现层、会话层、传输层、网络层、数据链路层和物理层。传输层、网络层、数据链路层和物理层叫做低四层，这四层和数据的移动相关。应用层、表现层和会话层叫做高三层，包含了应用程序级别的数据，每一层负责具体的一项工作将数据想向下一层传送。 应用层 应用层就是为了满足应用进程间的通信和交互任务。该层的协议有HTTP、HTTPS、FTP、POP3、SMTP等 表现层 表现层提供数据的编码和转换功能。数据的压缩和解压缩，加密和解密等工作都是在表现层完成。 会话层 会话层提供访问验证和会话管理在内的建立和维护应用间通信的机制，例如服务器验证用户登陆便由会话层完成。 传输层 传输层主要负责建立端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务。端口号即是这里的端，TCP和UDP就是这层的协议 网络层 网络层的任务是选择合适的网间路由和交换结点，确保数据及时传送。 数据链路层 将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测（也就是帧编码和误差纠错的功能）。数据链路层协议又分为两个子层：逻辑链路控制（LLC）和媒体访问控制（MAC）。 物理层 信号的最终传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"/tags/计算机网络/"}]},{"title":"ArrayList和LinkedList","slug":"ArrayList和LinkedList","date":"2020-05-21T06:16:27.000Z","updated":"2020-05-21T12:08:07.746Z","comments":true,"path":"2020/05/21/ArrayList和LinkedList/","link":"","permalink":"/2020/05/21/ArrayList和LinkedList/","excerpt":"","text":"源码分析 ArrayList 1234567/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */ transient Object[] elementData; // non-private to simplify nested class access ArrayList内部实现元素是放在elementData的数组中的，并且默认数组是空的，当增加元素时才扩展到DEFAULT_CAPACITY，这里DEFAULT_CAPACITY的值时10。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125; &#125; /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; ArrayList的构造函数有三个，一个无参的设置空数组，有参的一个传入容量初始化数组，另外一个通过Collection对象对数组初始化赋值。 123456789101112131415161718192021222324252627282930/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; add方法中主要的调用是ensureCapacityInternal方法，ensureCapacityInternal方法主要做了一个扩容的处理，这里容器的最小值被赋予了DEFAULT_CAPACITY，也就是10，扩容的处理在grow方法中完成，这里看到新容量的大小等于老容量加上老容量的一半，也就是新容量在老容量的基础上再增加它的一半。后面对数组进行重新创建和赋值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; /** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; /* * Private remove method that skips bounds checking and does not * return the value removed. */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; remove方法比较简单入参是索引的通过索引找到数组中的元素，通过本地方法System.arraycopy将index+1的元素赋值到索引从index到size-1，这里就相当于对index后面的元素进行了向前移位的操作。如果入参是元素o就通过遍历找到它的索引然后再根据它的索引进行remove。 这里modCount变量是一个叫做fail-fast的机制，就是当我们对ArrayList元素进行一些操作时，若果又有其他线程对其内容进行修改时，可以第一时间通过modCount的值来判定，当再操作中modCount值不一值就抛出ConcurrentModificationException，也表明ArrayList是线程不安全的 这里get方法就不再赘余，因为ArrayList这里时数组，可以通过下标方便的查找，ArrayList实现RandomAccess接口，作为一种标示说明它的访问时随机的 LinkedList 12345678910111213/** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */ transient Node&lt;E&gt; first; /** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */ transient Node&lt;E&gt; last; 123456789101112 private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; LinkedList的内部实现使用双向链表来存储元素的。 123456789101112131415161718/** * Constructs an empty list. */ public LinkedList() &#123; &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the specified * collection's iterator. The behavior of this operation is undefined if * the specified collection is modified while the operation is in * progress. (Note that this will occur if the specified collection is * this list, and it's nonempty.) * * @param c collection containing elements to be added to this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125;/** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection's iterator. * * @param index index at which to insert the first element * from the specified collection * @param c collection containing elements to be added to this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; for (Object o : a) &#123; @SuppressWarnings(\"unchecked\") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true;&#125; 构造函数有两个，有参的Collection元素集构造函数中调用addAll方法，addAll方法中通过遍历增加链表元素。 123456789101112/** * Appends the specified element to the end of this list. * * &lt;p&gt;This method is equivalent to &#123;@link #addLast&#125;. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; linkLast(e); return true; &#125; 1234567891011121314/** * Links e as last element. */ void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; add方法中主要调用linkLast方法，新建新增的Node元素，Node元素prev变量之前当前的last，next为null，然后找last.next指向newNode。 12345678910111213/** * Removes the element at the specified position in this list. Shifts any * subsequent elements to the left (subtracts one from their indices). * Returns the element that was removed from the list. * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125; 123456789101112131415161718/** * Returns the (non-null) Node at the specified element index. */ Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; 12345678910111213141516171819202122232425262728/** * Unlinks non-null node x. */ E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; remove主要通过两个方法实现，node方法通过index找到对应的Node元素，然后通过unlink方法链表重新链接，将x元素从链表中移除并置为null，以便GC回收。 1234567891011/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125; get方法直接通过node方法遍历等到Node元素，然后Node.item拿到元素值。 两者对比 1 .ArrayList内部是通过动态数组结构实现，空间利用相对有损耗；LinkedList内部是通过双向链表实现，空间利用上不存在浪费，因为元素的多少和链表长度是一致的。2. ArrayList因为是数组实现，所以删除、插入操作相对较慢（通过System.arraycopy本地方法完成，存在元素移动），但是它的查找操作可随机访问（实现RadomAccess接口）；LinkedList链表在删除、插入效率高，不存在元素移动，只需要改变目标元素的前驱和后继就可以实现。","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/categories/JAVA基础/"}],"tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/tags/JAVA基础/"}]},{"title":"java引用类型","slug":"java引用类型","date":"2020-05-19T10:02:08.000Z","updated":"2020-05-19T10:44:58.306Z","comments":true,"path":"2020/05/19/java引用类型/","link":"","permalink":"/2020/05/19/java引用类型/","excerpt":"","text":"java引用类型分为四类：强引用、软引用、弱引用和虚引用。强引用：就是我们最常用的直接new对象创建的引用，垃圾回收器将永远不会回收被引用的对象。内存不足的情况JVM会直接抛出OOM。软引用（SoftReference）：软引用在内存不足的情况下会被垃圾回收器回收。软引用常被用在存储一些内存敏感的缓冲，例如网页缓冲、图片缓冲等。弱引用（WeekReference）：弱引用的强度比软引用更弱一下，无论内存是否足够，只要当GC开始，被扫描到的弱引用的对象就会被回收。虚引用（PhantomReference）：虚引用是最弱的一种引用关系。它随时可能被回收，并且对象是无法通过虚引用获取的。虚引用主要用来跟踪对象被GC回收的活动，当被虚引用修饰的对象在被回收时，JVM会把虚引用加入到与之关联的引用队列（ReferrenceQueue）中。","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/categories/JAVA基础/"}],"tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/tags/JAVA基础/"}]},{"title":"单例模式","slug":"单例模式","date":"2020-05-19T04:37:45.000Z","updated":"2020-05-19T05:35:15.924Z","comments":true,"path":"2020/05/19/单例模式/","link":"","permalink":"/2020/05/19/单例模式/","excerpt":"","text":"懒汉式 懒汉式是在调用时创建实例，用时间来换空间。 1234567891011121314151617class LazySingleTon &#123; private static volatile LazySingleTon instance; public static LazySingleTon getInstance()&#123; if (instance==null)&#123; synchronized(LazySingleTon.class)&#123; if (instance == null) &#123; instance = new LazySingleTon(); &#125; &#125; &#125; return instance; &#125; &#125; 双重判断保证了原子性和可见性（synchronized），同时利用volatile来保证有序性，避免指令的重排。 饿汉式 饿汉式在类加载的时候就已经创建好对象，在使用时直接就可以拿到实例，标准的空间换时间。 12345678class HungrySingleTon &#123; private static HungrySingleTon instance = new HungrySingleTon(); public static HungrySingleTon getInstance()&#123; return instance; &#125;&#125; 静态内部类实现 当外部类加载时不会导致内部类的立即加载，只有当getInstance方法被调用时才会去加载内部类，实现了加载。因为类的加载只会加载一次，所以它时线程安全的。 12345678910111213class StaticInnerSingleTon &#123; public StaticInnerSingleTon() &#123; &#125; private static class SingleTonHolde &#123; private static StaticInnerSingleTon instance = new StaticInnerSingleTon(); &#125; public static StaticInnerSingleTon getInstance() &#123; return SingleTonHolde.instance; &#125;&#125; 枚举实现 1234567enum ESingleTon &#123; single; public void singletonOperate()&#123; System.out.println(\"singletonOperate\"); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}]},{"title":"final、finally和finalize","slug":"final、finally和finalize","date":"2020-05-19T03:59:33.000Z","updated":"2020-05-19T04:07:24.104Z","comments":true,"path":"2020/05/19/final、finally和finalize/","link":"","permalink":"/2020/05/19/final、finally和finalize/","excerpt":"","text":"final可以修饰类、方法和变量。修饰类代表这个类不可被继承。修饰方法表示该方法不可被重写。修饰变量表示该变量在赋值后不可改变。 finally保证重点代码一定会被执行的一种机制。通常使用组合try-catch-finally。 finalize是Object类的一个方法，当垃圾回收器将要回收对象所占内存之前被调用，这个方法来用保证来对象被回收前完成特定的资源回收。","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/categories/JAVA基础/"}],"tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/tags/JAVA基础/"}]},{"title":"线程间通信方式","slug":"线程间通信方式","date":"2020-05-15T07:07:21.000Z","updated":"2020-05-16T10:44:23.995Z","comments":true,"path":"2020/05/15/线程间通信方式/","link":"","permalink":"/2020/05/15/线程间通信方式/","excerpt":"","text":"这里将线程间通信的途径分为两类：同享内存和消息传递。 同享内存 volatile关键字的使用 就是利用volatile关键字的可见性，多个线程对它进行监控在其变量发生变化后执行对应线程的操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class ThreadCommunication &#123; public static int STATE_RUN_A = 0; public static int STATE_RUN_B = 1; public static int STATE_RUN_C = 2; volatile static int state = STATE_RUN_A; static int counter = 1; public static void main(String[] args) &#123; Thread threadA = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //这里睡眠3s等待BC线程 Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int c = 1 &lt;&lt; 3; if (state == STATE_RUN_A) &#123; System.out.println(\"threadA is running!\"); for (int i = 0; i &lt; c; i++) &#123; if (i == 5) &#123; state = STATE_RUN_B; break; &#125; &#125; &#125; &#125; &#125;); Thread threadB = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; if (state == STATE_RUN_B) &#123; System.out.println(\"threadB is running!\"); do &#123; counter = counter &lt;&lt; 1; &#125; while (counter &lt; 1 &lt;&lt; 4); state = STATE_RUN_C; break; &#125; &#125; &#125; &#125;); Thread threadC = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; if (state == STATE_RUN_C) &#123; System.out.println(\"threadC is running!\"); do &#123; counter = counter &gt;&gt; 1; &#125; while (counter &gt; 1); System.out.println(\"threadC finish counter：\" + counter); break; &#125; &#125; &#125; &#125;); threadA.start(); threadB.start(); threadC.start(); &#125;&#125; 消息传递 Object.wait()\\notify() 在线程中调用该线程锁对象是wait方法是，该线程就被放入等待队列，直到被其他线程通知notify。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class ThreadCommunication &#123; static int counter = 1; static Object lock = new Object(); public static void main(String[] args) &#123; Thread threadB = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; synchronized (lock) &#123; System.out.println(\"threadB is running!\"); do &#123; counter = counter &lt;&lt; 1; &#125; while (counter &lt; 1 &lt;&lt; 4); lock.notify(); break; &#125; &#125; &#125; &#125;); Thread threadC = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; synchronized (lock) &#123; if (counter == 1 &lt;&lt; 4) &#123; System.out.println(\"threadC is running!\"); do &#123; counter = counter &gt;&gt; 1; &#125; while (counter &gt; 1); System.out.println(\"threadC finish counter：\" + counter); break; &#125; else &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;); threadC.start(); threadB.start(); &#125;&#125; .join() {Thread.join} 当一个线程调用另外一个线程的join方法时，当前的线程就会阻塞等待被调用join方法的线程执行完毕后才能继续执行，所以join方法用来保证线程执行的顺序。 CountDownLatch类 CountDownLatch类可以使线程等待其他线程执行完毕后再执行。通过一个计数器来实现，CountDownLatch初始化传入的count代表等待count个线程执行完毕后等待的线程才能恢复执行。一般有几个应用场景：场景一：有多个线程依赖其他多个线程的执行完的结果，这是等待的await，被等待的线程执行完调用coutdown然后计数器减一，直到减为0就恢复多个线程的执行；场景二：实现多个线程同时执行，多个线程都设置await coutdown设置为1 在主线程中调用countdown让多个线程同时执行运行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class ThreadCommunication &#123; static int counter = 1; static CountDownLatch countDownLatch = new CountDownLatch(2); public static void main(String[] args) &#123; Thread threadA = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(\"threadA await\"); countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"threadA is running!\"); &#125; &#125;); Thread threadB = new Thread(new Runnable() &#123; @Override public void run() &#123; countDownLatch.countDown(); System.out.println(\"threadB is running!\"); &#125; &#125;); Thread threadC = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; do &#123; counter = counter &lt;&lt; 1; System.out.println(\"threadC is running! counter=\" + counter); &#125; while (counter &lt; 1 &lt;&lt; 5); countDownLatch.countDown(); break; &#125; &#125; &#125;); threadA.start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; threadB.start(); threadC.start(); &#125;&#125; LockSupport类LockSupport是JDK中用来实现线程阻塞和唤醒的工具。使用它可以在任何场合使线程阻塞，可以指定任何线程进行唤醒。LockSupport的设计核心是“许可”，park是等待一个许可，unpark是为某一线程提供一种许可，如果某线程A调用park，那么除非另外一个线程调用unpark(A)给A一个许可，否则线程A将阻塞在park操作上。还有就是unpark可以在park前调用，也就是先提供许可，等到后面调用park时在消耗之前的许可。 12345678910111213141516171819202122232425262728293031323334353637class ThreadCommunication &#123; public static void main(String[] args) &#123; Thread threadA = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"threadA park\"); LockSupport.park(); System.out.println(\"threadA is running!\"); &#125; &#125;); Thread threadB = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"threadB park\"); LockSupport.park(); System.out.println(\"threadB is running!\"); System.out.println(\"threadB unpark threadA\"); LockSupport.unpark(threadA); &#125; &#125;); threadA.start(); threadB.start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"main thread unpark threadB\"); LockSupport.unpark(threadB); &#125;&#125;","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/categories/JAVA基础/"}],"tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/tags/JAVA基础/"}]},{"title":"JAVA线程池的使用","slug":"JAVA线程池的使用","date":"2020-05-15T03:57:33.000Z","updated":"2020-05-16T10:46:37.786Z","comments":true,"path":"2020/05/15/JAVA线程池的使用/","link":"","permalink":"/2020/05/15/JAVA线程池的使用/","excerpt":"","text":"线程池的作用 线程池可以有效控制系统内执行线程的数量； 根据系统的状况可以手动或自动调整执行线程的数量，让其他线程排队等候； 线程池可以有效减少线程创建和销毁的次数，使得线程可以复用，可以执行多任务。 JAVA中常用的线程池 newSingleThreadExecutor()创建一个单线程的线程池，线程池中只有一个线程在工作（相当于单线程串行执行所有任务）。如果唯一的线程异常结束，将会创建一个新的线程来代替，同时任务按照队列顺序执行。方法解释： 12345678910111213141516171819202122232425262728293031/** * Executors.newSingleThreadExecutor() * Creates an Executor that uses a single worker thread operating * off an unbounded queue. * 使用单操作线程创建一个没有限制队列的Executor * (Note however that if this single * thread terminates due to a failure during * execution prior toshutdown, a new one will * take its place if needed to execute * subsequent tasks.) * 但是请注意，如果该单线程由于在关机之前执行期间失败而终 * 止，则在执行后续任务时需要使用一个新线程。 * Tasks are guaranteed to execute * sequentially, and no more than one task will * be active at any given time. * 确保任务按顺序执行，并且在任何给定时间都不会激活一项以上 * 的任务。 * Unlike the otherwise equivalent * &#123;@code newFixedThreadPool(1)&#125; the returned * executor is guaranteed not to be * reconfigurable to use additional threads. *与其他等效的&#123;@code newFixedThreadPool（1）&#125;不同，保 证返回的执行程序不可重新配置为使用其他线程。 * @return the newly created single-threaded Executor */ public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; newFixedThreadPool(int nThreads) 创建一个固定线程数量的线程池，每次提交的任务就创建一个线程，直到线程数量达到线程数量限制。其余多的任务进入等待队列，直到有空闲的线程。如果有线程异常结束，那么就会创建一个新的线程来代替它。方法解释： 12345678910111213141516171819202122232425262728293031323334353637/** * Executors.newFixedThreadPool(int nThreads) * Creates a thread pool that reuses a fixed * number of threads operating off a shared * unbounded queue. * 创建一个线程池，该线程池重用在共享的无边界队列上运行的固 * 定数量的线程。 * Atany point, at most&#123;@code nThreads&#125; threads * will be activeprocessing tasks. * 无论何时，最多&#123;@code nThreads&#125;个线程都是活动处理任 * 务。 * If additional tasks are submitted when all * threads are active,they will wait in the queue * until a thread is available. * 如果在所有线程都处于活动状态时提交了其他任务，则它们将 * 在队列中等待，直到某个线程可用为止。 * If any thread terminates due to a failure * during execution prior to shutdown, a new one * will take itsplace if needed to execute * subsequent tasks. * 如果在关闭之前执行过程中由于执行失败导致任何线程终止，则 * 在执行后续任务时将替换一个新线程。 * The threads in thepool will exist * until it is explicitly &#123;@link * ExecutorService#shutdown shutdown&#125;. *这个线程在池中将一直存在知道明确的shutdown。 * @param nThreads the number of threads in the * pool * @return the newly created thread pool * @throws IllegalArgumentException if &#123;@code * nThreads &lt;= 0&#125; */ public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; newCachedThreadPool() 创意一个可以缓冲的线程池，如果当前线程数超出了执行任务的数量，那么在等待60s无新任务的情况下结束掉。当任务数量增加的情况下，线程池又会自动增加线程数量。线程池对线程的数量没有做限制。方法解释： 123456789101112131415161718192021222324252627282930313233343536373839/** * Executors.newCachedThreadPool() * Creates a thread pool that creates new threads * as needed, but * will reuse previously constructed threads when * they are available. * 创建一个线程池，该线程池根据需要创建新线程，但是将在先前 * 构造的线程可用时重用它们。 * These pools will typically improve the * performance of programs that execute many * short-lived asynchronous tasks. * 这些池通常将提高执行许多短期异步任务的程序的性能。 * Calls to &#123;@code execute&#125; will reuse previously * constructed threads if available. * 调用&#123;@code execute&#125;将重用之前构造的可重用的线程 * If no existing thread is available, a new * thread will be created and added to the pool. * 如果不存在可重用的线程，那么一个新的线程将会被创建并添加 * 到池中。 * Threads that have not been used for sixty * seconds are terminated and removed from the * cache. * 六十秒内未使用的线程将终止并从缓存中删除。 * Thus, a pool that remains idle for * long enough will not consume any resources. * 因此，一个保持足够长的池也不会消耗任何资源。 * Note that pools with similar properties but * different details (for example, timeout * parameters) may be created using &#123;@link * ThreadPoolExecutor&#125; constructors. *请注意，可以使用&#123;@link ThreadPoolExecutor&#125;构造函数创 建具有相似属性但不同详细信息（例如，超时参数）的池。 * @return the newly created thread pool */ public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125;","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/categories/JAVA基础/"}],"tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/tags/JAVA基础/"}]},{"title":"关键字volatile和synchronized","slug":"关键字volatile和synchronized","date":"2020-05-13T03:51:19.000Z","updated":"2021-01-14T08:45:12.910Z","comments":true,"path":"2020/05/13/关键字volatile和synchronized/","link":"","permalink":"/2020/05/13/关键字volatile和synchronized/","excerpt":"","text":"volatile ：ˈvälətlsynchronized ：ˈsiNGkrəˌnaīzd JAVA内存模型（JAVA Memory Model JMM） JAVA内存模型定义了程序中各个变量的访问规则，即JVM将共享变量从内存存取的底层细节。主内存是线程共享的区域例如堆和方法区，而工作内存实现线程私有的，例如PC寄存器、虚拟机栈JMM规定所有共享变量都存储在主内存中，每条线程拥有自己的工作内存（比作缓冲区的概念），线程的工作内存中保存了主内存变量的拷贝副本。线程对共享变量的操作都在工作内存中进行，工作内存在线程是私有的，其他线程无法访问，变量的传递都是通过主内存来完成。 主内存与工作内存同步的中操作： lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程的独占状态； unlock（解锁）：作用于主内存的变量，将一个变量从lock状态解锁，释放出来的该变量才能被其他线程lock； read（读取）：作用于主内存的变量，将一个变量的值从主内存传输大工作内存，以便于后面的load操作使用； load（载入）：作用于工作内存，把read操作从主内存得到的变量值放到工作内存的变量副本中； use（使用）：作用于工作内存的变量，把一个工作内存中的变量值传递给执行引擎，当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作； assign（赋值）：作用于工作内存的变量，把一个从执行引擎收到的值赋值给工作内存的变量，当虚拟机遇到一个需要给变量赋值的字节码指令时就会执行该操作； store（存储）：作用于工作内存的变量，把一个工作内存中的变量的值传送到主内存中，以便于随后的write操作； write（写入）：作用于主内存的变量，把store操作从工作内存中的一个变量的值传送到主内存的变量中。 3个特性：1.原子性（Atomicity）：原子代表不可分割的最小单位。原子性指一个操作或多个操作要么全部执行，要么就都不执行。例如银行转账操作 A账户减去10000元和B账户增加10000元必须全部执行，否则就会出现错误，这两个操作不可再分割。read、load、use、assign、store、write操作都保证了原子性的操作，基本数据类型的读取大致都具有原子性。更大范围保证原子性JMM提供了lock和unlock操作，JVM提供了更高层次的字节码指令monitorenter和monitorexit来隐式使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。2.可见性（Visibility）：一个线程中堆共享变量（类中的成员变量或静态变量）的修改，其他线程立即得知这个修改。保证可见性的操作：volatile：volatile的特殊规则保证了新值立即同步到主内存中，以及每次使用前立即从主内存中刷新。synchronized：synchronized关键字在释放锁之前，必须把此变量同步回主内存中（执行了store、write操作）。final：final修饰的变量，一旦完成初始化，其他线程就能看见final字段的值。3.有序性（Orderly）：有序性主要涉及了指令重排序现象和“工作内存与主内存同步延迟”现象。总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程的所有的操作都是无序的。为了执行的效率，有时候会发生指令重排，这在单线程中指令重排之后的输出与我们的代码逻辑输出还是一致的。但在多线程中就可能发生问题，volatile在一定程度上可以避免指令重排。 volatile和synchronized synchronized保证了原子性和可见性，JMM中synchronized块执行流程清空工作内存-&gt;在主内存中拷贝变量值到工作内存的副本中-&gt;执行完代码-&gt;将更新后的共享变量值刷新到主内存中-&gt;释放同步锁volatile保证了可见性和有序性。线程中volatile修饰的变量对其他线程共享变量的修改是可立即看见的。有序性上volatile可以一定程度避免指令重排，volatile在生成指令上会加一个lock前缀，这个前缀相当于内存屏障可以避免指令重排序不能把后面的指令重排序到内存屏障之前的位置。synchronized作用于代码块和方法，而volatile是变量修饰符。volatile不会造成线程的阻塞,而synchronized可能会造成线程阻塞。 synchronized用法1.（普通class）当一个线程访问对象中的synchronized(this)同步代码块时，其他试图访问这个对象的synchronized(this)同步代码块的线程将被阻塞。 123456789101112131415161718class Test &#123; public Test() &#123; &#125; public void runTest(String threadName) &#123; synchronized (this) &#123; for (int counter = 0; counter &lt; 5; counter++) &#123; System.out.println(threadName + \" counter is\" + counter); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 1234567891011121314151617Test test = new Test(); Thread threadA = new Thread(new Runnable() &#123; @Override public void run() &#123; test.runTest(\"threadA\"); &#125; &#125;); Thread threadB = new Thread(new Runnable() &#123; @Override public void run() &#123; test.runTest(\"threadB\"); &#125; &#125;); threadA.start(); threadB.start(); threadA counter is0threadA counter is1threadA counter is2threadA counter is3threadA counter is4threadB counter is0threadB counter is1threadB counter is2threadB counter is3threadB counter is4 2.当一个线程访问对象的synchronized(this)代码块时，其他线程可以访问该对象的其他非同步代码块。 3.当一个线程访问对象的synchronized(obj)代码块时,相当于给obj对象加了锁，那么访问其他试图访问obj对象的线程将会阻塞，直到该对象对obj的访问结束。synchronized(obj)可以理解为哪个线程拿到了obj的锁就可以访问同步代码块的代码。 3.当synchronized修饰一个普通方法时，同步代码块对整个方法生效。4.当synchronized修饰一个静态方法时，同步锁生效的是整个类。 123456789101112131415class Test &#123; public Test() &#123; &#125; public synchronized static void runTest(String threadName) &#123; for (int counter = 0; counter &lt; 5; counter++) &#123; System.out.println(threadName + \" counter is\" + counter); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 123456789101112131415161718Test test = new Test(); Test test2 = new Test(); Thread threadA = new Thread(new Runnable() &#123; @Override public void run() &#123; test.runTest(\"threadA test\"); &#125; &#125;); Thread threadB = new Thread(new Runnable() &#123; @Override public void run() &#123; test2.runTest(\"threadB test2\"); &#125; &#125;); threadA.start(); threadB.start(); threadA test counter is0threadA test counter is1threadA test counter is2threadA test counter is3threadA test counter is4threadB test2 counter is0threadB test2 counter is1threadB test2 counter is2threadB test2 counter is3threadB test2 counter is4 5.当synchronized修饰的是一个类时，场景与4相同，属于类锁。 synchronized修饰类和静态方法时它作用在类上，属于类锁；修饰普通方法、代码块时它作用在类的对象上，属于对象锁，类锁和对象锁作用的目标时不同的，所以它两互不干扰","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/categories/JAVA基础/"}],"tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/tags/JAVA基础/"}]},{"title":"join方法","slug":"join方法","date":"2020-05-13T02:20:15.000Z","updated":"2020-05-16T10:47:12.448Z","comments":true,"path":"2020/05/13/join方法/","link":"","permalink":"/2020/05/13/join方法/","excerpt":"","text":"join()是用来保证线程间顺序调度的一个方法，是Thread类的方法。例如在ThreadA中执行了ThreadB.join(),此时ThreadA进入等待状态，直到ThreadB执行结束后才唤醒ThreadA继续执行后续的方法。join()可传时间也可不传，传值下等待具体时间后唤醒，不传值要等到被调线程结束后唤醒。 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Package: com.litchi.demo.java * Date: 2020/5/13 * Desc: 演示join方法调度线程执行 * * @author liujicheng */class JoinTest &#123; public static void main(String[] args) &#123; Thread threadB = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"threadB run start\"); try &#123; //这里sleep为了让threadA开始执行 Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int i = 1 &lt;&lt; 6; while ((i = i &gt;&gt; 1) &gt; 0) &#123; System.out.println(\"threadB run i=\" + i); &#125; System.out.println(\"threadB finish\"); &#125; &#125;); Thread threadA = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"threadA run start\"); try &#123; System.out.println(\"threadA call threadB.join()\"); threadB.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"threadA continue\"); System.out.println(\"threadA continue\"); System.out.println(\"threadA finish\"); &#125; &#125;); threadB.start(); threadA.start(); &#125;&#125; 执行结果： 如果不加join()的执行结果： 这里threadB.join()为什么去执行threadB，因为join()内部是用wait()实现的，所以这里把threadB看作是Object，Object.wait()就是操作当前线程去等待，也就是这里的threadB.join()使得threadA调用Object.wait()方法。 join()的内部实现原理其实是wait() 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Waits at most &#123;@code millis&#125; milliseconds for this thread to * die. A timeout of &#123;@code 0&#125; means to wait forever. * * &lt;p&gt; This implementation uses a loop of &#123;@code this.wait&#125; calls * conditioned on &#123;@code this.isAlive&#125;. As a thread terminates the * &#123;@code this.notifyAll&#125; method is invoked. It is recommended that * applications not use &#123;@code wait&#125;, &#123;@code notify&#125;, or * &#123;@code notifyAll&#125; on &#123;@code Thread&#125; instances. * * @param millis * the time to wait in milliseconds * * @throws IllegalArgumentException * if the value of &#123;@code millis&#125; is negative * * @throws InterruptedException * if any thread has interrupted the current thread. The * &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is * cleared when this exception is thrown. */ public final synchronized void join(long millis) throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125; &#125; millis小于0抛出IllegalArgumentException异常； millis等于0循环isAlive()判断当前线程是否存活，存活就调用wait(0),把当前线程放入对象的等待集合中，直到对象线程结束才唤醒当前线程； millis大于0 循环isAlive()判断当前线程是否存活，存活就调用wait()传入等待时间，等到时间到后唤醒当前线程的执行。","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/categories/JAVA基础/"}],"tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/tags/JAVA基础/"}]},{"title":"“sleep方法和wait方法”","slug":"sleep方法和wait方法","date":"2020-05-12T07:11:37.000Z","updated":"2020-05-16T10:47:54.555Z","comments":true,"path":"2020/05/12/sleep方法和wait方法/","link":"","permalink":"/2020/05/12/sleep方法和wait方法/","excerpt":"","text":"sleep() 12345678910111213141516171819/** * Causes the currently executing thread to sleep (temporarily cease * execution) for the specified number of milliseconds, subject to * the precision and accuracy of system timers and schedulers. The thread * does not lose ownership of any monitors. * * @param millis * the length of time to sleep in milliseconds * * @throws IllegalArgumentException * if the value of &#123;@code millis&#125; is negative * * @throws InterruptedException * if any thread has interrupted the current thread. The * &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is * cleared when this exception is thrown. * 根据系统计时器和调度程序的精度和准确性，使得当前的执行线程进入睡眠状态（暂时停止继续执行）达到指定的毫秒数。在这期间该线程不会失去任何所有权。 */ public static native void sleep(long millis) throws InterruptedException; sleep()是Thread类的静态方法。调用该方式使得当前线程进入指定毫秒数的睡眠状态，并且不会释放同步资源锁。sleep()需要catch InterruptedException，否则线程在被其他线程中执行对该线程的interrupt()方法，sleep()就会报InterruptedException 线程就会被终止。 wait() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** * Causes the current thread to wait until either another thread invokes the * &#123;@link java.lang.Object#notify()&#125; method or the * &#123;@link java.lang.Object#notifyAll()&#125; method for this object, or a * specified amount of time has elapsed. * 导致当前线程去等待，直到其他线程触发 * java.lang.Object#notify()方法或者一个特定的时间值执 * 行过去（设置的执行时间完成） * &lt;p&gt; * The current thread must own this object's monitor. * 当前线程必须拥有该对象的监视器。 * &lt;p&gt; * This method causes the current thread (call it &lt;var&gt;T&lt;/var&gt;) to * place itself in the wait set for this object and then to relinquish * any and all synchronization claims on this object. * 这个方法导致当前线程将自己放在一个对象的等待集中，并且放弃了任何的同步声明在当前对对象中。 * Thread &lt;var&gt;T&lt;/var&gt; * becomes disabled for thread scheduling purposes and lies dormant * until one of four things happens: * 线程称为不可调度并处于休眠状态，直到一下四种状况发生： * &lt;ul&gt; * &lt;li&gt;Some other thread invokes the &#123;@code notify&#125; method for this * object and thread &lt;var&gt;T&lt;/var&gt; happens to be arbitrarily chosen as * the thread to be awakened. * 某些其他线程触发notify方法，对于当前对象和线程恰好被任 * 意选择为要唤醒的线程。 * &lt;li&gt;Some other thread invokes the &#123;@code * notifyAll&#125; method for this * object. * 某些其他线程触发notifyAll方法针对当前对象 * &lt;li&gt;Some other thread &#123;@linkplain * Thread#interrupt() interrupts&#125; * thread &lt;var&gt;T&lt;/var&gt;. * 某些其他线程触发了interrupts方法。 * &lt;li&gt;The specified amount of real time has * elapsed, more or less. If * &#123;@code timeout&#125; is zero, however, then real * time is not taken into * consideration and the thread simply waits * until notified. * 特定的时间大致过去。如果这个时间是0，则不考虑时间，线程 * 只能等待通知 * &lt;/ul&gt; * The thread &lt;var&gt;T&lt;/var&gt; is then removed from * the wait set for this * object and re-enabled for thread scheduling. * 这个线程然后从等待集中移除，并且重新能够被线程调度。 * It then competes in the * usual manner with other threads for the right to synchronize on the * object; * 然后它与其他线程一样以通常的方式在对象上竞争同步的权利； * once it has gained control of the object, all * its synchronization claims on the object are * restored to the status quo * ante - that is, to the situation as of the time that the &#123;@code wait&#125; * method was invoked. * 一旦获得了对象的控制权，所有它的同步声明将恢复原状即调用方法是的情况。 * Thread &lt;var&gt;T&lt;/var&gt; then returns from the * invocation of the &#123;@code wait&#125; method. * 线程返回方法的调用。 * Thus, on return from the * &#123;@code wait&#125; method, the synchronization state of the object and of * thread &#123;@code T&#125; is exactly as it was when the &#123;@code wait&#125; method * was invoked. * 因此，从&#123;@code wait&#125;方法返回时，对象和线程&#123;@code T&#125; * 的同步状态与调用&#123;@code wait&#125;方法时的状态完全相同。 * &lt;p&gt; * A thread can also wake up without being notified, interrupted, or * timing out, a so-called &lt;i&gt;spurious wakeup&lt;/ * i&gt;. * 线程也可以在不被通知，中断或中断的情况下唤醒 *超时，即所谓的虚假唤醒。 * While this will rarely * occur in practice, applications must guard * against it by testing for * the condition that should have caused the * thread to be awakened, and * continuing to wait if the condition is not * satisfied. * 尽管在实践中这种情况很少发生，但是应用程序必须通过测试应 * 该导致线程唤醒的条件来防范它，并在条件不满足时继续等待。 * In other words, * waits should always occur in loops, like this * one: * 换句话说，等待应该总是在循环中发生，就像这样： * &lt;pre&gt; * synchronized (obj) &#123; * while (&amp;lt;condition does not hold&amp;gt;) * obj.wait(timeout); * ... // Perform action appropriate to condition * &#125; * &lt;/pre&gt; * (For more information on this topic, see Section 3.2.3 in Doug Lea's * \"Concurrent Programming in Java (Second Edition)\" (Addison-Wesley, * 2000), or Item 50 in Joshua Bloch's \"Effective Java Programming * Language Guide\" (Addison-Wesley, 2001). * * &lt;p&gt;If the current thread is &#123;@linkplain java.lang.Thread#interrupt() * interrupted&#125; by any thread before or while it is waiting, then an * &#123;@code InterruptedException&#125; is thrown. * 如果当前线程被任何其他线程中断则将会抛出 * InterruptedException * This exception is not * thrown until the lock status of this object has been restored as * described above. * 上述的异常在对象锁定状态恢复之前不会发生。 * * &lt;p&gt; * Note that the &#123;@code wait&#125; method, as it * places the current thread * into the wait set for this object, unlocks * only this object; * 注意wait方法被放置在当前线程对于该独享的等待集中，解锁 * 仅针对该对象 * any other objects on which the current thread * may be synchronized remain locked while the * thread waits. * 在当前线程的其他对象可能在同步时保持锁定在线程等待时。 * &lt;p&gt; * This method should only be called by a thread * that is the owner of this object's monitor. * 该方法只能由线程调用是该对象的监视器的所有者。 * See the &#123;@code notify&#125; method for a * description of the ways in which a thread can * become the owner of * a monitor. *有关线程可以成为监视器所有者的方式的描述，请参见&#123;@codenotify&#125;方法。 * @param timeout the maximum time to wait in milliseconds. * @throws IllegalArgumentException if the value of timeout is * negative. * @throws IllegalMonitorStateException if the current thread is not * the owner of the object's monitor. * @throws InterruptedException if any thread interrupted the * current thread before or while the current thread * was waiting for a notification. The &lt;i&gt;interrupted * status&lt;/i&gt; of the current thread is cleared when * this exception is thrown. * @see java.lang.Object#notify() * @see java.lang.Object#notifyAll() */ public final native void wait(long timeout) throws InterruptedException; wait()是Object类的方法.主要用来协调多线程对共享资源的存取。当线程调用wait()方法时，该线程就和对象放置在等待集（或叫等待池）中，同时释放对象锁，当满足一定条件等待结束时，唤醒当前在等待集中的该线程（此时该线程与其他线程一起争夺对象的同步权）,从等待集中移除的方式有：1.某些其他线程触发notify方法，对于当前对象和线程恰好被任意选择为要唤醒的线程；2.某些其他线程触发notifyAll方法；3.某些其他线程触发了interrupts方法；4.设置的特定wait时间到了。如果这个时间是0，则不考虑时间，线程只能等待通知。 其他线程调用interrupts方法中断时如果当前对象正在被其他线程占用，那么InterruptedException会在对象锁定状态恢复后抛出示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Package: com.litchi.demo.java * Date: 2020/5/12 * Desc: com.litchi.demo.java * * @author liujicheng */class LockTest &#123; public static java.lang.Object resourceOne = new Object(); public static void main(String[] args) &#123; Thread threadA = new Thread(new RunnableA()); threadA.start(); Thread threadB = new Thread(new RunnableB(threadA)); threadB.start(); &#125; static class RunnableA implements Runnable &#123; @Override public void run() &#123; synchronized (resourceOne) &#123; System.out.println(\"Thread A lock resourceOne\" + TimeUtil.getTime(System.currentTimeMillis())); try &#123; resourceOne.wait(); &#125; catch (InterruptedException e) &#123; System.out.println(\"ThreadA:\" + TimeUtil.getTime(System.currentTimeMillis())); &#125; &#125; &#125; &#125; static class RunnableB implements Runnable &#123; Thread thread; public RunnableB(Thread thread) &#123; this.thread = thread; &#125; @Override public void run() &#123; int i = 1 &lt;&lt; 3; while ((i = i &gt;&gt; 1) &gt; 0) &#123; synchronized (resourceOne) &#123; System.out.println(\"Thread B lock resourceOne:\" + TimeUtil.getTime(System.currentTimeMillis())); if (i == 4) &#123; System.out.println(\"Thread B request interrupt threadA:\" + TimeUtil.getTime(System.currentTimeMillis())); thread.interrupt(); try &#123; java.lang.Thread.sleep(8000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; try &#123; java.lang.Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 运行结果： 这里可以看到catch内的执行是在Thread B线程释放锁resourceOne对象后抛出的。 两者区别比较： 1.sleep()时Thread类的静态方法，wait()是Object类的方法；2.sleep()只是让当前线程休眠，不会释放同步锁，资源会被持续占有，wait()会释放同步锁，会把线程放入对象的wait集合中；3.sleep()可以在任何地方使用，wait()方法、notify()方法和notiftAll()方法用于协调多线程对共享数据的存取，所以只能在同步方法或者同步块中使用，否则抛出IllegalMonitorStateException；4.sleep()必须传入时间，而wait()可以传，也可以不传，如果不传要通过otify()方法和notiftAll()方法唤醒。","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/categories/JAVA基础/"}],"tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/tags/JAVA基础/"}]},{"title":"“死锁”","slug":"“死锁”","date":"2020-05-11T10:16:06.000Z","updated":"2020-05-11T11:47:30.298Z","comments":true,"path":"2020/05/11/“死锁”/","link":"","permalink":"/2020/05/11/“死锁”/","excerpt":"","text":"死锁的含义 死锁就是进程由于争夺资源造成的僵持状态，无外力作用下无法向前推进。 图中资源-1被线程a持有、资源-2被线程b持有，同时线程a又请求获得资源-2，线程b又请求获得资源-1，这个时候线程a和线程b都处于等待状态无法向前执行就处于了死锁状态。 死锁的四个必要条件1.互斥 一个资源在一段时间内只能被一个进程持有（占用）；2.请求和持有 进程在请求资源阻塞时，对已获得资源保持持有不放；3.不可抢占 进程已获得的资源在未使用完之前不能被其他进程抢占（剥夺），只能由自己释放；4.循环等待 若干进程之间形成一种头尾相接的循环等待资源关系。预防死锁的方法就是破坏死锁的四个必要条件 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Package: com.litchi.demo.java * Date: 2020/5/11 * Desc: com.litchi.demo.java * * @author liujicheng */class DeadLock &#123; public static Object resourceOne = new Object(); public static Object resourceTwo = new Object(); public static void main(String[] args) &#123; new java.lang.Thread(new RunnableA()).start(); new java.lang.Thread(new RunnableB()).start(); &#125; static class RunnableA implements Runnable &#123; @Override public void run() &#123; while (true) &#123; synchronized (resourceOne) &#123; System.out.println(&quot;Thread A lock resourceOne&quot;); //停留5s让ThreadB锁住resourceTwo try &#123; java.lang.Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (resourceTwo) &#123; System.out.println(&quot;Thread A lock resourceTwo&quot;); &#125; &#125; &#125; &#125; &#125; static class RunnableB implements Runnable &#123; @Override public void run() &#123; while (true) &#123; synchronized (resourceTwo) &#123; System.out.println(&quot;Thread B lock resourceTwo&quot;); //停留5s让ThreadB锁住resourceTwo// try &#123;// java.lang.Thread.sleep(5000);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; synchronized (resourceOne) &#123; System.out.println(&quot;Thread B lock resourceOne&quot;); &#125; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/categories/JAVA基础/"}],"tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/tags/JAVA基础/"}]},{"title":"HashMap原理","slug":"HashMap原理","date":"2020-05-09T04:30:20.000Z","updated":"2020-05-16T10:48:45.549Z","comments":true,"path":"2020/05/09/HashMap原理/","link":"","permalink":"/2020/05/09/HashMap原理/","excerpt":"","text":"HashMap的内部存储是以数组+链表+红黑树为组合的复合结构，数组(table)中元素是Entry，键值对(key-value)中key的hashCode值决定了Entry元素在数组中的位置，当发生hash冲突时，相同hash值的Entry元素组成链表，链表的长度是有定长的（TREEIFY_THRESHOLD=8），当链表触发链表树化，就会变成树形结构。 1234567/** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */ transient Node&lt;K,V&gt;[] table; hash() 123456789101112131415161718192021222324252627/** * Computes key.hashCode() and spreads (XORs) higher bits of hash * to lower. Because the table uses power-of-two masking, sets of * hashes that vary only in bits above the current mask will * always collide. (Among known examples are sets of Float keys * holding consecutive whole numbers in small tables.) So we * apply a transform that spreads the impact of higher bits * downward. There is a tradeoff between speed, utility, and * quality of bit-spreading. Because many common sets of hashes * are already reasonably distributed (so don't benefit from * spreading), and because we use trees to handle large sets of * collisions in bins, we just XOR some shifted bits in the * cheapest possible way to reduce systematic lossage, as well as * to incorporate impact of the highest bits that would otherwise * never be used in index calculations because of table bounds. * * 计算key.hashCode()并且移动高位到低位。由于数组使用2的幂次表示，变化仅仅在hash集合 * 的上方中这将总是发生碰撞（这其中的例子是Float的key集合在小的table中保持连续的数 * 字），所以我们应用高位向下移动的影响来作为转化。在速度、实用和为扩展上需要权衡，由于 * 许多哈希集已经合理的分布（所以无需从移动位中受益），并且因为我们使用了树来处理容器中 * 更大的冲突，因此我们仅以最简答单的方式对一些以为后的微bit进行XOR，以减少系统损耗， * 以及最高位的影响，否则由于table番位的限制，这些高位将永远不会在索引计算中使用。 */ static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 可以看到hash方法中将Object key计算出的hashCode右移了16位，这里的原因官方注释中已经很明了，这样做是为了将高位的信息在hash值进行计算索引中降低冲突的概率，因为在一些hash中低位可能会相同，所以这里移位来使得hash更加分布均匀。 构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; /** * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; 看到HashMap1.8中四个构造函数，主要就看第一个，两个入参initialCapacity是table数组的大小，默认值DEFAULT_INITIAL_CAPACITY=16，loadFactor负载因子用来控制扩容的阈值默认DEFAULT_LOAD_FACTOR=0.75f，就是当table的threshold到达0.75时触发table扩容。这里tableSizeFor(initialCapacity)方法是利用传入的初始化table容量转为2的幂次数。 put方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; /** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0)//（1） n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null)//（2） tab[i] = newNode(hash, key, value, null); else &#123;//（3） Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))//（4） e = p; else if (p instanceof TreeNode)//（5） e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123;//（6） for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))//（7） break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value;//（8） if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount;//（9） if (++size &gt; threshold)//(10) resize(); afterNodeInsertion(evict); return null; &#125; 这里主要看putVal()方法。（1）这里第一个if判断table是否为空，为空就利用resize方法初始化；（2）第二个if判断如果当前根据hash跟到的table索引下为空就直接将Node对象放入table中；（3）else下是hash发生碰撞；（4）首先第一个if判断的是如果NewNode和table中位置的Node hash值和key都相同就直接可以看作是同一个Node，这里还有个场景是否用新put的values覆盖老的value，onlyIfAbsent为false或者老的value为空就要覆盖掉老值；（5）else if判断如果是一个树结点就调用putTreeVal插入元素；（6）else下循环遍历将p添加到链表尾部，如果这时达到链表最大阈值就需要调用treeifyBin方法进行树化；（7）如果已经在链表中就braek掉；（8）这里判断是否需要覆盖老数据。（9）modCount保证并发访问，这里的put方法是线程不安全的，所以当modCount发现变化不一致就会抛出ConcurrentModificationException。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120 final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125;``` (10)这里对table扩容。* resize方法 ``` java/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table * * 初始化或增加成两倍大的table，如果为空，则根据字段阈值中保持的初始容量目标进行分配。 * 否则，因为我们使用的是2的幂，所以每个bin中的元素必须保持相同的索引，或者在新表中以2 * 的幂偏移。 */ final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123;//（1） Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order //（2） Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 上面的代码基本都很好理解的，这里主要说两个点：（1）这个位置是table变成两倍table的元素移动的操作，e.nex=null说明它就是一个元素不存在链和树直接根据e.hash &amp; (newCap - 1)计算出它在新table中的位置并赋值；如果是树通过split方法复制树；（2）这里比较重要的操作。这里是链表复制的过程，这里链表上的Node位置有两个场景，一种是不需要移动的Node形成链表还在老的index下，另一种是需要我们移动位置的Node形成新的链表复制到新的index下。这里为什么会有这个操作，因为index值的确定是根据Node.hash和cap-1取与获得的，那么在变成两倍table后讲道理每一个index都需要重新取计算，但是这里观察变成两倍table的原理其实每次threshold&lt;&lt;1（也就是二进制高位变成1），那么这样Node.hash和cap-1取与过程中发生变化的就只有高位是1的所以这里(e.hash &amp; oldCap) == 0表示在变成两倍table后index不需要变化，如果需要变化那么index=老idnex+oldCap。 get方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Returns the value to which the specified key is mapped, * or &#123;@code null&#125; if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * &#123;@code k&#125; to a value &#123;@code v&#125; such that &#123;@code (key==null ? k==null : * key.equals(k))&#125;, then this method returns &#123;@code v&#125;; otherwise * it returns &#123;@code null&#125;. (There can be at most one such mapping.) * * &lt;p&gt;A return value of &#123;@code null&#125; does not &lt;i&gt;necessarily&lt;/i&gt; * indicate that the map contains no mapping for the key; it's also * possible that the map explicitly maps the key to &#123;@code null&#125;. * The &#123;@link #containsKey containsKey&#125; operation may be used to * distinguish these two cases. * * @see #put(Object, Object) */ public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125;/** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */ final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; get方法相对简单直接通过key和hash取查找元素，如果是table中的first直接返回如果是tree从tree遍历g得到，如果是链表遍历拿到。 总结hash()方法的关键是高位右移的操作，目的是为了使得hash趋于均匀分布，避免hash冲突（碰撞），在与table.length取与获得index时尽降低形成链put()方法完成table创建和初始化和新增Node，新增Node分三个场景直接放置在table[index]位置；形成链表的插入链表中，链表达到阈值形成红黑树resize()方法完成 两倍扩展以及扩展后的Node的重新放置，这里重要是巧妙的使用 (e.hash &amp; oldCap) == 0来作为是否将老链表数据分开放置的处理，利用扩容和2的幂的关系进行操作","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/categories/JAVA基础/"}],"tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/tags/JAVA基础/"}]},{"title":"运行时数据区","slug":"运行时数据区","date":"2020-05-08T05:07:49.000Z","updated":"2020-05-08T08:18:38.654Z","comments":true,"path":"2020/05/08/运行时数据区/","link":"","permalink":"/2020/05/08/运行时数据区/","excerpt":"","text":"运行时数据区也就是JVM运行时的内存区域，这里主要划分为堆区、方法区、虚拟机栈、本地方法栈和PC寄存器。 堆区：堆区是这其中最大的一块区域，保存几乎所有创建出来的对象实例，这块区域是线程共享的，堆区是垃圾回收的主要区域，因此也叫“GC堆”,在GC回收时采用分代收集算法，所以堆区分为新生代和老年代。堆区在物理上时不连续的，在逻辑中看作是连续的。在堆区分配内存给对象实例时如果内存不足，会抛出OutOfMemoryError异常。Minor Gc和Major Gc(Full GC)：Minor Gc是指新生代垃圾回收的动作，新创建的对象都会在新生代，所以Minor Gc相对频繁，回收速度相对也快；Major Gc(Full GC)时老年代的垃圾回收动作，Major Gc(Full GC)回收频率较慢，速度也较慢。 方法区：方法区线程共享，方法去存储类的信息、常量、静态变量以及运行时常量池(Runtime Constant Pool:常量不一定只能在编译期产生，运行期间也可能产生新的常量，这些常量被放在运行时常量池中，例如通过String.intern()将String放入常量池)。 虚拟机栈和本地方法栈：虚拟机栈每个线程在创建时都会创建一个虚拟机栈，内部是由一个个的栈帧组成(Stack Frame)，一个栈帧就对应一个Java方法调用。它主管Java程序的运行，保存方法的局部变量（8中基本数据类型、对象引用地址）、部分结果，并参与方法的调用和返回。虚拟机栈的大小允许是固定的或者是动态的： 虚拟机栈大小固定情况下，如果线程请求分配的栈容量超过了虚拟机栈允许的最大容量就会报StackOverFlowError异常。虚拟机栈大小动态的情况下，当虚拟机栈请求扩展容量而这时内存不足JVM就会抛出OutOfMemoryError异常，同样在创建线程时如果没有足够的内存空间提供给虚拟机栈，也会报OutOfMemoryError异常。 每个栈帧包含：局部变量表、操作数栈、动态链接和方法返回地址。1.局部变量表：局部变量表存储方法参数和定义在方法内的局部变量，局部变量表的存储单位时slot（变量槽），存储的数据类型包括基本数据类型、引用数据类型和返回地址类型。 局部变量表的大小是在编译期间就确定下来的。 2.操作数栈：操作数栈在方法执行的过程中根据字节码指令写或者提取数据（入栈和出栈）。3.动态链接（Dynamic Linking）：即指向运行时常量池的引用它是栈帧内部指向运行时常量池中该栈帧所属方法的引用。动态链接的作用是为将符号应用转换为调用方法的直接引用。4.方法返回地址（return address）：方法返回地址存放调用该方法的PC寄存器的值。方法退出救市栈帧出栈的过程，此时需要恢复上层方法的局部变量表、操作数栈，将返回值压入调用者的操作数栈中，更新PC寄存器，调用者继续执行接下来的指令。异常完成退出不会给上层调用者产生任何返回值 本地方法栈结构与Java虚拟机栈相同，只是它服务的是本地方法，也有些虚拟机中将本地方法栈和Java虚拟机栈合二为一。 PC寄存器（Program Counter Register）：PC寄存器用来存放下一行执行指令的地址，由执行引擎读取下条指令。根据是一块很小的内存区域，每个线程都有自己的PC寄存器，它是线程私有的区域，生命周期与线程的生命周期保持一致。PC寄存器是JVM规范中唯一一个不会发生OutOfMemory的区域，也不存在GC。PC寄存器可以保证线程切换时指令不会发生异常，在来回切换后可以回到切换前执行位置继续执行。","categories":[{"name":"JVM","slug":"JVM","permalink":"/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"}]},{"title":"关于作者","slug":"关于作者","date":"2020-05-07T12:32:47.000Z","updated":"2020-05-07T12:34:06.625Z","comments":true,"path":"2020/05/07/关于作者/","link":"","permalink":"/2020/05/07/关于作者/","excerpt":"","text":"litchi 1992-05-20 浙江杭州 Android JAVA","categories":[],"tags":[]},{"title":"GC机制","slug":"GC机制","date":"2020-05-07T07:51:31.000Z","updated":"2020-05-07T10:59:28.215Z","comments":true,"path":"2020/05/07/GC机制/","link":"","permalink":"/2020/05/07/GC机制/","excerpt":"","text":"垃圾回收机制是JVM持续运行的关键，当JVM在运行过程中会产生很多“无用”的对象，如果没有及时GC就会导致我们虚拟机运行效率的降低，从而引发系统的异常。在运行时数据区中程序计数器、虚拟机栈、本地方法栈是线程私有的，不需要进行垃圾回收。方法区和堆区线程共享需要进行垃圾回收，堆是Java虚拟机进行垃圾回收的主要场所，其次要场所是方法区。垃圾回收分两步找到垃圾和回收垃圾，一般查找垃圾有两种方法引用计数法和可达性分析算法。引用计数法就是给每个创建的对象添加一个引用计数器，当有一地方引用它时引用计数器加1，当有引用消除时引用计数器减1。当引用计数器等于0时就表示该对象可收回。标记计数法存在的问题时当有两个或几个对象互相引用时，它们的引用计数器永远不会为0，就永远不会被回收。可达性分析算法（根搜索算法）以根对象作为根结点进行搜索，当有对象不可达时就认为该对象可回收，根对象一般指虚拟机栈中的引用对象、本地方法栈中JNI的引用对象、方法区中运行常量池中的引用对象、方法区中静态属性引用的对象、运行中的线程、由引导类加载器加载的对象、GC控制的对象。垃圾回收算法有：1.标记-清除（mark–sweep）标记所有需要回收的对象，之后统一回收。这是最基础的算法，后续的回收算法都是基于这个算法扩展的。缺点明显效率低，产生大量碎片。2.复制（copying）将内存空间划分两块相等的区域，每次只使用其中的一块区域，垃圾回收时遍历正在使用的区域内对象，将正在使用的引用对象赋值到另一块区域。每次垃圾回收时只处理正在使用的对象，赋值成本低，赋值过去会进行整理，不存在内存碎片。缺点是需要双倍的内存空间，以空间换时间。3.标记-整理或压缩（mark–compact））结合了复制和标记清除的优点，第一步标记所有需要回收的对象，第二部回收对象，并对存活对象进行整理（压缩）。4.分代收集算法根据对象生命周期的不同将对象分为新生代和老年代对象。新生代对象一般又分为Eden区(伊甸园)和两个Survivor区。新创建的u对象都在Eden区，当Eden区内存到达阈值就会出发Minor GC，这是就会把Eden区中的对象复制到其中一个Survivor区中，此时这些存活对象的生命存活计数会加1.这是Eden区空置，Eden区继续存放新创建的对象，当再次触发Minor Gc时，将此时Eden区的存活对象和之前一个Survivor区的存活对象复制到另外一个Survivor区中，同时它们的生命存活计数器加1，这个过程持续发生，当对象的存活计数器达到一定的阈值后触发“晋升”，新生代中的该对象就被放置到了老年代中。老年代中的对象经过多次的GC就会是生命周期很长的对象。当老年代的内存达到阈值时触发Major GC，这是采用标记-整理或压缩（mark–compact）算法。","categories":[{"name":"JVM","slug":"JVM","permalink":"/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"}]},{"title":"JVM结构","slug":"JVM结构","date":"2020-05-02T11:22:13.000Z","updated":"2020-05-07T11:05:31.701Z","comments":true,"path":"2020/05/02/JVM结构/","link":"","permalink":"/2020/05/02/JVM结构/","excerpt":"","text":"JVM(JavaVirtualMachine，Java虚拟机)JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台（write once run anywhere）。JVM包含在JDK中的一部分。 类加载器子系统类加载器子系统主要负责将二进制字节码文件加载成JVM识别的数据结构，并对其文件进行规则校验和一些初始化工作。具体分为三个阶段loading、linking和initialization：loading阶段将字节码文件加载到JVM中，这里有四类加载器来完成，Bootstrap ClassLoader(C++实现，加载Java核心类库/java_home/lib/rt.jar里的类集合)、Extension ClassLoader（加载/java_home/lib/ext里的类集合）、App ClassLoader(package下定义的类)、User define ClassLoader（自定义类加载器）；linking阶段又分为三个阶段：verify、prepare、resolution，verify阶段验证Class文件是否符合JVM语法规则（具体包括类文件信息、元数据信息、字节码验证和符号引用验证）；prepare阶段为变量设置默认初始值，也就是0值，ps：int是0 String null；resolution阶段将符号引用转化为直接应用；initialization阶段完成静态变量的显式赋值和静态代码块的执行。 运行时数据区运行时数据区包括PC寄存器、虚拟机栈、本地方法栈、方法区、堆五部分组成。1.PC寄存器保存下一条将要被执行指令的地址和线程一一对应，这样保证了再线程来回切换时可以回到之前执行的位置；2.虚拟机栈用来描述java方法执行的内存模型，每个线程对应一个栈，栈内的栈帧对应java方法，栈帧结构又包括：局部变量表、操作数栈、动态链接和方法返回地址；3.本地方法栈的功能和结构与虚拟机栈类似，区别在于它服务的对象是native方法；4.方法区是一块线程共享的内存区域，保存类的版本/字段/方法/接口等描述信息以及常量、静态场景等，还有运行时常量池（Runtime Constant Pool）；5.堆用来保存创建对象的主体，是最大的一块数据区，也是线程共享的内存区域。 执行引擎执行引擎是将JVM字节码指令转化为本地物理机可识别的机器指令执行，是JVM的核心部分之一。 本地方法接口本地接口的作用是融合不同的编程语言为java所用。 本地方法库为本地方法提供依赖支持。","categories":[{"name":"JVM","slug":"JVM","permalink":"/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"}]},{"title":"类加载器子系统","slug":"类加载子系统","date":"2020-04-26T11:16:43.000Z","updated":"2020-05-07T11:06:00.851Z","comments":true,"path":"2020/04/26/类加载子系统/","link":"","permalink":"/2020/04/26/类加载子系统/","excerpt":"","text":"类加载过程包括加载（load）、链接（linking）和初始化（init） 加载将字节码文件从数据源中加载到JVM内存中，生成JVM的认可的数据结构（也就是Class对象），数据源可以是来自物理硬盘或者网络的jar文件、war文件、class文件等一些JVM可识别的文件格式结构（文件格式异常回报ClassFormatError）。 链接链接是类加载的核心部分，分三个步骤：验证、准备和解析1.验证（Verify）：保证字节流信息符合JVM规范，避免恶意数据危害JVM的安全运行（异常抛出VerifyError）。2.准备（Prepare）：为类变量分配内存和为变量设置初始值。3.解析（Resolve）：将符号应用转换为直接应用，符号应用就是一组符号来描述所应用的目标，直接应用就是直接指向目标的指针或句柄。 初始化初始化主要是将静态变量赋值和执行静态代码块的一系列操作。 双亲委派机制 双亲委派机制是在类加载过程中加载部分里的机制，加载器大致有启动类加载器Bootstrap ClassLoader（加载核心的类）、扩展类加载器Extension ClassLoader（ext path下的类）和应用类加载器Application ClassLoader（自定义）。在执行类加载请求时，子加载器会先委托父类加载器执行；如果父类加载器还存在父类加载器就继续委托，一次递归找到其顶部启动类加载器；如果启动类加载器可以完成任务则将结果返回，倘若启动类加载器不能完成任务这时一次再让子类加载器尝试加载，这个过程叫双亲委派机制。 双亲委派机制优点1.避免类重复加载2.保护程序安全，防止核心API被篡改（java.lang.String）","categories":[{"name":"JVM","slug":"JVM","permalink":"/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"}]},{"title":"查找算法","slug":"查找算法","date":"2020-04-21T07:00:09.000Z","updated":"2020-05-07T11:06:18.364Z","comments":true,"path":"2020/04/21/查找算法/","link":"","permalink":"/2020/04/21/查找算法/","excerpt":"","text":"插值查找 黄金分割法 线性索引查找 二叉排序树 平衡二叉树 B树 散列表（哈希表）查找*","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"图","slug":"图","date":"2020-04-17T07:10:34.000Z","updated":"2020-05-16T10:50:45.166Z","comments":true,"path":"2020/04/17/图/","link":"","permalink":"/2020/04/17/图/","excerpt":"","text":"图的特点：1.通常用V(Vertex)表示一组定点的集合；2.通常用E(Edge)表示一组边的集合。 顶点：图中的一个结点 图的边：顶点和顶点间的连线，有向图中的边叫做弧 相邻顶点：由一条边连接在一起的顶点 顶点的度：相邻顶点的数量叫做顶点的度 连通图：在无向图中，若任意两个顶点Vi与Vj都有路径相通，则称该无向图为连通图 强连通图：在有向图中，若任意两个顶点Vi与Vj都有路径相通，则称该有向图为强连通图 连通网：在连通图中，若图的边具有一定的意义，每一条边都有一个对应数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网 生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则会形成环 图的深度优先遍历：假设初始状态是图中所有顶点都未被访问，从图中某个顶点v出发，先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到；若此时还有剩余顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 图的广度优先遍历：假设从图中某个顶点v出发，在访问了顶点v之后依次访问顶点v的各个未曾访问过的邻接顶点，然后分别从这些邻接顶点再出发依次访问它们的邻接顶点，并使“先被访问的顶点的邻接顶点”先于“后被访问的顶点的邻接顶点”被访问，直到图中所有已被访问的顶点的邻接点都被访问到；若此时图中还有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 最小生成树：在连通网的所有生成树中，所有边的代价总和最小的生成树，称为最小生成树 1.普里姆算法(Prim算法)： 描述：1.定义一个加权连通图，其中顶点集合V、Vnew，Vnew是V的子集，边的集合E、Enew，Enew是E的子集；2.初始化集合Vnew{x},x(起始点)是集合V中任意一结点，Enew{}；3.从边的集合E中选取权值最小的边&lt;u, v&gt;(其中u是顶点集合Vnew的元素，v属于顶点集合V，而不在新顶点集合Vnew中。若权值相同时，任意取值)；4.将v加入新顶点集合Vnew，将边&lt;u, v&gt;加入新边集合Enew中；5.重复操作3和4步骤 ，知道Vnew=V时，输出集合Vnew和Enew，Vnew和Enew即是来描述该加权连通图的最小生成树。代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253 static class GraphMatrix &#123; /** * 边的数量 */ private int edgeNum; /** * 顶点集合 */ private char[] vertex; /** * 邻接矩阵 */ private int[][] matrix; public GraphMatrix(char[] vertex, int[][] matrix) &#123; this.vertex = vertex; this.matrix = matrix; getEdgeNum(); &#125; private void getEdgeNum() &#123; int length = vertex.length; for (int i = 0; i &lt; length; i++) &#123; for (int j = i + 1; j &lt; length; j++) &#123; //矩阵值等于Integer.MAX_VALUE表示不相邻，等于0是自己到自己 if (matrix[i][j] != Integer.MAX_VALUE) &#123; edgeNum++; &#125; &#125; &#125; &#125; /** * print matrix */ private void printMatrix() &#123; System.out.println(\"矩阵:\"); for (int[] m : matrix) &#123; for (int c : m) &#123; System.out.print(c + \" \"); &#125; System.out.println(); &#125; &#125; /** * 获取字符在结点里的位置 * * @param c 字符 * @return 返回-1没该字符，其他位置 */ private int getVertexPosition(char c) &#123; for (int i = 0; i &lt; vertex.length; i++) &#123; if (c == vertex[i]) &#123; return i; &#125; &#125; return -1; &#125; /** * 输入开始顶点位置 * * @param x 开始顶点位置 */ public void prime(int x) &#123; int num = vertex.length; //邻边权重 int[] weights = new int[num]; //prime最小生成树结果 char[] result = new char[num]; //result当前索引 int index = 0; //复制第一个顶点值 result[index] = vertex[x]; index++; //init weight 找到顶点相邻边的权重赋值weights[i] for (int i = 0; i &lt; num; i++) &#123; weights[i] = matrix[x][i]; &#125; weights[x] = 0; //循环遍历娶到最短权重值添加到result中 for (int i = 0; i &lt; num; i++) &#123; if (x == i) &#123; continue; &#125; int minWeight = Integer.MAX_VALUE; int minWeightIndex = 0; for (int j = 0; j &lt; num; j++) &#123; if (weights[j] != 0 &amp;&amp; weights[j] &lt; minWeight) &#123; minWeight = weights[j]; minWeightIndex = j; &#125; &#125; //保存最短权重顶点 result[index] = vertex[minWeightIndex]; index++; weights[minWeightIndex] = 0; for (int j = 0; j &lt; num; j++) &#123; if (weights[j] != 0 &amp;&amp; matrix[minWeightIndex][j] &lt; weights[j]) &#123; weights[j] = matrix[minWeightIndex][j]; &#125; &#125; &#125; //计算最小生成树的权重 int sum = 0; for (int i = 1; i &lt; index; i++) &#123; int min = Integer.MAX_VALUE; int n = getVertexPosition(result[i]); //求当前节点到上面其他节点的最小值 for (int j = 0; j &lt; i; j++) &#123; int m = getVertexPosition(result[j]); if (matrix[m][n] &lt; min) &#123; min = matrix[m][n]; &#125; &#125; sum += min; &#125; //打印最小生成树 System.out.printf(\"PRIME(%c):\", vertex[x]); for (int i = 0; i &lt; index; i++) &#123; System.out.printf(\"%c \", result[i]); &#125; System.out.println(); System.out.printf(\"权重：%d\", sum); &#125; &#125;``` 2.克鲁斯卡尔算法(Kruskal算法)：描述： 首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。 代码实现： ``` java /** * 克鲁斯卡尔算法 */ public void Kruskal() &#123; //结果数组的当前索引 int index = 0; //输出的结果数组 Edge[] results = new Edge[edgeNum]; //保存某个顶点在该最小生成树的终点 int[] vends = new int[edgeNum]; //获取图中所有的边 Edge[] edges = getEdges(); //将边按权重从小到大排序 sortEdges(edges); for (int i = 0; i &lt; edgeNum; i++) &#123; int p1 = getVertexPosition(edges[i].start); int p2 = getVertexPosition(edges[i].end); int m = getEdgesEnd(vends, p1); int n = getEdgesEnd(vends, p2); if (m != n) &#123;//表示没有形成闭环 vends[m] = n; results[index++] = edges[i]; &#125; &#125; //统计并打印最小生成树的信息 int length = 0; for (int i = 0; i &lt; index; i++) &#123; length += results[i].weight; &#125; System.out.println(\"Kruskal：\"); for (int i = 0; i &lt; index; i++) &#123; System.out.printf(\"(%c,%c) \", results[i].start, results[i].end); &#125; System.out.println(); System.out.println(\"Kruskal的权重：\" + length); &#125; //连通图的边结构 private static class Edge &#123; char start;//边的起点 char end;//边的终点 int weight;//边的权重 public Edge(char start, char end, int weight) &#123; this.start = start; this.end = end; this.weight = weight; &#125; &#125; /** * 获取图中的边 */ private Edge[] getEdges() &#123; int index = 0; Edge[] edges = new Edge[edgeNum]; for (int i = 0; i &lt; vertex.length; i++) &#123; for (int j = i + 1; j &lt; vertex.length; j++) &#123; if (matrix[i][j] != Integer.MAX_VALUE) &#123; edges[index++] = new Edge(vertex[i], vertex[j], matrix[i][j]); &#125; &#125; &#125; return edges; &#125; /** * 根据权重从小到大排序 * * @param edges edges */ private void sortEdges(Edge[] edges) &#123; Edge tmp; for (int i = 0; i &lt; edges.length; i++) &#123; for (int j = (i + 1); j &lt; edges.length; j++) &#123; if (edges[i].weight &gt; edges[j].weight) &#123;//若大于则交换位置 tmp = edges[i]; edges[i] = edges[j]; edges[j] = tmp; &#125; &#125; &#125; &#125; /** * 取终点 */ private int getEdgesEnd(int[] vends, int i) &#123; //若C-&gt;D,D-&gt;F则取F的值 while (vends[i] != 0) &#123; i = vends[i]; &#125; return i; &#125; 最短路径：","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"树","slug":"树","date":"2020-04-14T14:12:59.000Z","updated":"2020-05-07T11:07:33.990Z","comments":true,"path":"2020/04/14/树/","link":"","permalink":"/2020/04/14/树/","excerpt":"","text":"树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。 特点： 1.在非空树中，根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点；2.子树的个数没有限制，但它们互不相交； 度： 结点的度：结点拥有的子树个数叫做结点的度，结点A的度是3，C的度是2，H的度是1。树的度：树中最大的结点度。图中树的度是3 结点的关系 1.结点子树的根结点称为该结点的 孩子结点，该结点叫做孩子结点的双亲结点。图中E是B的孩子结点，B是E的双亲结点；2.同一双亲的结点叫做兄弟结点，图中的F、G是E的兄弟结点；3.同一层的结点叫做堂兄结点，通中的H、I、J、K、L是E的堂兄结点；4.从根到该结点经过的左右分支结点叫做该结点的祖先结点，图中M的祖先结点有A、B、E。5.该结点的子树任意一个结点都称为该结点的子孙结点，E的子孙结点有M和N。 结点的层次 从根开始定义，根为第一层，根的孩子为第二层，根的孩子的孩子为第三层…。树的深度：树中结点的最大层次数称为树的深度或高度，图中深度为4 二叉树二叉树(Binary Tree)是n(n&gt;=0)个结点的有限集合，该集合或者为空集(空二叉树)，或者由一个跟结点和两个互补相交的、分别称为根的结点在左子树和右子树组成。每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。 二叉树的特点 1.每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点；2.左子树和右子树是有顺序的，次序不能任意颠倒；3.即使树中某结点只有一棵子树，也要区分它是左子树还是右子树； 二叉树的性质 1.在二叉树中第i层上最多有2的i-1次方个结点(i&gt;=1)；2.二叉树中如果深度为k,那么最多有2k-1个节点(k&gt;=1）； 斜树 所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。 满二叉树在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。满二叉树的特点有：1.叶子只能出现在最下一层。出现在其它层就不可能达成平衡。2.非叶子结点的度一定是2。3.在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。 完全二叉树若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。完全二叉树的特点：1.叶子结点只出现在最下层和次下层；2.最下层叶子结点集中在树的左部；3.如果结点度为1，则该结点只有左孩子，即没有右子树；4.相同结点数的二叉树，完全二叉树的深度最小；5.满二叉树一定是完全二叉树，但反过来不一定成立。 二叉树存储结构 1.*** 顺序存储结构二叉树的顺序存储结构就是使用一维数组存储二叉树中的结点，并且结点的存储位置，就是数组的下标索引。 如果索引下为空表示该位置下没有存储结点。 2.*** 链式存储结构 结构定义 12345678class BinaryNode&lt;E&gt; &#123; //数据 E data; //左子树 BinaryNode leftChild; //右子树 BinaryNode rightChild;&#125; 二叉树的遍历 1.前序遍历(DLR)首先访问根，再先序遍历左（右）子树，最后先序遍历右（左）子树图中结果：ABDECFG 12345678910111213141516171819/** * 前序遍历 * * @param root 根 */ public void DLR(BinaryNode root) &#123; if (root == null) &#123; return; &#125; //TODO do something if (root.leftChild != null) &#123; DLR(root.leftChild); &#125; if (root.rightChild != null) &#123; DLR(root.rightChild); &#125; &#125; 2.中序遍历(LDR)首先中序遍历左（右）子树，再访问根，最后中序遍历右（左）子树。图中结果：DBEAFCG 12345678910111213141516171819/** * 中序遍历 * * @param root 根 */ public void LDR(BinaryNode root) &#123; if (root == null) &#123; return; &#125; if (root.leftChild != null) &#123; LDR(root.leftChild); &#125; //TODO do something if (root.rightChild != null) &#123; LDR(root.rightChild); &#125; &#125; 3.后序遍历(LRD)首先后序遍历左（右）子树，再后序遍历右（左）子树，最后访问根图中结果：DEBFGA 12345678910111213141516171819/** * 后序遍历 * * @param root 根 */ public void LRD(BinaryNode root) &#123; if (root == null) &#123; return; &#125; if (root.leftChild != null) &#123; LRD(root.leftChild); &#125; if (root.rightChild != null) &#123; LRD(root.rightChild); &#125; //TODO do something &#125; 4.层序遍历按照层次访问，通常用队列来做。访问根，访问子女，再访问子女的子女 线索二叉树 二叉树线索化的过程中，会把树中的空指针利用起来作为寻找当前节点前驱和后继的线索，这样就出现了一个问题，即线索和数中原有指向孩子节点的指针无法区分。上边的这种节点设计就是为了区分这两类指针。其中，ltag和rtag为标识域，它们的具体意义如下:1.如果ltag==0，表示lchild为指针，指向结点的左子树；2.如果ltag==1，表示lchild为线索，指向结点的直接前驱;3.如果rtag==0，表示rchild为指针，指向结点的右子树；4.如果rtag==1，表示rchild为线索，指向结点的直接后继。 哈夫曼树 当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"字符串匹配算法","slug":"字符串匹配算法","date":"2020-04-14T06:49:35.000Z","updated":"2020-05-07T11:08:09.874Z","comments":true,"path":"2020/04/14/字符串匹配算法/","link":"","permalink":"/2020/04/14/字符串匹配算法/","excerpt":"","text":"BF算法首先原串与字串左端对齐，，如果第一个字符不匹配，字串向后移动逐一移动，当发现死一个第一个字符匹配后，当前位置下比较剩余字串的字符与原串是否匹配，直到全部匹配。 1234567对齐:litchicodercoder逐一移动 找到匹配字符:litchicoder coder 代码实现： 12345678910111213141516171819202122232425262728293031323334class BF &#123; public static void main(String[] args) &#123; int r = queryByBF(&quot;HelloWord&quot;, &quot;Word&quot;); System.out.print(r == 0 ? &quot;字符串匹配失败&quot; : &quot;子字符串在原串的位置：&quot; + r); &#125; /** * @param s 原字符串 * @param t 需要匹配的子字符串位置 */ public static int queryByBF(String s, String t) &#123; char[] a = s.toCharArray(); char[] b = t.toCharArray(); int i = 0, j = 0; while (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123; //比较字符 if (a[i] == b[j]) &#123; i++; j++; &#125; else &#123; //i后退重新匹配 i++; j = 0; &#125; &#125; if (j &gt;= t.length()) &#123; return i - t.length(); &#125; else &#123; //匹配失败 return 0; &#125; &#125;&#125; KMP算法KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"递归和分治","slug":"递归和分治","date":"2020-04-14T05:19:33.000Z","updated":"2020-05-16T10:51:02.881Z","comments":true,"path":"2020/04/14/递归和分治/","link":"","permalink":"/2020/04/14/递归和分治/","excerpt":"","text":"递归高级语言中，函数自己调用和调用其他函数并没有本质的不同，我们把一个直接调用自己或者通过一系列调用语句间接地调用自己的函数，称作递归函数。（ps：每个递归定义必须至少有一个条件，当满足这个条件时递归不再进行，即函数不再调用自身而是返回值） 斐波那契(Fibonacci)数列如果说兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔子都不会死去，能够一直干下去，那么一年以后可以繁殖多少对兔子呢？ 代码实现： 123456int Fib(int i)&#123; if( i &lt; 2 ) return i == 0 ? 0 : 1; return Fib(i-1) + Fib(i-2);&#125; 分治在遥远的周朝，人们受生产力水平所限，无法管理庞大的土地和众多的人民，因此采用了封邦建国的封建制度，把土地一层一层划分下去，以达到分而治之的目的，这也许是最古老的分治法了： 汉诺塔问题汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。 12345678910111213141516171819202122232425262728293031public class Hanoi &#123; /** * * @param n 盘子的个数 * @param a 原来的柱子 * @param b 中间辅助柱子 * @param c 最终到达的目标珠子 */ public void hanoi(int n, char a, char b, char c) &#123; if (n == 1) &#123; move(a, c); &#125; else &#123; //将n-1个盘子从a利用c移动到b盘子 hanoi(n - 1, a, c, b); //将第n个盘子从a移动到c move(a, c); //将n-1个盘子从b利用a移动到c hanoi(n - 1, b, a, c); &#125; &#125; // 移动盘子 private void move(char origin, char target) &#123; System.out.println(\"方向:\" + origin + \"---&gt;\" + target); &#125; public static void main(String[] args) &#123; Hanoi hanoi = new Hanoi(); hanoi.hanoi(3, 'A', 'B', 'C'); &#125;&#125; 快速排序找出第n大的值直尺八皇后问题","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"栈和队列","slug":"栈和队列","date":"2020-04-13T03:53:45.000Z","updated":"2020-05-16T10:50:18.416Z","comments":true,"path":"2020/04/13/栈和队列/","link":"","permalink":"/2020/04/13/栈和队列/","excerpt":"","text":"栈：栈(Stack)是一个后进先出(Last in first out LIFO)的线性表，要求只在表尾进行删除和插入操作了，栈的插入叫做进栈（进栈、压栈、入栈）、栈的删除叫出栈。 队列：队列(queue)是只允许在一端进行插入操作，而另一端进行删除操作的一种先进先出(First in First out FIFo)的线性表1.循环队列： 123456789101112131415161718192021222324252627282930public class CircleQueue&lt;E&gt; &#123; private Object q[]; private int head = 0; private int tail = 0; private int size; public CircleQueue(int size) &#123; this.size = size; q = new Object[size]; &#125; public CircleQueue() &#123; this(10); &#125; public boolean inQueue(E e) &#123; //表示队列已经满了 if ((tail+1) % size == head) return false; q[tail] = e; tail = (tail + 1) % size; return true; &#125; public E outQueue() &#123; if (head == tail) return null; E o = (E) q[head]; head = (head + 1) % size; return o; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"线性表","slug":"线性表","date":"2020-04-08T12:49:40.000Z","updated":"2020-05-07T11:07:52.322Z","comments":true,"path":"2020/04/08/线性表/","link":"","permalink":"/2020/04/08/线性表/","excerpt":"","text":"线性表理解为将数据结点用一根“线”连接起来存储在物理空间，线性表的数据元素一般具有相同的数据类型。大部分线性表中除了第一个元素（没有前驱）和最后一个元素（没有后继）其他元素都有前驱和后继（也就是各元素之间是一对一的关系）。 顺序存储结构（顺序表） 顺序存储结构就是数据是用一块完整的物理空间来连续存储数据，一般它的大小是固定的。优点：物理空间利用率高，增查效率高。缺点：插入和删除效率低，每次都需要移动目标元素后面的所有数据元素，由于它的length是提前分配固定好不能扩容，会发生存储溢出。 链式存储结构链式存储结构中数据元素的存储方式在物理空间中是随机的，数据结点氛围数据域和指针域，数据域存储数据元素，指针域来关联起来数据结点形成链。链式存储结构一般有单链表、双向链表和循环链表。 单链表 题目：找到单链表倒数第n个节点，保证链表中节点的最少数量为n。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for ListNode. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; * &#125; */ public class Solution &#123; /* * @param head: The first node of linked list. * @param n: An integer * @return: Nth to last node of a singly linked list. */ public ListNode nthToLast(ListNode head, int n) &#123; // write your code here ArrayList&lt;ListNode&gt; list=new ArrayList&lt;&gt;(); if (head!=null)&#123; list.add(head); &#125; else&#123; return head; &#125; while(head.next!=null)&#123; list.add(0,head.next); head=head.next; &#125; ListNode targetNode=list.get(n-1); return targetNode; &#125;&#125; 双向链表双向链表是每个数据结点都有两个指针，分别指向相邻的前驱结点和后继结点，可以方便的访问某个结点的前驱结点和后继结点，存储上会相对多占用一些空间。 代码实现 1 静态链表静态链表就是用数组来实现链式存储结构，所以它的长度是初始化的时候固定分配的定长。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197 public class StaticList &#123; public static void main(String[] args) &#123; run(); &#125; private static void run() &#123; StcList list = new StcList&lt;CharSequence&gt;(); System.out.println(&quot;顺序新增前：&quot;); list.printAll(); System.out.println(&quot;顺序新增后：&quot;); list.add(&quot;A&quot;); list.add(&quot;B&quot;); list.add(&quot;C&quot;); list.add(&quot;E&quot;); list.insert(&quot;D&quot;, 3); list.delete(2); list.printAll(); &#125; //存储结构 public static class StaticListNode&lt;E&gt; &#123; private E data; private int cursor; public StaticListNode(E data, int cursor) &#123; this.data = data; this.cursor = cursor; &#125; public E getData() &#123; return data; &#125; public void setData(E data) &#123; this.data = data; &#125; public int getCursor() &#123; return cursor; &#125; public void setCursor(int cursor) &#123; this.cursor = cursor; &#125; &#125; static class StcList&lt;E&gt; &#123; private static final int MAX_SIZE = 10; StaticListNode&lt;E&gt;[] nodes = new StaticListNode[MAX_SIZE]; public StcList() &#123; initList(nodes, nodes.length); &#125; //初始化备用链表 private void initList(StaticListNode[] nodes, int maxSize) &#123; for (int i = 0; i &lt; maxSize; i++) &#123; nodes[i] = new StaticListNode(null, i + 1); &#125; //将最后一个数据元素的游标指向第一个有值元素 nodes[maxSize - 1] = new StaticListNode(null, 0); &#125; public void printAll() &#123; for (int i = 0; i &lt; nodes.length; i++) &#123; System.out.print(nodes[i].getCursor()); System.out.print(&quot;:&quot;); System.out.print(nodes[i].getData()); System.out.print(&quot;:&quot;); System.out.print(i); System.out.print(&quot;|&quot;); &#125; System.out.println(); &#125; /** * 查找当前备用链表的头的 */ private void findHead() &#123; &#125; /** * 分配空间 分配空间的元素下标 * * @return 0分配失败 */ private int mallocArry() &#123; int index = 0; if (nodes[0].cursor &gt; 0) &#123; index = nodes[0].cursor; nodes[0].cursor = nodes[index].cursor; &#125; return index; &#125; //顺序新增元素 public boolean add(E e) &#123; if (e == null) &#123; System.out.println(&quot;新增失败&quot;); return false; &#125; //不等于零说明链表容量没用完，可以新增 int currentIndex = nodes[0].getCursor(); if (currentIndex &gt; 0) &#123; //当前空元素下标 nodes[currentIndex].setData(e); nodes[0].setCursor(nodes[currentIndex].getCursor());// nodes[currentIndex].setCursor(0); return true; &#125; System.out.println(&quot;新增失败&quot;); return false; &#125; /** * @param e 要插入的数据 * @param index 表示要插入的链中的位置 * @return true插入成功 */ //新增元素 public boolean insert(E e, int index) &#123; if (e == null || index &lt; 0 || index &gt; MAX_SIZE - 1) &#123; System.out.println(&quot;插入元素失败&quot;); return false; &#125; //不等于零说明链表容量没用完，可以新增 int currentIndex = nodes[0].getCursor(); if (currentIndex &gt; 0) &#123; //查找对应的位置 int k = 1; for (int i = 0; i &lt; index - 1; i++) &#123; k = nodes[k].cursor; &#125; //要插入位置记录的游标 int insertCursor = nodes[k].getCursor(); //申请分配的空间的下标 int i = mallocArry(); //插入位置的游标连接到新插入元素 nodes[k].setCursor(i); //新插入元素的游标连接之前插入位置记录的游标 nodes[i].cursor = insertCursor; nodes[i].data = e; return true; &#125; System.out.println(&quot;插入元素失败&quot;); return false; &#125; public boolean delete(int index) &#123; //不等于零说明链表容量没用完，可以新增 int currentEmptyIndex = nodes[0].getCursor(); if (currentEmptyIndex &gt; 0) &#123; //查找前一个的位置 int k = 1; for (int i = 1; i &lt; index - 1; i++) &#123; k = nodes[k].cursor; &#125; int currentIndex = nodes[k].cursor; int nextIndex = nodes[currentIndex].cursor; nodes[k].cursor = nextIndex; //将删除的结点连接到备用链表 free(currentIndex); return true; &#125; else &#123; System.out.println(&quot;删除元素失败&quot;); return false; &#125; &#125; private void free(int i) &#123; nodes[i].cursor=nodes[0].cursor; nodes[0].cursor=i; nodes[i].data = null; &#125; &#125;&#125; 循环链表 有环 循环链表的特点是最后一个结点的指针指向头结点，使整个链表形成环。 空链的判断条件：head==head-&gt;next;rear==rear-&gt;next; 约瑟夫问题 问题描述：N个人围成一个圈，从第一个开始报数，第M个人将被杀掉，最后只剩一个，其他都被杀掉。 循环链表的实现方式就是通过遍历元素，指针移动M位删除该元素，知道剩余一个元素。数学推导方式是发现最终获胜的元素下标是在每一轮“杀人”过程中移动M位从而得到公式：f(N,M)=(f(N−1,M)+M)。 代码实现： 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int n, m, i, winner = 0; printf (&quot;N M = &quot;); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (i = 2; i &lt;= n; i++) &#123; //i是每阶约瑟夫环的人数 winner = (winner + m) % i; &#125; //编号是从零开始，这里加1变成符合习惯的计数 printf (&quot;\\nThe winner is %d\\n&quot;, (winner +1)); &#125; 魔术师发牌问题 问题描述：魔术师手中有A到K十三张黑桃扑克牌，表演前魔术师已经按照一定的顺序叠放好，表演过程：开始，魔术师数1将最上面的那张翻过来，是黑桃A，将其放在桌面上；第二次，魔术师数1、2，将第一张牌放在所有牌最下面，将第二张牌翻转过来，第二张牌正好是黑桃2；第三次，魔术师数1、2、3，将第一、二张牌按照顺序放在所有牌最下面，将第三张牌翻转过来，第三张牌正好是黑桃3；…知道所有牌都翻转过来，顺序刚好是A、2、3…K，现在要知道魔术师在翻牌前叠放的13张牌的顺序。 代码实现 1 拉丁方阵问题 问题描述：拉丁方阵是一种n×n的方阵，方阵中恰有n种不同的元素，每种元素恰有n个，并且每种元素在一行和一列中 恰好出现一次。 特点：每一行除了开始的数递进一位外，其余的数都是按照顺序排列，递进的数排在后面，因此使用循环链表解决。 代码实现 1","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"时间复杂度和空间复杂度","slug":"时间复杂度和空间复杂度","date":"2020-04-07T13:24:37.000Z","updated":"2020-05-16T10:50:05.448Z","comments":true,"path":"2020/04/07/时间复杂度和空间复杂度/","link":"","permalink":"/2020/04/07/时间复杂度和空间复杂度/","excerpt":"","text":"时间复杂度：执行算法所需要的时间 空间复杂度：执行算法所需要的内存空间 时间复杂度的定义：一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得T(n)/f(n)的极限值（当n趋近于无穷大时）为不等于零的常数，则称f(n)是T(n)的同数量级函数 通常将O(1)、O(n)、O(logn)、O(n2)等分别叫做常量阶、线性阶、对数阶、平方阶等 推导大O阶方法：1.用常数1取代运行时间中的所有加法常数；2.修改后的运行次数函数中，值保留最高阶项；3.如果最高阶向存在且不是1，则去除与这个项相乘的常数 常数阶O(1)： 123int sum=0，n=100；sum=（1+n）*n/2;System.out.println(sum); 线性阶O(n): 123for(int i=0;i&lt;n;i++)&#123;//O(1)的算法&#125; 对数阶O(logn): 12345int num=1;while(num&lt;n)&#123;num=num*2;//O(1)的算法&#125; 平方阶O(n^2): 12345for(int i=0;i&lt;n;i++)&#123; for(int j=i;j++)&#123; //O(1)的算法 &#125;&#125; 常用的时间复杂度按照耗费的时间从小到大依次是： O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"面试积累","slug":"面试积累","date":"2020-02-05T06:20:52.000Z","updated":"2020-07-19T14:33:56.388Z","comments":true,"path":"2020/02/05/面试积累/","link":"","permalink":"/2020/02/05/面试积累/","excerpt":"","text":"要求： 薪酬结构 五险一金（全额，非全额要在基础薪资上调整） 技术团队规模 上下班时间 单双休 加班情况 人员配置 发版频率 绩效 年终奖 其他福利 餐补 车补贴 房补贴 项目经验：遇到了什么困难怎么解决的 直播 做了两方面的隔离，一是与其他业务模块的解耦 利用中间控制层 直播模块提供出对其他业务场景的依赖需求 其他业务模块提供这些能力给直播；二是把直播内部分为业务表现层和三方依赖层 具体做法是把三方直播依赖沉淀到baseview 把业务层需要的能力通过统一能力管理输出 （主要是直播画面能力控制和自定义消息协议的控制） 首页 动画控件 级联viewtab java基础： 同步锁同步锁的原理： 线程和进程 位运算常见十进制D、二进制B、八进制Q和十六进制H（逢几进1）n十进制向n进制转化：十进制转化为n进制时 十进制数一直除以n得余数 到一直不能整除为止，小数点部分是将小数部分乘以n 取整 然后小数部分继续乘以n 取整部分倒叙排序就是小数部分的值二进制转n进制：采用r（二进制和n进制之间的位数差 例如八进制是3合1、十六进制时4合1，如果是32进制就是 5合1）合1的方式，如果位数不够r位，整数部分向左补零，小数部分向右补零，然后按照案权展开相加即可得 线程安全 进程保活 HashMap原理 HashTable 序列化 泛性-类型擦除 数据结构与算法： 时间复杂度、空间复杂度 手写快排手写归并排序手写堆以及堆排序说一下排序算法的区别(时间复杂度和空间复杂度) 网络： tcp的三次握手和四次挥手：第一次：c端发送连接请求 序列号seq=x SYN创建连接状态第二次：b端收到信息后 发送确认码ack=x+1 SYN=1第三次：c端收到后 http2.0 Android下网络优化方案 QUIC协议 Android基础：pt px dpandroid sdkJNI framework安卓系统架构安全机制（网络安全 本地数据安全 apk代码安全）Java内存管理LRUCahe DiskLRUCaheRecyclerView 和ListView 三方库： eventbus原理利用反射触发事件函数的执行关键的一个键值对来存储数据 key是eventType（传递的时事件类型）线程模式 posting：处理函数看post在线程就在什么线程执行main：处理函数在主线程执行background：处理函数在子线程 post如果在主线程辉创建子线程 如果在子线程就直接在子线程触发处理async：新建子线程触发处理函数的执行 butterknife原理 okhttp rxjava retrofit Glide Fresco 三级缓冲 其他：对称加密和非对称加密工作中解决了什么难题，做了什么有成就感的项目（这个问题一定会问到，所以肯定要做准备）","categories":[{"name":"其他","slug":"其他","permalink":"/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"/tags/其他/"}]},{"title":"Android数据的持久化","slug":"Android数据的持久化","date":"2018-06-28T07:28:40.000Z","updated":"2020-05-07T11:08:53.408Z","comments":true,"path":"2018/06/28/Android数据的持久化/","link":"","permalink":"/2018/06/28/Android数据的持久化/","excerpt":"常见的存储的方式为SQlite数据存储、xml存储以及自定义数据格式的存储方式","text":"常见的存储的方式为SQlite数据存储、xml存储以及自定义数据格式的存储方式","categories":[{"name":"数据存储","slug":"数据存储","permalink":"/categories/数据存储/"}],"tags":[{"name":"Android 存储","slug":"Android-存储","permalink":"/tags/Android-存储/"}]},{"title":"android 中gradle依赖冲突解决","slug":"android-中gradle依赖冲突解决","date":"2017-11-24T07:00:34.000Z","updated":"2020-05-07T11:08:30.756Z","comments":true,"path":"2017/11/24/android-中gradle依赖冲突解决/","link":"","permalink":"/2017/11/24/android-中gradle依赖冲突解决/","excerpt":"","text":"android项目开发中经常会遇到库依赖异常，大多是版本依赖的冲突问题，说明下常见的版本依赖冲突解决方式 首页看下我们项目的依赖关系1./gradlew dependencies :app:dependencies :app表示依赖modulemac下运行可能人别不了命令行，运行+x gradlew ```添加权限1234567可以看到依赖结构是树状结构，各库下又依赖了android的官方提供的一些库，如果依赖的库不是太多的话，可以使用transitive参数，使得依赖库所需的依赖不直接使用，在依赖库的module中同一级上做依赖关系``` implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; compile (&apos;com.alibaba.android:vlayout:1.2.2@aar&apos;) &#123; transitive = false &#125; transitive为false表示单独依赖，true为默认树状依赖 这种解决方式只用于当前的依赖包只是版本导致的，且版本变动不大，起码它的代码package路径一致，如果差异很大可以指定依赖关系中特定包不包含到依赖中1234implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; compile (&apos;com.alibaba.android:vlayout:1.2.2@aar&apos;) &#123; exclude group: &apos;support-v4&apos; &#125;","categories":[],"tags":[{"name":"gradle","slug":"gradle","permalink":"/tags/gradle/"}]},{"title":"git基础知识","slug":"git基础知识","date":"2017-11-07T02:53:40.000Z","updated":"2020-09-28T02:33:13.548Z","comments":true,"path":"2017/11/07/git基础知识/","link":"","permalink":"/2017/11/07/git基础知识/","excerpt":"","text":"git基础知识——创建新的ssh key ssh-keygen -t rsa -C \"793021170@qq.com\"```1234------测试 ssh 链接 github```$ ssh -T git@git.oschina.net ——设置用户名、邮箱 git config --global user.name \"litchi\"```1```$ git config --global user.email &quot;793021170@qq.com&quot; ——提交到远程服务器 git remote add origin ssh://git@dev.lemote.com/rt4ls.git```1```$ git push origin master ——-本地库中缺少md文件时git pull --rebase origin master```1234567-------由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令```$ git push -u origin master ——-关联远程库git remote add origin git@server-name:path/repo-name.git```123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178git checkout master //进入master分支git checkout -b frommaster //以master为源创建分支frommastergit show # 显示某次提交的内容 git show $idgit co -- &lt;file&gt; # 抛弃工作区修改git co . # 抛弃工作区修改git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci &lt;file&gt; git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci -am &quot;some comments&quot;git ci --amend # 修改最后一次提交记录git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象git revert HEAD # 恢复最后一次提交的状态查看文件diffgit diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diffgit diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较git diff --staged # 比较暂存区和版本库差异git diff --cached # 比较暂存区和版本库差异git diff --stat # 仅仅比较统计信息查看提交记录git log git log &lt;file&gt; # 查看该文件每次提交记录git log -p &lt;file&gt; # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log --stat #查看提交统计信息tigMac上可以使用tig代替diff和log，brew install tigGit 本地分支管理查看、切换、创建和删除分支git br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br --merged # 查看已经被合并到当前分支的分支git br --no-merged # 查看尚未被合并到当前分支的分支git co &lt;branch&gt; # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d &lt;branch&gt; # 删除某个分支git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebasegit merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; Git补丁管理(方便在多台机器上开发同步时用)git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch # 打补丁git apply --check ../sync.patch #测试补丁能否成功 Git暂存管理git stash save “ ” # 暂存git stash list # 列所有stashgit stash apply stash@&#123;$num&#125; # 恢复暂存的内容git stash drop stash@&#123;$num&#125; # 删除暂存区Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支Git远程仓库管理GitHubgit remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm &lt;repository&gt; # 删除远程仓库创建远程仓库git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支也可以命令设置跟踪远程库和本地库git branch --set-upstream master origin/mastergit branch --set-upstream develop origin/develop--------显示command的help```git help &lt;command&gt; # 异常处理：1.如果出现remote origin already exists.需要删除远程库后在执行git remote add origin 具体执行：git remote rm origin git remote add origin git@git.oschina.net:jichengliu/SilkMarke","categories":[],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}]},{"title":"设计模式之工厂模式","slug":"设计模式之工厂模式","date":"2017-11-06T03:10:35.000Z","updated":"2020-05-07T11:07:02.122Z","comments":true,"path":"2017/11/06/设计模式之工厂模式/","link":"","permalink":"/2017/11/06/设计模式之工厂模式/","excerpt":"","text":"设计模式之工厂模式前言最近在看设计模式相关的一些知识，看了一些感觉还是要做一些记录的，一方面用来记录当前情况下个人对设计模式的理解程度，使得这块知识更加深刻，另一方面也是方便把自己的一些拙见拿出来希望能够共同进步，得到众人的指正。 引入工厂模式应该说最常见的模式，看一些介绍模式的书里工厂模式基本都是第一个被提到的，它应用场景比较多，也容易被理解。它是名如其模式，先来分析下它的名字，“工厂”用来生产各种产品，我们可以直接通过工厂来获得需要的各种产品，而不需要来考虑其具体的实现，所谓的“工厂”就类似于“商店”，提供我们需要所需产品。那么“工厂”的产品是怎么样获得的呢，“工厂”会根据我们具体的需求来利用具体的“材料”来“生产”具体的产品，到这里来看图说话。 上图就是对上面文字的一个概括，这里先又了这个概念就OK了，下面深入到代码层面来说明。 代码实现这里用引入中最原始的提到的工厂、产品和消费者举例。例子在android studio中android项目中开发。 工厂、产品和消费者 创建一个工厂类(Factory),提供一个获得产品的方法 123456789101112131415161718192021222324public class Factory &#123; /** * 获得产品对象实例 * * @param clazz clazz * @param &lt;P extends BaseProduct&gt; p * @return p */ public static &lt;P extends BaseProduct&gt; P getProduct(Class&lt;P&gt; clazz) &#123; P p = null; try &#123; p = (P) Class.forName(clazz.getName()).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return p; &#125;&#125; 创建一个接口(IProduct)，商品类将实现produce()方法 12345public interface IProduct &#123; public BaseProduct produce();&#125; 分别创建商品类(BaseProduct、ProductOne、ProductTwo、ProductThree和ProductFour) 123456public abstract class BaseProduct implements IProduct &#123; public void makeBaseComponents() &#123; //制作基础组件 &#125;&#125; 123456789public class ProductOne extends BaseProduct implements IProduct &#123; @Override public BaseProduct produce() &#123; makeBaseComponents(); Log.d(\"ProductOne\", \"make ProductOne\"); return this; &#125;&#125; 123456789public class ProductTwo extends BaseProduct implements IProduct &#123; @Override public BaseProduct produce() &#123; makeBaseComponents(); Log.d(\"ProductTwo\", \"make ProductTwo\"); return this; &#125;&#125; 123456789public class ProductThree extends BaseProduct implements IProduct &#123; @Override public BaseProduct produce() &#123; makeBaseComponents(); Log.d(\"ProductThree\", \"make ProductThree\"); return this; &#125;&#125; 123456789public class ProductFour extends BaseProduct implements IProduct &#123; @Override public BaseProduct produce() &#123; makeBaseComponents(); Log.d(\"ProductFour\", \"make ProductFour\"); return this; &#125;&#125; 在MainActivity类中获得需要的商品类实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void onGetProduct(int productType) &#123; Class&lt;? extends BaseProduct&gt; clazz = null; switch (productType) &#123; case 1: clazz = ProductOne.class; break; case 2: clazz = ProductTwo.class; break; case 3: clazz = ProductThree.class; break; case 4: clazz = ProductFour.class; break; &#125; BaseProduct product = Factory.getProduct(clazz); Toast.makeText(this, product.produce(), Toast.LENGTH_LONG).show(); &#125; public void onGetProductThree(View view) &#123; onGetProduct(3); &#125; public void onGetProductTwo(View view) &#123; onGetProduct(2); &#125; public void onGetProductOne(View view) &#123; onGetProduct(1); &#125; public void onGetProductFour(View view) &#123; onGetProduct(4); &#125;&#125; 最终我们实现在activity中获得了产品的实例对象 github 为什么要用工厂模式在开发过程中常常会独立做一些模块供其他的开发者来用，这种情况下，其实对于其他的开发者来说要求在使用功能时尽量的简单、调用方便，他们不需要去了解里面的具体实现，只要简单调用就可以拿到对应的实例，这个时候对于工厂模式时一个可行的方案，当然在实际开发中可以会和其他的模式混用来达到效果，这个还要具问具析。对于我们可以在什么场景下利用工厂模式，这里列出一些它的利弊，以便在考虑使用时参考： 利: 多类型扩展好，如果新增了一种商品只要实现它的具体类和方法，即可根据类来获取其实例 具体实现是封闭的、不对外的 调用方便，可通过一个类型或者类名就可以获得具体实例 弊产品类创建方式单一，因为是通过类命来创建实例，这样创建不会像常见的直接new灵活不适合单一产品时使用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}]},{"title":"Markdown常用语法","slug":"Markdown常用语法","date":"2017-11-06T03:01:55.000Z","updated":"2017-11-07T04:49:11.000Z","comments":true,"path":"2017/11/06/Markdown常用语法/","link":"","permalink":"/2017/11/06/Markdown常用语法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"hexo command line","slug":"hexo-command-line","date":"2017-11-03T14:34:03.000Z","updated":"2020-02-05T06:21:38.195Z","comments":true,"path":"2017/11/03/hexo-command-line/","link":"","permalink":"/2017/11/03/hexo-command-line/","excerpt":"Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server","text":"Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"linux环境下jdk安装配置","slug":"linux环境下jdk安装配置","date":"2017-11-03T13:54:47.000Z","updated":"2017-11-03T14:46:49.000Z","comments":true,"path":"2017/11/03/linux环境下jdk安装配置/","link":"","permalink":"/2017/11/03/linux环境下jdk安装配置/","excerpt":"jdk下载 wget -O jdk-8u131-linux-x64.tar.gz jdk-8u131-linux-x64.tar.gzAuthParam=1499664230_984ba136862e0fd6281ac5bc2bee90e2 解压文件 tar xf jdk-8u131-linux-x64.tar.gz 创建要存放的目录并复制解压后的jdk文件到目录下","text":"jdk下载 wget -O jdk-8u131-linux-x64.tar.gz jdk-8u131-linux-x64.tar.gzAuthParam=1499664230_984ba136862e0fd6281ac5bc2bee90e2 解压文件 tar xf jdk-8u131-linux-x64.tar.gz 创建要存放的目录并复制解压后的jdk文件到目录下 修改配置文件，指向存放jdk的目录 cd etc(进入etc目录) vi profile（打开profile文件并修改环境变量 source profile（使文件生效) 测试 java -version 能够打印java 版本号信息就表示安装或升级成功","categories":[],"tags":[{"name":"java linux","slug":"java-linux","permalink":"/tags/java-linux/"}]},{"title":"linux环境下Jenkins搭建","slug":"linux环境下Jenkins搭建","date":"2017-11-03T13:46:06.000Z","updated":"2017-11-03T14:30:32.000Z","comments":true,"path":"2017/11/03/linux环境下Jenkins搭建/","link":"","permalink":"/2017/11/03/linux环境下Jenkins搭建/","excerpt":"安装java环境具体查看Linux java环境安装 安装tomcat从tomcat官网上下载最新的安装压缩包，注意区分选择不同操作环境下的压缩包.（Linux一般是 tar.gz，Windows一般用zip压缩包），选择对应的压缩包能保证系统可以直接解压，避免不支持时还需安转压缩工具。 下载压缩包 wget http://apache.fayea.com/tomcat/tomcat-8/v8.5.16/bin/apache-tomcat-8.5.16.tar.gz 解压压缩包 tar xf apache-tomcat-8.5.16.tar.gz 进入解压后的文件夹并将所有的复制到自己要安装的目录下 cd apache-tomcat-8.5.16 cp -rf ./* /usr/local/tomcat/","text":"安装java环境具体查看Linux java环境安装 安装tomcat从tomcat官网上下载最新的安装压缩包，注意区分选择不同操作环境下的压缩包.（Linux一般是 tar.gz，Windows一般用zip压缩包），选择对应的压缩包能保证系统可以直接解压，避免不支持时还需安转压缩工具。 下载压缩包 wget http://apache.fayea.com/tomcat/tomcat-8/v8.5.16/bin/apache-tomcat-8.5.16.tar.gz 解压压缩包 tar xf apache-tomcat-8.5.16.tar.gz 进入解压后的文件夹并将所有的复制到自己要安装的目录下 cd apache-tomcat-8.5.16 cp -rf ./* /usr/local/tomcat/ 安装SDK根据镜像下载sdk包即可，注意最新的sdk可能没有platform tools文件夹，可下在低版本的将platform tolls文件夹移动到最新的sdk文件夹下即可。 有一些插件也可以在没有sdk时自动在Jenkins搭建好后构建时自动下载sdk，如Android Emulator Plugin在配置好后它自己会根据配置参数自动去下载对应的sdk版本，这里后面会说到。 安装Jenkins从Jenkins官网下载并复制jenkins.war到tomcat目录下webapps下。 wget http://mirrors.jenkins.io/war/latest/jenkins.war cp ./jenkins.war /usr/local/tomcat/webapps 启动Tomcat在浏览器中打开http://网址:8080/jenkins/就可以打开Jenkins网页，接下来就可以创建项目，Jenkins玩起来了。 注： 如果要使用其他端口来使用Jenkins可以运行命令： java -jar jenkins.war --httpPort=端口号 java -jar jenkins.war --httpPort=8899 --daemon --logfile=日志路径/jenkins/jenkins.log(在后台运行) 在打开Jenkins网页前要保证对应的端口号可访问，aliyun要配置安全组，开放对应端口。","categories":[],"tags":[{"name":"Jenkins tomcat Linux","slug":"Jenkins-tomcat-Linux","permalink":"/tags/Jenkins-tomcat-Linux/"}]},{"title":"note","slug":"note","date":"2017-11-03T08:56:19.000Z","updated":"2017-12-04T03:24:38.104Z","comments":true,"path":"2017/11/03/note/","link":"","permalink":"/2017/11/03/note/","excerpt":"","text":"hexo官方教程地址http:https://hexo.io/zh-cn/ markdown 教程http:http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-8/","categories":[],"tags":[]},{"title":"Jenkins参数化构建android项目","slug":"Jenkins参数化构建android项目","date":"2017-11-03T01:59:37.000Z","updated":"2017-11-03T15:28:17.000Z","comments":true,"path":"2017/11/03/Jenkins参数化构建android项目/","link":"","permalink":"/2017/11/03/Jenkins参数化构建android项目/","excerpt":"达到的目标： 根据版本类型(release、beta or debug)、版本号、渠道、服务器请求地址等参数进行构建； 构建完成后显示相关构建信息； 展示apk下载二维码、下载地址供直接安装和下载apk 需要的插件： Dynamic Extended Choice Parameter plugin参数化选择需要 Description Setter Plugin构建的信息显示需要 GIt Plugingit 插件","text":"达到的目标： 根据版本类型(release、beta or debug)、版本号、渠道、服务器请求地址等参数进行构建； 构建完成后显示相关构建信息； 展示apk下载二维码、下载地址供直接安装和下载apk 需要的插件： Dynamic Extended Choice Parameter plugin参数化选择需要 Description Setter Plugin构建的信息显示需要 GIt Plugingit 插件 配置项目参数： 设置构建类型参数： 在general模块中复选‘参数化构建过程’，‘添加参数‘中选择’Choice Parameter‘; Name添加参数名，按照Jenkins已有的默认参数集来定义都以大写字母和下划线组成，例：ENVIRONMENT_BUILD，Choices输入item的选项，第一项会变成默认项。 设置列表型参数渠道、版本号、服务器请求地址等： 列表型参数和构建类型一样，设置name、Choices和Description。 配置git参数： 这里首先要保证我们的代码在每个版本都有独立的版本分支，通过不同的版本名来拉取对应的代码，来实现分版本构建。 配置构建命令参数： Tasks输入框输入构建命令行 clean assemble${PRODUCT_FLAVOR_BUILD}${ENVIRONMENT_BUILD}，${参数}表示参数应用，‘PRODUCT_FLAVOR_BUILD’是自定义的参数用来表示构建渠道，‘ENVIRONMENT_BUILD’表示构建类型。 配置构建后描述参数： 在‘构建’模块‘增加构建步骤’列表中选择‘set build description’，在Description输入框输入html代码，例如下，其中的‘${参数}’表示自定义的一些参数，用‘${参数}’来取对应的值。 请求环境：${JENKINS_SERVER_HOST}构建类型：${ENVIRONMENT_BUILD}构建渠道：${PRODUCT_FLAVOR_BUILD}构建版本：${APP_BUILD_VERSION}点击查看二维码点击下载apk 注：如果在构建完后显示还是按照文本显示的，修改一下系统管理／安全配置中‘Markup Formatter‘选择为Safe HTML，来支持html。 配置效果：","categories":[],"tags":[{"name":"Jenkins Android","slug":"Jenkins-Android","permalink":"/tags/Jenkins-Android/"}]}]}