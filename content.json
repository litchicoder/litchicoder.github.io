{"meta":{"title":"litchi","subtitle":"litchi blog","description":null,"author":"litchi","url":""},"pages":[{"title":"about","date":"2017-11-07T06:59:32.000Z","updated":"2017-11-07T07:00:17.000Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"litchi"},{"title":"404","date":"2020-03-30T13:32:57.615Z","updated":"2017-11-03T08:52:38.000Z","comments":true,"path":"/404.html","permalink":"//404.html","excerpt":"","text":"页面找不到了，回看看吧！"}],"posts":[{"title":"类加载子系统","slug":"类加载子系统","date":"2020-04-26T11:16:43.000Z","updated":"2020-04-26T12:57:01.516Z","comments":true,"path":"2020/04/26/类加载子系统/","link":"","permalink":"/2020/04/26/类加载子系统/","excerpt":"","text":"类加载过程包括加载（load）、链接（linking）和初始化（init） 加载将字节码文件从数据源中加载到JVM内存中，生成JVM的认可的数据结构（也就是Class对象），数据源可以是来自物理硬盘或者网络的jar文件、war文件、class文件等一些JVM可识别的文件格式结构（文件格式异常回报ClassFormatError）。 链接链接是类加载的核心部分，分三个步骤：验证、准备和解析1.验证（Verify）：保证字节流信息符合JVM规范，避免恶意数据危害JVM的安全运行（异常抛出VerifyError）。2.准备（Prepare）：为类变量分配内存和为变量设置初始值。3.解析（Resolve）：将符号应用转换为直接应用，符号应用就是一组符号来描述所应用的目标，直接应用就是直接指向目标的指针或句柄。 初始化初始化主要是将静态变量赋值和执行静态代码块的一系列操作。 双亲委派机制 双亲委派机制是在类加载过程中加载部分里的机制，加载器大致有启动类加载器（加载核心的类）、扩展类加载器（ext path下的类）和应用类加载器（自定义）。在执行类加载请求时，子加载器会先委托父类加载器执行；如果父类加载器还存在父类加载器就继续委托，一次递归找到其顶部启动类加载器；如果启动类加载器可以完成任务则将结果返回，倘若启动类加载器不能完成任务这时一次再让子类加载器尝试加载，这个过程叫双亲委派机制。 双亲委派机制优点1.避免类重复加载2.保护程序安全，防止核心API被篡改（java.lang.String）","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"}]},{"title":"查找算法","slug":"查找算法","date":"2020-04-21T07:00:09.000Z","updated":"2020-04-21T07:05:50.788Z","comments":true,"path":"2020/04/21/查找算法/","link":"","permalink":"/2020/04/21/查找算法/","excerpt":"","text":"插值查找 黄金分割法 线性索引查找 二叉排序树 平衡二叉树 B树 散列表（哈希表）查找*","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"图","slug":"图","date":"2020-04-17T07:10:34.000Z","updated":"2020-04-21T06:54:37.309Z","comments":true,"path":"2020/04/17/图/","link":"","permalink":"/2020/04/17/图/","excerpt":"","text":"图的特点：1.通常用V(Vertex)表示一组定点的集合；2.通常用E(Edge)表示一组边的集合。 顶点：图中的一个结点 图的边：顶点和顶点间的连线，有向图中的边叫做弧 相邻顶点：由一条边连接在一起的顶点 顶点的度：相邻顶点的数量叫做顶点的度 连通图：在无向图中，若任意两个顶点Vi与Vj都有路径相通，则称该无向图为连通图 强连通图：在有向图中，若任意两个顶点Vi与Vj都有路径相通，则称该有向图为强连通图 连通网：在连通图中，若图的边具有一定的意义，每一条边都有一个对应数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网 生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则会形成环 图的深度优先遍历：假设初始状态是图中所有顶点都未被访问，从图中某个顶点v出发，先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到；若此时还有剩余顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 图的广度优先遍历：假设从图中某个顶点v出发，在访问了顶点v之后依次访问顶点v的各个未曾访问过的邻接顶点，然后分别从这些邻接顶点再出发依次访问它们的邻接顶点，并使“先被访问的顶点的邻接顶点”先于“后被访问的顶点的邻接顶点”被访问，直到图中所有已被访问的顶点的邻接点都被访问到；若此时图中还有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 最小生成树：在连通网的所有生成树中，所有边的代价总和最小的生成树，称为最小生成树 1.普里姆算法(Prim算法)： 描述：1.定义一个加权连通图，其中顶点集合V、Vnew，Vnew是V的子集，边的集合E、Enew，Enew是E的子集；2.初始化集合Vnew{x},x(起始点)是集合V中任意一结点，Enew{}；3.从边的集合E中选取权值最小的边&lt;u, v&gt;(其中u是顶点集合Vnew的元素，v属于顶点集合V，而不在新顶点集合Vnew中。若权值相同时，任意取值)；4.将v加入新顶点集合Vnew，将边&lt;u, v&gt;加入新边集合Enew中；5.重复操作3和4步骤 ，知道Vnew=V时，输出集合Vnew和Enew，Vnew和Enew即是来描述该加权连通图的最小生成树。代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149 static class GraphMatrix &#123; /** * 边的数量 */ private int edgeNum; /** * 顶点集合 */ private char[] vertex; /** * 邻接矩阵 */ private int[][] matrix; public GraphMatrix(char[] vertex, int[][] matrix) &#123; this.vertex = vertex; this.matrix = matrix; getEdgeNum(); &#125; private void getEdgeNum() &#123; int length = vertex.length; for (int i = 0; i &lt; length; i++) &#123; for (int j = i + 1; j &lt; length; j++) &#123; //矩阵值等于Integer.MAX_VALUE表示不相邻，等于0是自己到自己 if (matrix[i][j] != Integer.MAX_VALUE) &#123; edgeNum++; &#125; &#125; &#125; &#125; /** * print matrix */ private void printMatrix() &#123; System.out.println(&quot;矩阵:&quot;); for (int[] m : matrix) &#123; for (int c : m) &#123; System.out.print(c + &quot; &quot;); &#125; System.out.println(); &#125; &#125; /** * 获取字符在结点里的位置 * * @param c 字符 * @return 返回-1没该字符，其他位置 */ private int getVertexPosition(char c) &#123; for (int i = 0; i &lt; vertex.length; i++) &#123; if (c == vertex[i]) &#123; return i; &#125; &#125; return -1; &#125; /** * 输入开始顶点位置 * * @param x 开始顶点位置 */ public void prime(int x) &#123; int num = vertex.length; //邻边权重 int[] weights = new int[num]; //prime最小生成树结果 char[] result = new char[num]; //result当前索引 int index = 0; //复制第一个顶点值 result[index] = vertex[x]; index++; //init weight 找到顶点相邻边的权重赋值weights[i] for (int i = 0; i &lt; num; i++) &#123; weights[i] = matrix[x][i]; &#125; weights[x] = 0; //循环遍历娶到最短权重值添加到result中 for (int i = 0; i &lt; num; i++) &#123; if (x == i) &#123; continue; &#125; int minWeight = Integer.MAX_VALUE; int minWeightIndex = 0; for (int j = 0; j &lt; num; j++) &#123; if (weights[j] != 0 &amp;&amp; weights[j] &lt; minWeight) &#123; minWeight = weights[j]; minWeightIndex = j; &#125; &#125; //保存最短权重顶点 result[index] = vertex[minWeightIndex]; index++; weights[minWeightIndex] = 0; for (int j = 0; j &lt; num; j++) &#123; if (weights[j] != 0 &amp;&amp; matrix[minWeightIndex][j] &lt; weights[j]) &#123; weights[j] = matrix[minWeightIndex][j]; &#125; &#125; &#125; //计算最小生成树的权重 int sum = 0; for (int i = 1; i &lt; index; i++) &#123; int min = Integer.MAX_VALUE; int n = getVertexPosition(result[i]); //求当前节点到上面其他节点的最小值 for (int j = 0; j &lt; i; j++) &#123; int m = getVertexPosition(result[j]); if (matrix[m][n] &lt; min) &#123; min = matrix[m][n]; &#125; &#125; sum += min; &#125; //打印最小生成树 System.out.printf(&quot;PRIME(%c):&quot;, vertex[x]); for (int i = 0; i &lt; index; i++) &#123; System.out.printf(&quot;%c &quot;, result[i]); &#125; System.out.println(); System.out.printf(&quot;权重：%d&quot;, sum); &#125; &#125;``` 2.克鲁斯卡尔算法(Kruskal算法)：描述： 首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。 代码实现： /** * 克鲁斯卡尔算法 */ public void Kruskal() { //结果数组的当前索引 int index = 0; //输出的结果数组 Edge[] results = new Edge[edgeNum]; //保存某个顶点在该最小生成树的终点 int[] vends = new int[edgeNum]; //获取图中所有的边 Edge[] edges = getEdges(); //将边按权重从小到大排序 sortEdges(edges); for (int i = 0; i &lt; edgeNum; i++) { int p1 = getVertexPosition(edges[i].start); int p2 = getVertexPosition(edges[i].end); int m = getEdgesEnd(vends, p1); int n = getEdgesEnd(vends, p2); if (m != n) {//表示没有形成闭环 vends[m] = n; results[index++] = edges[i]; } } //统计并打印最小生成树的信息 int length = 0; for (int i = 0; i &lt; index; i++) { length += results[i].weight; } System.out.println(&quot;Kruskal：&quot;); for (int i = 0; i &lt; index; i++) { System.out.printf(&quot;(%c,%c) &quot;, results[i].start, results[i].end); } System.out.println(); System.out.println(&quot;Kruskal的权重：&quot; + length); } //连通图的边结构 private static class Edge { char start;//边的起点 char end;//边的终点 int weight;//边的权重 public Edge(char start, char end, int weight) { this.start = start; this.end = end; this.weight = weight; } } /** * 获取图中的边 */ private Edge[] getEdges() { int index = 0; Edge[] edges = new Edge[edgeNum]; for (int i = 0; i &lt; vertex.length; i++) { for (int j = i + 1; j &lt; vertex.length; j++) { if (matrix[i][j] != Integer.MAX_VALUE) { edges[index++] = new Edge(vertex[i], vertex[j], matrix[i][j]); } } } return edges; } /** * 根据权重从小到大排序 * * @param edges edges */ private void sortEdges(Edge[] edges) { Edge tmp; for (int i = 0; i &lt; edges.length; i++) { for (int j = (i + 1); j &lt; edges.length; j++) { if (edges[i].weight &gt; edges[j].weight) {//若大于则交换位置 tmp = edges[i]; edges[i] = edges[j]; edges[j] = tmp; } } } } /** * 取终点 */ private int getEdgesEnd(int[] vends, int i) { //若C-&gt;D,D-&gt;F则取F的值 while (vends[i] != 0) { i = vends[i]; } return i; } ` 最短路径：","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"树","slug":"树","date":"2020-04-14T14:12:59.000Z","updated":"2020-04-16T12:51:44.691Z","comments":true,"path":"2020/04/14/树/","link":"","permalink":"/2020/04/14/树/","excerpt":"","text":"树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。 特点： 1.在非空树中，根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点；2.子树的个数没有限制，但它们互不相交； 度： 结点的度：结点拥有的子树个数叫做结点的度，结点A的度是3，C的度是2，H的度是1。树的度：树中最大的结点度。图中树的度是3 结点的关系 1.结点子树的根结点称为该结点的 孩子结点，该结点叫做孩子结点的双亲结点。图中E是B的孩子结点，B是E的双亲结点；2.同一双亲的结点叫做兄弟结点，图中的F、G是E的兄弟结点；3.同一层的结点叫做堂兄结点，通中的H、I、J、K、L是E的堂兄结点；4.从根到该结点经过的左右分支结点叫做该结点的祖先结点，图中M的祖先结点有A、B、E。5.该结点的子树任意一个结点都称为该结点的子孙结点，E的子孙结点有M和N。 结点的层次 从根开始定义，根为第一层，根的孩子为第二层，根的孩子的孩子为第三层…。树的深度：树中结点的最大层次数称为树的深度或高度，图中深度为4 二叉树二叉树(Binary Tree)是n(n&gt;=0)个结点的有限集合，该集合或者为空集(空二叉树)，或者由一个跟结点和两个互补相交的、分别称为根的结点在左子树和右子树组成。每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。 二叉树的特点 1.每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点；2.左子树和右子树是有顺序的，次序不能任意颠倒；3.即使树中某结点只有一棵子树，也要区分它是左子树还是右子树； 二叉树的性质 1.在二叉树中第i层上最多有2的i-1次方个结点(i&gt;=1)；2.二叉树中如果深度为k,那么最多有2k-1个节点(k&gt;=1）； 斜树 所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。 满二叉树在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。满二叉树的特点有：1.叶子只能出现在最下一层。出现在其它层就不可能达成平衡。2.非叶子结点的度一定是2。3.在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。 完全二叉树若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。完全二叉树的特点：1.叶子结点只出现在最下层和次下层；2.最下层叶子结点集中在树的左部；3.如果结点度为1，则该结点只有左孩子，即没有右子树；4.相同结点数的二叉树，完全二叉树的深度最小；5.满二叉树一定是完全二叉树，但反过来不一定成立。 二叉树存储结构 1.*** 顺序存储结构二叉树的顺序存储结构就是使用一维数组存储二叉树中的结点，并且结点的存储位置，就是数组的下标索引。 如果索引下为空表示该位置下没有存储结点。 2.*** 链式存储结构 结构定义 12345678class BinaryNode&lt;E&gt; &#123; //数据 E data; //左子树 BinaryNode leftChild; //右子树 BinaryNode rightChild;&#125; 二叉树的遍历 1.前序遍历(DLR)首先访问根，再先序遍历左（右）子树，最后先序遍历右（左）子树图中结果：ABDECFG 12345678910111213141516171819/** * 前序遍历 * * @param root 根 */ public void DLR(BinaryNode root) &#123; if (root == null) &#123; return; &#125; //TODO do something if (root.leftChild != null) &#123; DLR(root.leftChild); &#125; if (root.rightChild != null) &#123; DLR(root.rightChild); &#125; &#125; 2.中序遍历(LDR)首先中序遍历左（右）子树，再访问根，最后中序遍历右（左）子树。图中结果：DBEAFCG 12345678910111213141516171819/** * 中序遍历 * * @param root 根 */ public void LDR(BinaryNode root) &#123; if (root == null) &#123; return; &#125; if (root.leftChild != null) &#123; LDR(root.leftChild); &#125; //TODO do something if (root.rightChild != null) &#123; LDR(root.rightChild); &#125; &#125; 3.后序遍历(LRD)首先后序遍历左（右）子树，再后序遍历右（左）子树，最后访问根图中结果：DEBFGA 12345678910111213141516171819/** * 后序遍历 * * @param root 根 */ public void LRD(BinaryNode root) &#123; if (root == null) &#123; return; &#125; if (root.leftChild != null) &#123; LRD(root.leftChild); &#125; if (root.rightChild != null) &#123; LRD(root.rightChild); &#125; //TODO do something &#125; 4.层序遍历按照层次访问，通常用队列来做。访问根，访问子女，再访问子女的子女 线索二叉树 二叉树线索化的过程中，会把树中的空指针利用起来作为寻找当前节点前驱和后继的线索，这样就出现了一个问题，即线索和数中原有指向孩子节点的指针无法区分。上边的这种节点设计就是为了区分这两类指针。其中，ltag和rtag为标识域，它们的具体意义如下:1.如果ltag==0，表示lchild为指针，指向结点的左子树；2.如果ltag==1，表示lchild为线索，指向结点的直接前驱;3.如果rtag==0，表示rchild为指针，指向结点的右子树；4.如果rtag==1，表示rchild为线索，指向结点的直接后继。 哈夫曼树 当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"字符串匹配算法","slug":"字符串匹配算法","date":"2020-04-14T06:49:35.000Z","updated":"2020-04-14T14:10:29.663Z","comments":true,"path":"2020/04/14/字符串匹配算法/","link":"","permalink":"/2020/04/14/字符串匹配算法/","excerpt":"","text":"BF算法首先原串与字串左端对齐，，如果第一个字符不匹配，字串向后移动逐一移动，当发现死一个第一个字符匹配后，当前位置下比较剩余字串的字符与原串是否匹配，直到全部匹配。 1234567对齐:litchicodercoder逐一移动 找到匹配字符:litchicoder coder 代码实现： 12345678910111213141516171819202122232425262728293031323334class BF &#123; public static void main(String[] args) &#123; int r = queryByBF(&quot;HelloWord&quot;, &quot;Word&quot;); System.out.print(r == 0 ? &quot;字符串匹配失败&quot; : &quot;子字符串在原串的位置：&quot; + r); &#125; /** * @param s 原字符串 * @param t 需要匹配的子字符串位置 */ public static int queryByBF(String s, String t) &#123; char[] a = s.toCharArray(); char[] b = t.toCharArray(); int i = 0, j = 0; while (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123; //比较字符 if (a[i] == b[j]) &#123; i++; j++; &#125; else &#123; //i后退重新匹配 i++; j = 0; &#125; &#125; if (j &gt;= t.length()) &#123; return i - t.length(); &#125; else &#123; //匹配失败 return 0; &#125; &#125;&#125; KMP算法KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"递归和分治","slug":"递归和分治","date":"2020-04-14T05:19:33.000Z","updated":"2020-04-14T06:43:14.130Z","comments":true,"path":"2020/04/14/递归和分治/","link":"","permalink":"/2020/04/14/递归和分治/","excerpt":"","text":"递归高级语言中，函数自己调用和调用其他函数并没有本质的不同，我们把一个直接调用自己或者通过一系列调用语句间接地调用自己的函数，称作递归函数。（ps：每个递归定义必须至少有一个条件，当满足这个条件时递归不再进行，即函数不再调用自身而是返回值） 斐波那契(Fibonacci)数列如果说兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔子都不会死去，能够一直干下去，那么一年以后可以繁殖多少对兔子呢？ 代码实现： 123456int Fib(int i)&#123; if( i &lt; 2 ) return i == 0 ? 0 : 1; return Fib(i-1) + Fib(i-2);&#125; 分治在遥远的周朝，人们受生产力水平所限，无法管理庞大的土地和众多的人民，因此采用了封邦建国的封建制度，把土地一层一层划分下去，以达到分而治之的目的，这也许是最古老的分治法了： 汉诺塔问题汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。 12345678910111213141516171819202122232425262728293031public class Hanoi &#123; /** * * @param n 盘子的个数 * @param a 原来的柱子 * @param b 中间辅助柱子 * @param c 最终到达的目标珠子 */ public void hanoi(int n, char a, char b, char c) &#123; if (n == 1) &#123; move(a, c); &#125; else &#123; //将n-1个盘子从a利用c移动到b盘子 hanoi(n - 1, a, c, b); //将第n个盘子从a移动到c move(a, c); //将n-1个盘子从b利用a移动到c hanoi(n - 1, b, a, c); &#125; &#125; // 移动盘子 private void move(char origin, char target) &#123; System.out.println(&quot;方向:&quot; + origin + &quot;---&gt;&quot; + target); &#125; public static void main(String[] args) &#123; Hanoi hanoi = new Hanoi(); hanoi.hanoi(3, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;); &#125;&#125; 快速排序找出第n大的值直尺八皇后问题","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"栈和队列","slug":"栈和队列","date":"2020-04-13T03:53:45.000Z","updated":"2020-04-14T05:00:35.712Z","comments":true,"path":"2020/04/13/栈和队列/","link":"","permalink":"/2020/04/13/栈和队列/","excerpt":"","text":"栈：栈(Stack)是一个后进先出(Last in first out LIFO)的线性表，要求只在表尾进行删除和插入操作了，栈的插入叫做进栈（进栈、压栈、入栈）、栈的删除叫出栈。 队列：队列(queue)是只允许在一端进行插入操作，而另一端进行删除操作的一种先进先出(First in First out FIFo)的线性表1.循环队列： 123456789101112131415161718192021222324252627282930public class CircleQueue&lt;E&gt; &#123; private Object q[]; private int head = 0; private int tail = 0; private int size; public CircleQueue(int size) &#123; this.size = size; q = new Object[size]; &#125; public CircleQueue() &#123; this(10); &#125; public boolean inQueue(E e) &#123; //表示队列已经满了 if ((tail+1) % size == head) return false; q[tail] = e; tail = (tail + 1) % size; return true; &#125; public E outQueue() &#123; if (head == tail) return null; E o = (E) q[head]; head = (head + 1) % size; return o; &#125;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"线性表","slug":"线性表","date":"2020-04-08T12:49:40.000Z","updated":"2020-04-12T13:22:34.500Z","comments":true,"path":"2020/04/08/线性表/","link":"","permalink":"/2020/04/08/线性表/","excerpt":"","text":"线性表理解为将数据结点用一根“线”连接起来存储在物理空间，线性表的数据元素一般具有相同的数据类型。大部分线性表中除了第一个元素（没有前驱）和最后一个元素（没有后继）其他元素都有前驱和后继（也就是各元素之间是一对一的关系）。 顺序存储结构（顺序表） 顺序存储结构就是数据是用一块完整的物理空间来连续存储数据，一般它的大小是固定的。优点：物理空间利用率高，增查效率高。缺点：插入和删除效率低，每次都需要移动目标元素后面的所有数据元素，由于它的length是提前分配固定好不能扩容，会发生存储溢出。 链式存储结构链式存储结构中数据元素的存储方式在物理空间中是随机的，数据结点氛围数据域和指针域，数据域存储数据元素，指针域来关联起来数据结点形成链。链式存储结构一般有单链表、双向链表和循环链表。 单链表 题目：找到单链表倒数第n个节点，保证链表中节点的最少数量为n。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for ListNode. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; * &#125; */ public class Solution &#123; /* * @param head: The first node of linked list. * @param n: An integer * @return: Nth to last node of a singly linked list. */ public ListNode nthToLast(ListNode head, int n) &#123; // write your code here ArrayList&lt;ListNode&gt; list=new ArrayList&lt;&gt;(); if (head!=null)&#123; list.add(head); &#125; else&#123; return head; &#125; while(head.next!=null)&#123; list.add(0,head.next); head=head.next; &#125; ListNode targetNode=list.get(n-1); return targetNode; &#125;&#125; 双向链表双向链表是每个数据结点都有两个指针，分别指向相邻的前驱结点和后继结点，可以方便的访问某个结点的前驱结点和后继结点，存储上会相对多占用一些空间。 代码实现 1 静态链表静态链表就是用数组来实现链式存储结构，所以它的长度是初始化的时候固定分配的定长。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197 public class StaticList &#123; public static void main(String[] args) &#123; run(); &#125; private static void run() &#123; StcList list = new StcList&lt;CharSequence&gt;(); System.out.println(&quot;顺序新增前：&quot;); list.printAll(); System.out.println(&quot;顺序新增后：&quot;); list.add(&quot;A&quot;); list.add(&quot;B&quot;); list.add(&quot;C&quot;); list.add(&quot;E&quot;); list.insert(&quot;D&quot;, 3); list.delete(2); list.printAll(); &#125; //存储结构 public static class StaticListNode&lt;E&gt; &#123; private E data; private int cursor; public StaticListNode(E data, int cursor) &#123; this.data = data; this.cursor = cursor; &#125; public E getData() &#123; return data; &#125; public void setData(E data) &#123; this.data = data; &#125; public int getCursor() &#123; return cursor; &#125; public void setCursor(int cursor) &#123; this.cursor = cursor; &#125; &#125; static class StcList&lt;E&gt; &#123; private static final int MAX_SIZE = 10; StaticListNode&lt;E&gt;[] nodes = new StaticListNode[MAX_SIZE]; public StcList() &#123; initList(nodes, nodes.length); &#125; //初始化备用链表 private void initList(StaticListNode[] nodes, int maxSize) &#123; for (int i = 0; i &lt; maxSize; i++) &#123; nodes[i] = new StaticListNode(null, i + 1); &#125; //将最后一个数据元素的游标指向第一个有值元素 nodes[maxSize - 1] = new StaticListNode(null, 0); &#125; public void printAll() &#123; for (int i = 0; i &lt; nodes.length; i++) &#123; System.out.print(nodes[i].getCursor()); System.out.print(&quot;:&quot;); System.out.print(nodes[i].getData()); System.out.print(&quot;:&quot;); System.out.print(i); System.out.print(&quot;|&quot;); &#125; System.out.println(); &#125; /** * 查找当前备用链表的头的 */ private void findHead() &#123; &#125; /** * 分配空间 分配空间的元素下标 * * @return 0分配失败 */ private int mallocArry() &#123; int index = 0; if (nodes[0].cursor &gt; 0) &#123; index = nodes[0].cursor; nodes[0].cursor = nodes[index].cursor; &#125; return index; &#125; //顺序新增元素 public boolean add(E e) &#123; if (e == null) &#123; System.out.println(&quot;新增失败&quot;); return false; &#125; //不等于零说明链表容量没用完，可以新增 int currentIndex = nodes[0].getCursor(); if (currentIndex &gt; 0) &#123; //当前空元素下标 nodes[currentIndex].setData(e); nodes[0].setCursor(nodes[currentIndex].getCursor());// nodes[currentIndex].setCursor(0); return true; &#125; System.out.println(&quot;新增失败&quot;); return false; &#125; /** * @param e 要插入的数据 * @param index 表示要插入的链中的位置 * @return true插入成功 */ //新增元素 public boolean insert(E e, int index) &#123; if (e == null || index &lt; 0 || index &gt; MAX_SIZE - 1) &#123; System.out.println(&quot;插入元素失败&quot;); return false; &#125; //不等于零说明链表容量没用完，可以新增 int currentIndex = nodes[0].getCursor(); if (currentIndex &gt; 0) &#123; //查找对应的位置 int k = 1; for (int i = 0; i &lt; index - 1; i++) &#123; k = nodes[k].cursor; &#125; //要插入位置记录的游标 int insertCursor = nodes[k].getCursor(); //申请分配的空间的下标 int i = mallocArry(); //插入位置的游标连接到新插入元素 nodes[k].setCursor(i); //新插入元素的游标连接之前插入位置记录的游标 nodes[i].cursor = insertCursor; nodes[i].data = e; return true; &#125; System.out.println(&quot;插入元素失败&quot;); return false; &#125; public boolean delete(int index) &#123; //不等于零说明链表容量没用完，可以新增 int currentEmptyIndex = nodes[0].getCursor(); if (currentEmptyIndex &gt; 0) &#123; //查找前一个的位置 int k = 1; for (int i = 1; i &lt; index - 1; i++) &#123; k = nodes[k].cursor; &#125; int currentIndex = nodes[k].cursor; int nextIndex = nodes[currentIndex].cursor; nodes[k].cursor = nextIndex; //将删除的结点连接到备用链表 free(currentIndex); return true; &#125; else &#123; System.out.println(&quot;删除元素失败&quot;); return false; &#125; &#125; private void free(int i) &#123; nodes[i].cursor=nodes[0].cursor; nodes[0].cursor=i; nodes[i].data = null; &#125; &#125;&#125; 循环链表 有环 循环链表的特点是最后一个结点的指针指向头结点，使整个链表形成环。 空链的判断条件：head==head-&gt;next;rear==rear-&gt;next; 约瑟夫问题 问题描述：N个人围成一个圈，从第一个开始报数，第M个人将被杀掉，最后只剩一个，其他都被杀掉。 循环链表的实现方式就是通过遍历元素，指针移动M位删除该元素，知道剩余一个元素。数学推导方式是发现最终获胜的元素下标是在每一轮“杀人”过程中移动M位从而得到公式：f(N,M)=(f(N−1,M)+M)。 代码实现： 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int n, m, i, winner = 0; printf (&quot;N M = &quot;); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (i = 2; i &lt;= n; i++) &#123; //i是每阶约瑟夫环的人数 winner = (winner + m) % i; &#125; //编号是从零开始，这里加1变成符合习惯的计数 printf (&quot;\\nThe winner is %d\\n&quot;, (winner +1)); &#125; 魔术师发牌问题 问题描述：魔术师手中有A到K十三张黑桃扑克牌，表演前魔术师已经按照一定的顺序叠放好，表演过程：开始，魔术师数1将最上面的那张翻过来，是黑桃A，将其放在桌面上；第二次，魔术师数1、2，将第一张牌放在所有牌最下面，将第二张牌翻转过来，第二张牌正好是黑桃2；第三次，魔术师数1、2、3，将第一、二张牌按照顺序放在所有牌最下面，将第三张牌翻转过来，第三张牌正好是黑桃3；…知道所有牌都翻转过来，顺序刚好是A、2、3…K，现在要知道魔术师在翻牌前叠放的13张牌的顺序。 代码实现 1 拉丁方阵问题 问题描述：拉丁方阵是一种n×n的方阵，方阵中恰有n种不同的元素，每种元素恰有n个，并且每种元素在一行和一列中 恰好出现一次。 特点：每一行除了开始的数递进一位外，其余的数都是按照顺序排列，递进的数排在后面，因此使用循环链表解决。 代码实现 1","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"时间复杂度和空间复杂度","slug":"时间复杂度和空间复杂度","date":"2020-04-07T13:24:37.000Z","updated":"2020-04-07T15:08:34.445Z","comments":true,"path":"2020/04/07/时间复杂度和空间复杂度/","link":"","permalink":"/2020/04/07/时间复杂度和空间复杂度/","excerpt":"","text":"时间复杂度：执行算法所需要的时间 空间复杂度：执行算法所需要的内存空间 时间复杂度的定义：一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得T(n)/f(n)的极限值（当n趋近于无穷大时）为不等于零的常数，则称f(n)是T(n)的同数量级函数 通常将O(1)、O(n)、O(logn)、O(n2)等分别叫做常量阶、线性阶、对数阶、平方阶等 推导大O阶方法：1.用常数1取代运行时间中的所有加法常数；2.修改后的运行次数函数中，值保留最高阶项；3.如果最高阶向存在且不是1，则去除与这个项相乘的常数 常数阶O(1)： 123int sum=0，n=100；sum=（1+n）*n/2;System.out.println(sum); 线性阶O(n): 123for(int i=0;i&lt;n;i++)&#123;//O(1)的算法&#125; 对数阶O(logn): 12345int num=1;while(num&lt;n)&#123;num=num*2;//O(1)的算法&#125; 平方阶O(n^2): 12345for(int i=0;i&lt;n;i++)&#123; for(int j=i;j++)&#123; //O(1)的算法 &#125;&#125; 常用的时间复杂度按照耗费的时间从小到大依次是： O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"面试积累","slug":"面试积累","date":"2020-02-05T06:20:52.000Z","updated":"2020-04-24T11:39:54.664Z","comments":true,"path":"2020/02/05/面试积累/","link":"","permalink":"/2020/02/05/面试积累/","excerpt":"","text":"要求： 五险一金（全额，非全额要在基础薪资上调整） 技术团队规模 上下班时间 单双休 加班情况 人员配置 发版频率 绩效 年终奖 其他福利 餐补 车补贴 房补贴 项目经验：遇到了什么困难怎么解决的 直播 做了两方面的隔离，一是与其他业务模块的解耦 利用中间控制层 直播模块提供出对其他业务场景的依赖需求 其他业务模块提供这些能力给直播；二是把直播内部分为业务表现层和三方依赖层 具体做法是把三方直播依赖沉淀到baseview 把业务层需要的能力通过统一能力管理输出 （主要是直播画面能力控制和自定义消息协议的控制） 首页 动画控件 级联viewtab java基础： 同步锁同步锁的原理： Arraylist和LinklistArrayList是一个数组实现了RandomAccess接口可以随机访问元素，增删速度相对慢；LinkList是链表，只能顺序访问元素，增删快 线程和进程 位运算常见十进制D、二进制B、八进制Q和十六进制H（逢几进1）n十进制向n进制转化：十进制转化为n进制时 十进制数一直除以n得余数 到一直不能整除为止，小数点部分是将小数部分乘以n 取整 然后小数部分继续乘以n 取整部分倒叙排序就是小数部分的值二进制转n进制：采用r（二进制和n进制之间的位数差 例如八进制是3合1、十六进制时4合1，如果是32进制就是 5合1）合1的方式，如果位数不够r位，整数部分向左补零，小数部分向右补零，然后按照案权展开相加即可得 线程安全 进程保活 HashMap原理 数据结构与算法： 时间复杂度、空间复杂度 网络： tcp的三次握手和四次挥手：第一次：c端发送连接请求 序列号seq=x SYN创建连接状态第二次：b端收到信息后 发送确认码ack=x+1 SYN=1第三次：c端收到后 http2.0 Android下网络优化方案 QUIC协议 Android基础：android sdk 三方库： eventbus原理利用反射触发事件函数的执行关键的一个键值对来存储数据 key是eventType（传递的时事件类型）线程模式 posting：处理函数看post在线程就在什么线程执行main：处理函数在主线程执行background：处理函数在子线程 post如果在主线程辉创建子线程 如果在子线程就直接在子线程触发处理async：新建子线程触发处理函数的执行 butterknife原理 okhttp rxjava retrofit Glide Fresco 三级缓冲7.","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"/tags/面试/"}]},{"title":"Android数据的持久化","slug":"Android数据的持久化","date":"2018-06-28T07:28:40.000Z","updated":"2018-06-28T07:51:47.298Z","comments":true,"path":"2018/06/28/Android数据的持久化/","link":"","permalink":"/2018/06/28/Android数据的持久化/","excerpt":"常见的存储的方式为SQlite数据存储、xml存储以及自定义数据格式的存储方式","text":"常见的存储的方式为SQlite数据存储、xml存储以及自定义数据格式的存储方式","categories":[],"tags":[{"name":"Android 存储","slug":"Android-存储","permalink":"/tags/Android-存储/"}]},{"title":"android 中gradle依赖冲突解决","slug":"android-中gradle依赖冲突解决","date":"2017-11-24T07:00:34.000Z","updated":"2020-04-07T14:52:54.168Z","comments":true,"path":"2017/11/24/android-中gradle依赖冲突解决/","link":"","permalink":"/2017/11/24/android-中gradle依赖冲突解决/","excerpt":"","text":"android项目开发中经常会遇到库依赖异常，大多是版本依赖的冲突问题，说明下常见的版本依赖冲突解决方式 首页看下我们项目的依赖关系1./gradlew dependencies :app:dependencies :app表示依赖modulemac下运行可能人别不了命令行，运行+x gradlew ```添加权限1234567可以看到依赖结构是树状结构，各库下又依赖了android的官方提供的一些库，如果依赖的库不是太多的话，可以使用transitive参数，使得依赖库所需的依赖不直接使用，在依赖库的module中同一级上做依赖关系``` implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; compile (&apos;com.alibaba.android:vlayout:1.2.2@aar&apos;) &#123; transitive = false &#125; transitive为false表示单独依赖，true为默认树状依赖 这种解决方式只用于当前的依赖包只是版本导致的，且版本变动不大，起码它的代码package路径一致，如果差异很大可以指定依赖关系中特定包不包含到依赖中1234implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; compile (&apos;com.alibaba.android:vlayout:1.2.2@aar&apos;) &#123; exclude group: &apos;support-v4&apos; &#125;","categories":[],"tags":[{"name":"gradle","slug":"gradle","permalink":"/tags/gradle/"}]},{"title":"git基础知识","slug":"git基础知识","date":"2017-11-07T02:53:40.000Z","updated":"2017-11-16T05:57:00.390Z","comments":true,"path":"2017/11/07/git基础知识/","link":"","permalink":"/2017/11/07/git基础知识/","excerpt":"","text":"git基础知识——创建新的ssh key ssh-keygen -t rsa -C \"793021170@qq.com\"```1234------测试 ssh 链接 github```$ ssh -T git@git.oschina.net ——设置用户名、邮箱 git config --global user.name \"litchi\"```1```$ git config --global user.email &quot;793021170@qq.com&quot; ——提交到远程服务器 git remote add origin ssh://git@dev.lemote.com/rt4ls.git```1```$ git push origin master ——-本地库中缺少md文件时git pull --rebase origin master```1234567-------由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令```$ git push -u origin master ——-关联远程库git remote add origin git@server-name:path/repo-name.git```123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178git checkout master //进入master分支git checkout -b frommaster //以master为源创建分支frommastergit show # 显示某次提交的内容 git show $idgit co -- &lt;file&gt; # 抛弃工作区修改git co . # 抛弃工作区修改git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci &lt;file&gt; git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci -am &quot;some comments&quot;git ci --amend # 修改最后一次提交记录git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象git revert HEAD # 恢复最后一次提交的状态查看文件diffgit diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diffgit diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较git diff --staged # 比较暂存区和版本库差异git diff --cached # 比较暂存区和版本库差异git diff --stat # 仅仅比较统计信息查看提交记录git log git log &lt;file&gt; # 查看该文件每次提交记录git log -p &lt;file&gt; # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log --stat #查看提交统计信息tigMac上可以使用tig代替diff和log，brew install tigGit 本地分支管理查看、切换、创建和删除分支git br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br --merged # 查看已经被合并到当前分支的分支git br --no-merged # 查看尚未被合并到当前分支的分支git co &lt;branch&gt; # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d &lt;branch&gt; # 删除某个分支git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebasegit merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; Git补丁管理(方便在多台机器上开发同步时用)git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch # 打补丁git apply --check ../sync.patch #测试补丁能否成功 Git暂存管理git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支Git远程仓库管理GitHubgit remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm &lt;repository&gt; # 删除远程仓库创建远程仓库git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支也可以命令设置跟踪远程库和本地库git branch --set-upstream master origin/mastergit branch --set-upstream develop origin/develop--------显示command的help```git help &lt;command&gt; # 异常处理：1.如果出现remote origin already exists.需要删除远程库后在执行git remote add origin 具体执行：git remote rm origin git remote add origin git@git.oschina.net:jichengliu/SilkMarke","categories":[],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}]},{"title":"设计模式之工厂模式","slug":"设计模式之工厂模式","date":"2017-11-06T03:10:35.000Z","updated":"2017-11-16T05:50:54.645Z","comments":true,"path":"2017/11/06/设计模式之工厂模式/","link":"","permalink":"/2017/11/06/设计模式之工厂模式/","excerpt":"","text":"设计模式之工厂模式前言最近在看设计模式相关的一些知识，看了一些感觉还是要做一些记录的，一方面用来记录当前情况下个人对设计模式的理解程度，使得这块知识更加深刻，另一方面也是方便把自己的一些拙见拿出来希望能够共同进步，得到众人的指正。 引入工厂模式应该说最常见的模式，看一些介绍模式的书里工厂模式基本都是第一个被提到的，它应用场景比较多，也容易被理解。它是名如其模式，先来分析下它的名字，“工厂”用来生产各种产品，我们可以直接通过工厂来获得需要的各种产品，而不需要来考虑其具体的实现，所谓的“工厂”就类似于“商店”，提供我们需要所需产品。那么“工厂”的产品是怎么样获得的呢，“工厂”会根据我们具体的需求来利用具体的“材料”来“生产”具体的产品，到这里来看图说话。 上图就是对上面文字的一个概括，这里先又了这个概念就OK了，下面深入到代码层面来说明。 代码实现这里用引入中最原始的提到的工厂、产品和消费者举例。例子在android studio中android项目中开发。 工厂、产品和消费者 创建一个工厂类(Factory),提供一个获得产品的方法 123456789101112131415161718192021222324public class Factory &#123; /** * 获得产品对象实例 * * @param clazz clazz * @param &lt;P extends BaseProduct&gt; p * @return p */ public static &lt;P extends BaseProduct&gt; P getProduct(Class&lt;P&gt; clazz) &#123; P p = null; try &#123; p = (P) Class.forName(clazz.getName()).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return p; &#125;&#125; 创建一个接口(IProduct)，商品类将实现produce()方法 12345public interface IProduct &#123; public BaseProduct produce();&#125; 分别创建商品类(BaseProduct、ProductOne、ProductTwo、ProductThree和ProductFour) 123456public abstract class BaseProduct implements IProduct &#123; public void makeBaseComponents() &#123; //制作基础组件 &#125;&#125; 123456789public class ProductOne extends BaseProduct implements IProduct &#123; @Override public BaseProduct produce() &#123; makeBaseComponents(); Log.d(\"ProductOne\", \"make ProductOne\"); return this; &#125;&#125; 123456789public class ProductTwo extends BaseProduct implements IProduct &#123; @Override public BaseProduct produce() &#123; makeBaseComponents(); Log.d(\"ProductTwo\", \"make ProductTwo\"); return this; &#125;&#125; 123456789public class ProductThree extends BaseProduct implements IProduct &#123; @Override public BaseProduct produce() &#123; makeBaseComponents(); Log.d(\"ProductThree\", \"make ProductThree\"); return this; &#125;&#125; 123456789public class ProductFour extends BaseProduct implements IProduct &#123; @Override public BaseProduct produce() &#123; makeBaseComponents(); Log.d(\"ProductFour\", \"make ProductFour\"); return this; &#125;&#125; 在MainActivity类中获得需要的商品类实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void onGetProduct(int productType) &#123; Class&lt;? extends BaseProduct&gt; clazz = null; switch (productType) &#123; case 1: clazz = ProductOne.class; break; case 2: clazz = ProductTwo.class; break; case 3: clazz = ProductThree.class; break; case 4: clazz = ProductFour.class; break; &#125; BaseProduct product = Factory.getProduct(clazz); Toast.makeText(this, product.produce(), Toast.LENGTH_LONG).show(); &#125; public void onGetProductThree(View view) &#123; onGetProduct(3); &#125; public void onGetProductTwo(View view) &#123; onGetProduct(2); &#125; public void onGetProductOne(View view) &#123; onGetProduct(1); &#125; public void onGetProductFour(View view) &#123; onGetProduct(4); &#125;&#125; 最终我们实现在activity中获得了产品的实例对象 github 为什么要用工厂模式在开发过程中常常会独立做一些模块供其他的开发者来用，这种情况下，其实对于其他的开发者来说要求在使用功能时尽量的简单、调用方便，他们不需要去了解里面的具体实现，只要简单调用就可以拿到对应的实例，这个时候对于工厂模式时一个可行的方案，当然在实际开发中可以会和其他的模式混用来达到效果，这个还要具问具析。对于我们可以在什么场景下利用工厂模式，这里列出一些它的利弊，以便在考虑使用时参考： 利: 多类型扩展好，如果新增了一种商品只要实现它的具体类和方法，即可根据类来获取其实例 具体实现是封闭的、不对外的 调用方便，可通过一个类型或者类名就可以获得具体实例 弊产品类创建方式单一，因为是通过类命来创建实例，这样创建不会像常见的直接new灵活不适合单一产品时使用","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}]},{"title":"Markdown常用语法","slug":"Markdown常用语法","date":"2017-11-06T03:01:55.000Z","updated":"2017-11-07T04:49:11.000Z","comments":true,"path":"2017/11/06/Markdown常用语法/","link":"","permalink":"/2017/11/06/Markdown常用语法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"hexo command line","slug":"hexo-command-line","date":"2017-11-03T14:34:03.000Z","updated":"2020-02-05T06:21:38.195Z","comments":true,"path":"2017/11/03/hexo-command-line/","link":"","permalink":"/2017/11/03/hexo-command-line/","excerpt":"Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server","text":"Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"linux环境下jdk安装配置","slug":"linux环境下jdk安装配置","date":"2017-11-03T13:54:47.000Z","updated":"2017-11-03T14:46:49.000Z","comments":true,"path":"2017/11/03/linux环境下jdk安装配置/","link":"","permalink":"/2017/11/03/linux环境下jdk安装配置/","excerpt":"jdk下载 wget -O jdk-8u131-linux-x64.tar.gz jdk-8u131-linux-x64.tar.gzAuthParam=1499664230_984ba136862e0fd6281ac5bc2bee90e2 解压文件 tar xf jdk-8u131-linux-x64.tar.gz 创建要存放的目录并复制解压后的jdk文件到目录下","text":"jdk下载 wget -O jdk-8u131-linux-x64.tar.gz jdk-8u131-linux-x64.tar.gzAuthParam=1499664230_984ba136862e0fd6281ac5bc2bee90e2 解压文件 tar xf jdk-8u131-linux-x64.tar.gz 创建要存放的目录并复制解压后的jdk文件到目录下 修改配置文件，指向存放jdk的目录 cd etc(进入etc目录) vi profile（打开profile文件并修改环境变量 source profile（使文件生效) 测试 java -version 能够打印java 版本号信息就表示安装或升级成功","categories":[],"tags":[{"name":"java linux","slug":"java-linux","permalink":"/tags/java-linux/"}]},{"title":"linux环境下Jenkins搭建","slug":"linux环境下Jenkins搭建","date":"2017-11-03T13:46:06.000Z","updated":"2017-11-03T14:30:32.000Z","comments":true,"path":"2017/11/03/linux环境下Jenkins搭建/","link":"","permalink":"/2017/11/03/linux环境下Jenkins搭建/","excerpt":"安装java环境具体查看Linux java环境安装 安装tomcat从tomcat官网上下载最新的安装压缩包，注意区分选择不同操作环境下的压缩包.（Linux一般是 tar.gz，Windows一般用zip压缩包），选择对应的压缩包能保证系统可以直接解压，避免不支持时还需安转压缩工具。 下载压缩包 wget http://apache.fayea.com/tomcat/tomcat-8/v8.5.16/bin/apache-tomcat-8.5.16.tar.gz 解压压缩包 tar xf apache-tomcat-8.5.16.tar.gz 进入解压后的文件夹并将所有的复制到自己要安装的目录下 cd apache-tomcat-8.5.16 cp -rf ./* /usr/local/tomcat/","text":"安装java环境具体查看Linux java环境安装 安装tomcat从tomcat官网上下载最新的安装压缩包，注意区分选择不同操作环境下的压缩包.（Linux一般是 tar.gz，Windows一般用zip压缩包），选择对应的压缩包能保证系统可以直接解压，避免不支持时还需安转压缩工具。 下载压缩包 wget http://apache.fayea.com/tomcat/tomcat-8/v8.5.16/bin/apache-tomcat-8.5.16.tar.gz 解压压缩包 tar xf apache-tomcat-8.5.16.tar.gz 进入解压后的文件夹并将所有的复制到自己要安装的目录下 cd apache-tomcat-8.5.16 cp -rf ./* /usr/local/tomcat/ 安装SDK根据镜像下载sdk包即可，注意最新的sdk可能没有platform tools文件夹，可下在低版本的将platform tolls文件夹移动到最新的sdk文件夹下即可。 有一些插件也可以在没有sdk时自动在Jenkins搭建好后构建时自动下载sdk，如Android Emulator Plugin在配置好后它自己会根据配置参数自动去下载对应的sdk版本，这里后面会说到。 安装Jenkins从Jenkins官网下载并复制jenkins.war到tomcat目录下webapps下。 wget http://mirrors.jenkins.io/war/latest/jenkins.war cp ./jenkins.war /usr/local/tomcat/webapps 启动Tomcat在浏览器中打开http://网址:8080/jenkins/就可以打开Jenkins网页，接下来就可以创建项目，Jenkins玩起来了。 注： 如果要使用其他端口来使用Jenkins可以运行命令： java -jar jenkins.war --httpPort=端口号 java -jar jenkins.war --httpPort=8899 --daemon --logfile=日志路径/jenkins/jenkins.log(在后台运行) 在打开Jenkins网页前要保证对应的端口号可访问，aliyun要配置安全组，开放对应端口。","categories":[],"tags":[{"name":"Jenkins tomcat Linux","slug":"Jenkins-tomcat-Linux","permalink":"/tags/Jenkins-tomcat-Linux/"}]},{"title":"note","slug":"note","date":"2017-11-03T08:56:19.000Z","updated":"2017-12-04T03:24:38.104Z","comments":true,"path":"2017/11/03/note/","link":"","permalink":"/2017/11/03/note/","excerpt":"","text":"hexo官方教程地址http:https://hexo.io/zh-cn/ markdown 教程http:http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-8/","categories":[],"tags":[]},{"title":"Jenkins参数化构建android项目","slug":"Jenkins参数化构建android项目","date":"2017-11-03T01:59:37.000Z","updated":"2017-11-03T15:28:17.000Z","comments":true,"path":"2017/11/03/Jenkins参数化构建android项目/","link":"","permalink":"/2017/11/03/Jenkins参数化构建android项目/","excerpt":"达到的目标： 根据版本类型(release、beta or debug)、版本号、渠道、服务器请求地址等参数进行构建； 构建完成后显示相关构建信息； 展示apk下载二维码、下载地址供直接安装和下载apk 需要的插件： Dynamic Extended Choice Parameter plugin参数化选择需要 Description Setter Plugin构建的信息显示需要 GIt Plugingit 插件","text":"达到的目标： 根据版本类型(release、beta or debug)、版本号、渠道、服务器请求地址等参数进行构建； 构建完成后显示相关构建信息； 展示apk下载二维码、下载地址供直接安装和下载apk 需要的插件： Dynamic Extended Choice Parameter plugin参数化选择需要 Description Setter Plugin构建的信息显示需要 GIt Plugingit 插件 配置项目参数： 设置构建类型参数： 在general模块中复选‘参数化构建过程’，‘添加参数‘中选择’Choice Parameter‘; Name添加参数名，按照Jenkins已有的默认参数集来定义都以大写字母和下划线组成，例：ENVIRONMENT_BUILD，Choices输入item的选项，第一项会变成默认项。 设置列表型参数渠道、版本号、服务器请求地址等： 列表型参数和构建类型一样，设置name、Choices和Description。 配置git参数： 这里首先要保证我们的代码在每个版本都有独立的版本分支，通过不同的版本名来拉取对应的代码，来实现分版本构建。 配置构建命令参数： Tasks输入框输入构建命令行 clean assemble${PRODUCT_FLAVOR_BUILD}${ENVIRONMENT_BUILD}，${参数}表示参数应用，‘PRODUCT_FLAVOR_BUILD’是自定义的参数用来表示构建渠道，‘ENVIRONMENT_BUILD’表示构建类型。 配置构建后描述参数： 在‘构建’模块‘增加构建步骤’列表中选择‘set build description’，在Description输入框输入html代码，例如下，其中的‘${参数}’表示自定义的一些参数，用‘${参数}’来取对应的值。 请求环境：${JENKINS_SERVER_HOST}构建类型：${ENVIRONMENT_BUILD}构建渠道：${PRODUCT_FLAVOR_BUILD}构建版本：${APP_BUILD_VERSION}点击查看二维码点击下载apk 注：如果在构建完后显示还是按照文本显示的，修改一下系统管理／安全配置中‘Markup Formatter‘选择为Safe HTML，来支持html。 配置效果：","categories":[],"tags":[{"name":"Jenkins Android","slug":"Jenkins-Android","permalink":"/tags/Jenkins-Android/"}]}]}