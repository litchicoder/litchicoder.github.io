{"meta":{"title":"litchi","subtitle":"litchi blog","description":null,"author":"litchi","url":""},"pages":[{"title":"404","date":"2020-03-30T13:32:57.615Z","updated":"2017-11-03T08:52:38.000Z","comments":true,"path":"/404.html","permalink":"//404.html","excerpt":"","text":"页面找不到了，回看看吧！"},{"title":"about","date":"2017-11-07T06:59:32.000Z","updated":"2017-11-07T07:00:17.000Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"litchi"}],"posts":[{"title":"HashMap原理","slug":"HashMap原理","date":"2020-05-09T04:30:20.000Z","updated":"2020-05-11T08:41:42.898Z","comments":true,"path":"2020/05/09/HashMap原理/","link":"","permalink":"/2020/05/09/HashMap原理/","excerpt":"","text":"HashMap的内部存储是以数组+链表+红黑树为组合的复合结构，数组(table)中元素是Entry，键值对(key-value)中key的hashCode值决定了Entry元素在数组中的位置，当发生hash冲突时，相同hash值的Entry元素组成链表，链表的长度是有定长的（TREEIFY_THRESHOLD=8），当链表触发链表树化，就会变成树形结构。 1234567/** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */ transient Node&lt;K,V&gt;[] table; hash() 123456789101112131415161718192021222324252627/** * Computes key.hashCode() and spreads (XORs) higher bits of hash * to lower. Because the table uses power-of-two masking, sets of * hashes that vary only in bits above the current mask will * always collide. (Among known examples are sets of Float keys * holding consecutive whole numbers in small tables.) So we * apply a transform that spreads the impact of higher bits * downward. There is a tradeoff between speed, utility, and * quality of bit-spreading. Because many common sets of hashes * are already reasonably distributed (so don&apos;t benefit from * spreading), and because we use trees to handle large sets of * collisions in bins, we just XOR some shifted bits in the * cheapest possible way to reduce systematic lossage, as well as * to incorporate impact of the highest bits that would otherwise * never be used in index calculations because of table bounds. * * 计算key.hashCode()并且移动高位到低位。由于数组使用2的幂次表示，变化仅仅在hash集合 * 的上方中这将总是发生碰撞（这其中的例子是Float的key集合在小的table中保持连续的数 * 字），所以我们应用高位向下移动的影响来作为转化。在速度、实用和为扩展上需要权衡，由于 * 许多哈希集已经合理的分布（所以无需从移动位中受益），并且因为我们使用了树来处理容器中 * 更大的冲突，因此我们仅以最简答单的方式对一些以为后的微bit进行XOR，以减少系统损耗， * 以及最高位的影响，否则由于table番位的限制，这些高位将永远不会在索引计算中使用。 */ static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 可以看到hash方法中将Object key计算出的hashCode右移了16位，这里的原因官方注释中已经很明了，这样做是为了将高位的信息在hash值进行计算索引中降低冲突的概率，因为在一些hash中低位可能会相同，所以这里移位来使得hash更加分布均匀。 构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; /** * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; 看到HashMap1.8中四个构造函数，主要就看第一个，两个入参initialCapacity是table数组的大小，默认值DEFAULT_INITIAL_CAPACITY=16，loadFactor负载因子用来控制扩容的阈值默认DEFAULT_LOAD_FACTOR=0.75f，就是当table的threshold到达0.75时触发table扩容。这里tableSizeFor(initialCapacity)方法是利用传入的初始化table容量转为2的幂次数。 put方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; /** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&apos;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0)//（1） n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null)//（2） tab[i] = newNode(hash, key, value, null); else &#123;//（3） Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))//（4） e = p; else if (p instanceof TreeNode)//（5） e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123;//（6） for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))//（7） break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value;//（8） if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount;//（9） if (++size &gt; threshold)//(10) resize(); afterNodeInsertion(evict); return null; &#125; 这里主要看putVal()方法。（1）这里第一个if判断table是否为空，为空就利用resize方法初始化；（2）第二个if判断如果当前根据hash跟到的table索引下为空就直接将Node对象放入table中；（3）else下是hash发生碰撞；（4）首先第一个if判断的是如果NewNode和table中位置的Node hash值和key都相同就直接可以看作是同一个Node，这里还有个场景是否用新put的values覆盖老的value，onlyIfAbsent为false或者老的value为空就要覆盖掉老值；（5）else if判断如果是一个树结点就调用putTreeVal插入元素；（6）else下循环遍历将p添加到链表尾部，如果这时达到链表最大阈值就需要调用treeifyBin方法进行树化；（7）如果已经在链表中就braek掉；（8）这里判断是否需要覆盖老数据。（9）modCount保证并发访问，这里的put方法是线程不安全的，所以当modCount发现变化不一致就会抛出ConcurrentModificationException。 12345678910111213141516171819202122232425262728293031 final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125;``` (10)这里对table扩容。* resize方法 /** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table * * 初始化或增加成两倍大的table，如果为空，则根据字段阈值中保持的初始容量目标进行分配。 * 否则，因为我们使用的是2的幂，所以每个bin中的元素必须保持相同的索引，或者在新表中以2 * 的幂偏移。 */ final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) {//（1） Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order //（2） Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 12345678上面的代码基本都很好理解的，这里主要说两个点： （1）这个位置是table变成两倍table的元素移动的操作，e.nex=null说明它就是一个元素不存在链和树直接根据e.hash &amp; (newCap - 1)计算出它在新table中的位置并赋值；如果是树通过split方法复制树； （2）这里比较重要的操作。这里是链表复制的过程，这里链表上的Node位置有两个场景，一种是不需要移动的Node形成链表还在老的index下，另一种是需要我们移动位置的Node形成新的链表复制到新的index下。*这里为什么会有这个操作，因为index值的确定是根据Node.hash和cap-1取与获得的，那么在变成两倍table后讲道理每一个index都需要重新取计算，但是这里观察变成两倍table的原理其实每次threshold&lt;&lt;1（也就是二进制高位变成1），那么这样Node.hash和cap-1取与过程中发生变化的就只有高位是1的所以这里(e.hash &amp; oldCap) == 0表示在变成两倍table后index不需要变化，如果需要变化那么index=老idnex+oldCap。* ![](hashmap_resize.jpg)&lt;!--你好啊--&gt;* get方法 /** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * {@code k} to a value {@code v} such that {@code (key==null ? k==null : * key.equals(k))}, then this method returns {@code v}; otherwise * it returns {@code null}. (There can be at most one such mapping.) * * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt; * indicate that the map contains no mapping for the key; it&apos;s also * possible that the map explicitly maps the key to {@code null}. * The {@link #containsKey containsKey} operation may be used to * distinguish these two cases. * * @see #put(Object, Object) */ public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } /** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */ final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } ` get方法相对简单直接通过key和hash取查找元素，如果是table中的first直接返回如果是tree从tree遍历g得到，如果是链表遍历拿到。 总结hash()方法的关键是高位右移的操作，目的是为了使得hash趋于均匀分布，避免hash冲突（碰撞），在与table.length取与获得index时尽降低形成链put()方法完成table创建和初始化和新增Node，新增Node分三个场景直接放置在table[index]位置；形成链表的插入链表中，链表达到阈值形成红黑树resize()方法完成 两倍扩展以及扩展后的Node的重新放置，这里重要是巧妙的使用 (e.hash &amp; oldCap) == 0来作为是否将老链表数据分开放置的处理，利用扩容和2的幂的关系进行操作","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/categories/JAVA基础/"}],"tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"/tags/JAVA基础/"}]},{"title":"运行时数据区","slug":"运行时数据区","date":"2020-05-08T05:07:49.000Z","updated":"2020-05-08T08:18:38.654Z","comments":true,"path":"2020/05/08/运行时数据区/","link":"","permalink":"/2020/05/08/运行时数据区/","excerpt":"","text":"运行时数据区也就是JVM运行时的内存区域，这里主要划分为堆区、方法区、虚拟机栈、本地方法栈和PC寄存器。 堆区：堆区是这其中最大的一块区域，保存几乎所有创建出来的对象实例，这块区域是线程共享的，堆区是垃圾回收的主要区域，因此也叫“GC堆”,在GC回收时采用分代收集算法，所以堆区分为新生代和老年代。堆区在物理上时不连续的，在逻辑中看作是连续的。在堆区分配内存给对象实例时如果内存不足，会抛出OutOfMemoryError异常。Minor Gc和Major Gc(Full GC)：Minor Gc是指新生代垃圾回收的动作，新创建的对象都会在新生代，所以Minor Gc相对频繁，回收速度相对也快；Major Gc(Full GC)时老年代的垃圾回收动作，Major Gc(Full GC)回收频率较慢，速度也较慢。 方法区：方法区线程共享，方法去存储类的信息、常量、静态变量以及运行时常量池(Runtime Constant Pool:常量不一定只能在编译期产生，运行期间也可能产生新的常量，这些常量被放在运行时常量池中，例如通过String.intern()将String放入常量池)。 虚拟机栈和本地方法栈：虚拟机栈每个线程在创建时都会创建一个虚拟机栈，内部是由一个个的栈帧组成(Stack Frame)，一个栈帧就对应一个Java方法调用。它主管Java程序的运行，保存方法的局部变量（8中基本数据类型、对象引用地址）、部分结果，并参与方法的调用和返回。虚拟机栈的大小允许是固定的或者是动态的： 虚拟机栈大小固定情况下，如果线程请求分配的栈容量超过了虚拟机栈允许的最大容量就会报StackOverFlowError异常。虚拟机栈大小动态的情况下，当虚拟机栈请求扩展容量而这时内存不足JVM就会抛出OutOfMemoryError异常，同样在创建线程时如果没有足够的内存空间提供给虚拟机栈，也会报OutOfMemoryError异常。 每个栈帧包含：局部变量表、操作数栈、动态链接和方法返回地址。1.局部变量表：局部变量表存储方法参数和定义在方法内的局部变量，局部变量表的存储单位时slot（变量槽），存储的数据类型包括基本数据类型、引用数据类型和返回地址类型。 局部变量表的大小是在编译期间就确定下来的。 2.操作数栈：操作数栈在方法执行的过程中根据字节码指令写或者提取数据（入栈和出栈）。3.动态链接（Dynamic Linking）：即指向运行时常量池的引用它是栈帧内部指向运行时常量池中该栈帧所属方法的引用。动态链接的作用是为将符号应用转换为调用方法的直接引用。4.方法返回地址（return address）：方法返回地址存放调用该方法的PC寄存器的值。方法退出救市栈帧出栈的过程，此时需要恢复上层方法的局部变量表、操作数栈，将返回值压入调用者的操作数栈中，更新PC寄存器，调用者继续执行接下来的指令。异常完成退出不会给上层调用者产生任何返回值 本地方法栈结构与Java虚拟机栈相同，只是它服务的是本地方法，也有些虚拟机中将本地方法栈和Java虚拟机栈合二为一。 PC寄存器（Program Counter Register）：PC寄存器用来存放下一行执行指令的地址，由执行引擎读取下条指令。根据是一块很小的内存区域，每个线程都有自己的PC寄存器，它是线程私有的区域，生命周期与线程的生命周期保持一致。PC寄存器是JVM规范中唯一一个不会发生OutOfMemory的区域，也不存在GC。PC寄存器可以保证线程切换时指令不会发生异常，在来回切换后可以回到切换前执行位置继续执行。","categories":[{"name":"JVM","slug":"JVM","permalink":"/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"}]},{"title":"关于作者","slug":"关于作者","date":"2020-05-07T12:32:47.000Z","updated":"2020-05-07T12:34:06.625Z","comments":true,"path":"2020/05/07/关于作者/","link":"","permalink":"/2020/05/07/关于作者/","excerpt":"","text":"litchi 1992-05-20 浙江杭州 Android JAVA","categories":[],"tags":[]},{"title":"GC机制","slug":"GC机制","date":"2020-05-07T07:51:31.000Z","updated":"2020-05-07T10:59:28.215Z","comments":true,"path":"2020/05/07/GC机制/","link":"","permalink":"/2020/05/07/GC机制/","excerpt":"","text":"垃圾回收机制是JVM持续运行的关键，当JVM在运行过程中会产生很多“无用”的对象，如果没有及时GC就会导致我们虚拟机运行效率的降低，从而引发系统的异常。在运行时数据区中程序计数器、虚拟机栈、本地方法栈是线程私有的，不需要进行垃圾回收。方法区和堆区线程共享需要进行垃圾回收，堆是Java虚拟机进行垃圾回收的主要场所，其次要场所是方法区。垃圾回收分两步找到垃圾和回收垃圾，一般查找垃圾有两种方法引用计数法和可达性分析算法。引用计数法就是给每个创建的对象添加一个引用计数器，当有一地方引用它时引用计数器加1，当有引用消除时引用计数器减1。当引用计数器等于0时就表示该对象可收回。标记计数法存在的问题时当有两个或几个对象互相引用时，它们的引用计数器永远不会为0，就永远不会被回收。可达性分析算法（根搜索算法）以根对象作为根结点进行搜索，当有对象不可达时就认为该对象可回收，根对象一般指虚拟机栈中的引用对象、本地方法栈中JNI的引用对象、方法区中运行常量池中的引用对象、方法区中静态属性引用的对象、运行中的线程、由引导类加载器加载的对象、GC控制的对象。垃圾回收算法有：1.标记-清除（mark–sweep）标记所有需要回收的对象，之后统一回收。这是最基础的算法，后续的回收算法都是基于这个算法扩展的。缺点明显效率低，产生大量碎片。2.复制（copying）将内存空间划分两块相等的区域，每次只使用其中的一块区域，垃圾回收时遍历正在使用的区域内对象，将正在使用的引用对象赋值到另一块区域。每次垃圾回收时只处理正在使用的对象，赋值成本低，赋值过去会进行整理，不存在内存碎片。缺点是需要双倍的内存空间，以空间换时间。3.标记-整理或压缩（mark–compact））结合了复制和标记清除的优点，第一步标记所有需要回收的对象，第二部回收对象，并对存活对象进行整理（压缩）。4.分代收集算法根据对象生命周期的不同将对象分为新生代和老年代对象。新生代对象一般又分为Eden区(伊甸园)和两个Survivor区。新创建的u对象都在Eden区，当Eden区内存到达阈值就会出发Minor GC，这是就会把Eden区中的对象复制到其中一个Survivor区中，此时这些存活对象的生命存活计数会加1.这是Eden区空置，Eden区继续存放新创建的对象，当再次触发Minor Gc时，将此时Eden区的存活对象和之前一个Survivor区的存活对象复制到另外一个Survivor区中，同时它们的生命存活计数器加1，这个过程持续发生，当对象的存活计数器达到一定的阈值后触发“晋升”，新生代中的该对象就被放置到了老年代中。老年代中的对象经过多次的GC就会是生命周期很长的对象。当老年代的内存达到阈值时触发Major GC，这是采用标记-整理或压缩（mark–compact）算法。","categories":[{"name":"JVM","slug":"JVM","permalink":"/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"}]},{"title":"JVM结构","slug":"JVM结构","date":"2020-05-02T11:22:13.000Z","updated":"2020-05-07T11:05:31.701Z","comments":true,"path":"2020/05/02/JVM结构/","link":"","permalink":"/2020/05/02/JVM结构/","excerpt":"","text":"JVM(JavaVirtualMachine，Java虚拟机)JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台（write once run anywhere）。JVM包含在JDK中的一部分。 类加载器子系统类加载器子系统主要负责将二进制字节码文件加载成JVM识别的数据结构，并对其文件进行规则校验和一些初始化工作。具体分为三个阶段loading、linking和initialization：loading阶段将字节码文件加载到JVM中，这里有四类加载器来完成，Bootstrap ClassLoader(C++实现，加载Java核心类库/java_home/lib/rt.jar里的类集合)、Extension ClassLoader（加载/java_home/lib/ext里的类集合）、App ClassLoader(package下定义的类)、User define ClassLoader（自定义类加载器）；linking阶段又分为三个阶段：verify、prepare、resolution，verify阶段验证Class文件是否符合JVM语法规则（具体包括类文件信息、元数据信息、字节码验证和符号引用验证）；prepare阶段为变量设置默认初始值，也就是0值，ps：int是0 String null；resolution阶段将符号引用转化为直接应用；initialization阶段完成静态变量的显式赋值和静态代码块的执行。 运行时数据区运行时数据区包括PC寄存器、虚拟机栈、本地方法栈、方法区、堆五部分组成。1.PC寄存器保存下一条将要被执行指令的地址和线程一一对应，这样保证了再线程来回切换时可以回到之前执行的位置；2.虚拟机栈用来描述java方法执行的内存模型，每个线程对应一个栈，栈内的栈帧对应java方法，栈帧结构又包括：局部变量表、操作数栈、动态链接和方法返回地址；3.本地方法栈的功能和结构与虚拟机栈类似，区别在于它服务的对象是native方法；4.方法区是一块线程共享的内存区域，保存类的版本/字段/方法/接口等描述信息以及常量、静态场景等，还有运行时常量池（Runtime Constant Pool）；5.堆用来保存创建对象的主体，是最大的一块数据区，也是线程共享的内存区域。 执行引擎执行引擎是将JVM字节码指令转化为本地物理机可识别的机器指令执行，是JVM的核心部分之一。 本地方法接口本地接口的作用是融合不同的编程语言为java所用。 本地方法库为本地方法提供依赖支持。","categories":[{"name":"JVM","slug":"JVM","permalink":"/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"}]},{"title":"类加载器子系统","slug":"类加载子系统","date":"2020-04-26T11:16:43.000Z","updated":"2020-05-07T11:06:00.851Z","comments":true,"path":"2020/04/26/类加载子系统/","link":"","permalink":"/2020/04/26/类加载子系统/","excerpt":"","text":"类加载过程包括加载（load）、链接（linking）和初始化（init） 加载将字节码文件从数据源中加载到JVM内存中，生成JVM的认可的数据结构（也就是Class对象），数据源可以是来自物理硬盘或者网络的jar文件、war文件、class文件等一些JVM可识别的文件格式结构（文件格式异常回报ClassFormatError）。 链接链接是类加载的核心部分，分三个步骤：验证、准备和解析1.验证（Verify）：保证字节流信息符合JVM规范，避免恶意数据危害JVM的安全运行（异常抛出VerifyError）。2.准备（Prepare）：为类变量分配内存和为变量设置初始值。3.解析（Resolve）：将符号应用转换为直接应用，符号应用就是一组符号来描述所应用的目标，直接应用就是直接指向目标的指针或句柄。 初始化初始化主要是将静态变量赋值和执行静态代码块的一系列操作。 双亲委派机制 双亲委派机制是在类加载过程中加载部分里的机制，加载器大致有启动类加载器Bootstrap ClassLoader（加载核心的类）、扩展类加载器Extension ClassLoader（ext path下的类）和应用类加载器Application ClassLoader（自定义）。在执行类加载请求时，子加载器会先委托父类加载器执行；如果父类加载器还存在父类加载器就继续委托，一次递归找到其顶部启动类加载器；如果启动类加载器可以完成任务则将结果返回，倘若启动类加载器不能完成任务这时一次再让子类加载器尝试加载，这个过程叫双亲委派机制。 双亲委派机制优点1.避免类重复加载2.保护程序安全，防止核心API被篡改（java.lang.String）","categories":[{"name":"JVM","slug":"JVM","permalink":"/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"}]},{"title":"查找算法","slug":"查找算法","date":"2020-04-21T07:00:09.000Z","updated":"2020-05-07T11:06:18.364Z","comments":true,"path":"2020/04/21/查找算法/","link":"","permalink":"/2020/04/21/查找算法/","excerpt":"","text":"插值查找 黄金分割法 线性索引查找 二叉排序树 平衡二叉树 B树 散列表（哈希表）查找*","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"图","slug":"图","date":"2020-04-17T07:10:34.000Z","updated":"2020-05-07T11:07:43.771Z","comments":true,"path":"2020/04/17/图/","link":"","permalink":"/2020/04/17/图/","excerpt":"","text":"图的特点：1.通常用V(Vertex)表示一组定点的集合；2.通常用E(Edge)表示一组边的集合。 顶点：图中的一个结点 图的边：顶点和顶点间的连线，有向图中的边叫做弧 相邻顶点：由一条边连接在一起的顶点 顶点的度：相邻顶点的数量叫做顶点的度 连通图：在无向图中，若任意两个顶点Vi与Vj都有路径相通，则称该无向图为连通图 强连通图：在有向图中，若任意两个顶点Vi与Vj都有路径相通，则称该有向图为强连通图 连通网：在连通图中，若图的边具有一定的意义，每一条边都有一个对应数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网 生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则会形成环 图的深度优先遍历：假设初始状态是图中所有顶点都未被访问，从图中某个顶点v出发，先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到；若此时还有剩余顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 图的广度优先遍历：假设从图中某个顶点v出发，在访问了顶点v之后依次访问顶点v的各个未曾访问过的邻接顶点，然后分别从这些邻接顶点再出发依次访问它们的邻接顶点，并使“先被访问的顶点的邻接顶点”先于“后被访问的顶点的邻接顶点”被访问，直到图中所有已被访问的顶点的邻接点都被访问到；若此时图中还有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 最小生成树：在连通网的所有生成树中，所有边的代价总和最小的生成树，称为最小生成树 1.普里姆算法(Prim算法)： 描述：1.定义一个加权连通图，其中顶点集合V、Vnew，Vnew是V的子集，边的集合E、Enew，Enew是E的子集；2.初始化集合Vnew{x},x(起始点)是集合V中任意一结点，Enew{}；3.从边的集合E中选取权值最小的边&lt;u, v&gt;(其中u是顶点集合Vnew的元素，v属于顶点集合V，而不在新顶点集合Vnew中。若权值相同时，任意取值)；4.将v加入新顶点集合Vnew，将边&lt;u, v&gt;加入新边集合Enew中；5.重复操作3和4步骤 ，知道Vnew=V时，输出集合Vnew和Enew，Vnew和Enew即是来描述该加权连通图的最小生成树。代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149 static class GraphMatrix &#123; /** * 边的数量 */ private int edgeNum; /** * 顶点集合 */ private char[] vertex; /** * 邻接矩阵 */ private int[][] matrix; public GraphMatrix(char[] vertex, int[][] matrix) &#123; this.vertex = vertex; this.matrix = matrix; getEdgeNum(); &#125; private void getEdgeNum() &#123; int length = vertex.length; for (int i = 0; i &lt; length; i++) &#123; for (int j = i + 1; j &lt; length; j++) &#123; //矩阵值等于Integer.MAX_VALUE表示不相邻，等于0是自己到自己 if (matrix[i][j] != Integer.MAX_VALUE) &#123; edgeNum++; &#125; &#125; &#125; &#125; /** * print matrix */ private void printMatrix() &#123; System.out.println(&quot;矩阵:&quot;); for (int[] m : matrix) &#123; for (int c : m) &#123; System.out.print(c + &quot; &quot;); &#125; System.out.println(); &#125; &#125; /** * 获取字符在结点里的位置 * * @param c 字符 * @return 返回-1没该字符，其他位置 */ private int getVertexPosition(char c) &#123; for (int i = 0; i &lt; vertex.length; i++) &#123; if (c == vertex[i]) &#123; return i; &#125; &#125; return -1; &#125; /** * 输入开始顶点位置 * * @param x 开始顶点位置 */ public void prime(int x) &#123; int num = vertex.length; //邻边权重 int[] weights = new int[num]; //prime最小生成树结果 char[] result = new char[num]; //result当前索引 int index = 0; //复制第一个顶点值 result[index] = vertex[x]; index++; //init weight 找到顶点相邻边的权重赋值weights[i] for (int i = 0; i &lt; num; i++) &#123; weights[i] = matrix[x][i]; &#125; weights[x] = 0; //循环遍历娶到最短权重值添加到result中 for (int i = 0; i &lt; num; i++) &#123; if (x == i) &#123; continue; &#125; int minWeight = Integer.MAX_VALUE; int minWeightIndex = 0; for (int j = 0; j &lt; num; j++) &#123; if (weights[j] != 0 &amp;&amp; weights[j] &lt; minWeight) &#123; minWeight = weights[j]; minWeightIndex = j; &#125; &#125; //保存最短权重顶点 result[index] = vertex[minWeightIndex]; index++; weights[minWeightIndex] = 0; for (int j = 0; j &lt; num; j++) &#123; if (weights[j] != 0 &amp;&amp; matrix[minWeightIndex][j] &lt; weights[j]) &#123; weights[j] = matrix[minWeightIndex][j]; &#125; &#125; &#125; //计算最小生成树的权重 int sum = 0; for (int i = 1; i &lt; index; i++) &#123; int min = Integer.MAX_VALUE; int n = getVertexPosition(result[i]); //求当前节点到上面其他节点的最小值 for (int j = 0; j &lt; i; j++) &#123; int m = getVertexPosition(result[j]); if (matrix[m][n] &lt; min) &#123; min = matrix[m][n]; &#125; &#125; sum += min; &#125; //打印最小生成树 System.out.printf(&quot;PRIME(%c):&quot;, vertex[x]); for (int i = 0; i &lt; index; i++) &#123; System.out.printf(&quot;%c &quot;, result[i]); &#125; System.out.println(); System.out.printf(&quot;权重：%d&quot;, sum); &#125; &#125;``` 2.克鲁斯卡尔算法(Kruskal算法)：描述： 首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。 代码实现： /** * 克鲁斯卡尔算法 */ public void Kruskal() { //结果数组的当前索引 int index = 0; //输出的结果数组 Edge[] results = new Edge[edgeNum]; //保存某个顶点在该最小生成树的终点 int[] vends = new int[edgeNum]; //获取图中所有的边 Edge[] edges = getEdges(); //将边按权重从小到大排序 sortEdges(edges); for (int i = 0; i &lt; edgeNum; i++) { int p1 = getVertexPosition(edges[i].start); int p2 = getVertexPosition(edges[i].end); int m = getEdgesEnd(vends, p1); int n = getEdgesEnd(vends, p2); if (m != n) {//表示没有形成闭环 vends[m] = n; results[index++] = edges[i]; } } //统计并打印最小生成树的信息 int length = 0; for (int i = 0; i &lt; index; i++) { length += results[i].weight; } System.out.println(&quot;Kruskal：&quot;); for (int i = 0; i &lt; index; i++) { System.out.printf(&quot;(%c,%c) &quot;, results[i].start, results[i].end); } System.out.println(); System.out.println(&quot;Kruskal的权重：&quot; + length); } //连通图的边结构 private static class Edge { char start;//边的起点 char end;//边的终点 int weight;//边的权重 public Edge(char start, char end, int weight) { this.start = start; this.end = end; this.weight = weight; } } /** * 获取图中的边 */ private Edge[] getEdges() { int index = 0; Edge[] edges = new Edge[edgeNum]; for (int i = 0; i &lt; vertex.length; i++) { for (int j = i + 1; j &lt; vertex.length; j++) { if (matrix[i][j] != Integer.MAX_VALUE) { edges[index++] = new Edge(vertex[i], vertex[j], matrix[i][j]); } } } return edges; } /** * 根据权重从小到大排序 * * @param edges edges */ private void sortEdges(Edge[] edges) { Edge tmp; for (int i = 0; i &lt; edges.length; i++) { for (int j = (i + 1); j &lt; edges.length; j++) { if (edges[i].weight &gt; edges[j].weight) {//若大于则交换位置 tmp = edges[i]; edges[i] = edges[j]; edges[j] = tmp; } } } } /** * 取终点 */ private int getEdgesEnd(int[] vends, int i) { //若C-&gt;D,D-&gt;F则取F的值 while (vends[i] != 0) { i = vends[i]; } return i; } ` 最短路径：","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"树","slug":"树","date":"2020-04-14T14:12:59.000Z","updated":"2020-05-07T11:07:33.990Z","comments":true,"path":"2020/04/14/树/","link":"","permalink":"/2020/04/14/树/","excerpt":"","text":"树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。 特点： 1.在非空树中，根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点；2.子树的个数没有限制，但它们互不相交； 度： 结点的度：结点拥有的子树个数叫做结点的度，结点A的度是3，C的度是2，H的度是1。树的度：树中最大的结点度。图中树的度是3 结点的关系 1.结点子树的根结点称为该结点的 孩子结点，该结点叫做孩子结点的双亲结点。图中E是B的孩子结点，B是E的双亲结点；2.同一双亲的结点叫做兄弟结点，图中的F、G是E的兄弟结点；3.同一层的结点叫做堂兄结点，通中的H、I、J、K、L是E的堂兄结点；4.从根到该结点经过的左右分支结点叫做该结点的祖先结点，图中M的祖先结点有A、B、E。5.该结点的子树任意一个结点都称为该结点的子孙结点，E的子孙结点有M和N。 结点的层次 从根开始定义，根为第一层，根的孩子为第二层，根的孩子的孩子为第三层…。树的深度：树中结点的最大层次数称为树的深度或高度，图中深度为4 二叉树二叉树(Binary Tree)是n(n&gt;=0)个结点的有限集合，该集合或者为空集(空二叉树)，或者由一个跟结点和两个互补相交的、分别称为根的结点在左子树和右子树组成。每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。 二叉树的特点 1.每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点；2.左子树和右子树是有顺序的，次序不能任意颠倒；3.即使树中某结点只有一棵子树，也要区分它是左子树还是右子树； 二叉树的性质 1.在二叉树中第i层上最多有2的i-1次方个结点(i&gt;=1)；2.二叉树中如果深度为k,那么最多有2k-1个节点(k&gt;=1）； 斜树 所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。 满二叉树在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。满二叉树的特点有：1.叶子只能出现在最下一层。出现在其它层就不可能达成平衡。2.非叶子结点的度一定是2。3.在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。 完全二叉树若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。完全二叉树的特点：1.叶子结点只出现在最下层和次下层；2.最下层叶子结点集中在树的左部；3.如果结点度为1，则该结点只有左孩子，即没有右子树；4.相同结点数的二叉树，完全二叉树的深度最小；5.满二叉树一定是完全二叉树，但反过来不一定成立。 二叉树存储结构 1.*** 顺序存储结构二叉树的顺序存储结构就是使用一维数组存储二叉树中的结点，并且结点的存储位置，就是数组的下标索引。 如果索引下为空表示该位置下没有存储结点。 2.*** 链式存储结构 结构定义 12345678class BinaryNode&lt;E&gt; &#123; //数据 E data; //左子树 BinaryNode leftChild; //右子树 BinaryNode rightChild;&#125; 二叉树的遍历 1.前序遍历(DLR)首先访问根，再先序遍历左（右）子树，最后先序遍历右（左）子树图中结果：ABDECFG 12345678910111213141516171819/** * 前序遍历 * * @param root 根 */ public void DLR(BinaryNode root) &#123; if (root == null) &#123; return; &#125; //TODO do something if (root.leftChild != null) &#123; DLR(root.leftChild); &#125; if (root.rightChild != null) &#123; DLR(root.rightChild); &#125; &#125; 2.中序遍历(LDR)首先中序遍历左（右）子树，再访问根，最后中序遍历右（左）子树。图中结果：DBEAFCG 12345678910111213141516171819/** * 中序遍历 * * @param root 根 */ public void LDR(BinaryNode root) &#123; if (root == null) &#123; return; &#125; if (root.leftChild != null) &#123; LDR(root.leftChild); &#125; //TODO do something if (root.rightChild != null) &#123; LDR(root.rightChild); &#125; &#125; 3.后序遍历(LRD)首先后序遍历左（右）子树，再后序遍历右（左）子树，最后访问根图中结果：DEBFGA 12345678910111213141516171819/** * 后序遍历 * * @param root 根 */ public void LRD(BinaryNode root) &#123; if (root == null) &#123; return; &#125; if (root.leftChild != null) &#123; LRD(root.leftChild); &#125; if (root.rightChild != null) &#123; LRD(root.rightChild); &#125; //TODO do something &#125; 4.层序遍历按照层次访问，通常用队列来做。访问根，访问子女，再访问子女的子女 线索二叉树 二叉树线索化的过程中，会把树中的空指针利用起来作为寻找当前节点前驱和后继的线索，这样就出现了一个问题，即线索和数中原有指向孩子节点的指针无法区分。上边的这种节点设计就是为了区分这两类指针。其中，ltag和rtag为标识域，它们的具体意义如下:1.如果ltag==0，表示lchild为指针，指向结点的左子树；2.如果ltag==1，表示lchild为线索，指向结点的直接前驱;3.如果rtag==0，表示rchild为指针，指向结点的右子树；4.如果rtag==1，表示rchild为线索，指向结点的直接后继。 哈夫曼树 当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"字符串匹配算法","slug":"字符串匹配算法","date":"2020-04-14T06:49:35.000Z","updated":"2020-05-07T11:08:09.874Z","comments":true,"path":"2020/04/14/字符串匹配算法/","link":"","permalink":"/2020/04/14/字符串匹配算法/","excerpt":"","text":"BF算法首先原串与字串左端对齐，，如果第一个字符不匹配，字串向后移动逐一移动，当发现死一个第一个字符匹配后，当前位置下比较剩余字串的字符与原串是否匹配，直到全部匹配。 1234567对齐:litchicodercoder逐一移动 找到匹配字符:litchicoder coder 代码实现： 12345678910111213141516171819202122232425262728293031323334class BF &#123; public static void main(String[] args) &#123; int r = queryByBF(&quot;HelloWord&quot;, &quot;Word&quot;); System.out.print(r == 0 ? &quot;字符串匹配失败&quot; : &quot;子字符串在原串的位置：&quot; + r); &#125; /** * @param s 原字符串 * @param t 需要匹配的子字符串位置 */ public static int queryByBF(String s, String t) &#123; char[] a = s.toCharArray(); char[] b = t.toCharArray(); int i = 0, j = 0; while (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123; //比较字符 if (a[i] == b[j]) &#123; i++; j++; &#125; else &#123; //i后退重新匹配 i++; j = 0; &#125; &#125; if (j &gt;= t.length()) &#123; return i - t.length(); &#125; else &#123; //匹配失败 return 0; &#125; &#125;&#125; KMP算法KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"递归和分治","slug":"递归和分治","date":"2020-04-14T05:19:33.000Z","updated":"2020-05-07T11:06:29.922Z","comments":true,"path":"2020/04/14/递归和分治/","link":"","permalink":"/2020/04/14/递归和分治/","excerpt":"","text":"递归高级语言中，函数自己调用和调用其他函数并没有本质的不同，我们把一个直接调用自己或者通过一系列调用语句间接地调用自己的函数，称作递归函数。（ps：每个递归定义必须至少有一个条件，当满足这个条件时递归不再进行，即函数不再调用自身而是返回值） 斐波那契(Fibonacci)数列如果说兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔子都不会死去，能够一直干下去，那么一年以后可以繁殖多少对兔子呢？ 代码实现： 123456int Fib(int i)&#123; if( i &lt; 2 ) return i == 0 ? 0 : 1; return Fib(i-1) + Fib(i-2);&#125; 分治在遥远的周朝，人们受生产力水平所限，无法管理庞大的土地和众多的人民，因此采用了封邦建国的封建制度，把土地一层一层划分下去，以达到分而治之的目的，这也许是最古老的分治法了： 汉诺塔问题汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。 12345678910111213141516171819202122232425262728293031public class Hanoi &#123; /** * * @param n 盘子的个数 * @param a 原来的柱子 * @param b 中间辅助柱子 * @param c 最终到达的目标珠子 */ public void hanoi(int n, char a, char b, char c) &#123; if (n == 1) &#123; move(a, c); &#125; else &#123; //将n-1个盘子从a利用c移动到b盘子 hanoi(n - 1, a, c, b); //将第n个盘子从a移动到c move(a, c); //将n-1个盘子从b利用a移动到c hanoi(n - 1, b, a, c); &#125; &#125; // 移动盘子 private void move(char origin, char target) &#123; System.out.println(&quot;方向:&quot; + origin + &quot;---&gt;&quot; + target); &#125; public static void main(String[] args) &#123; Hanoi hanoi = new Hanoi(); hanoi.hanoi(3, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;); &#125;&#125; 快速排序找出第n大的值直尺八皇后问题","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"栈和队列","slug":"栈和队列","date":"2020-04-13T03:53:45.000Z","updated":"2020-05-07T11:08:01.069Z","comments":true,"path":"2020/04/13/栈和队列/","link":"","permalink":"/2020/04/13/栈和队列/","excerpt":"","text":"栈：栈(Stack)是一个后进先出(Last in first out LIFO)的线性表，要求只在表尾进行删除和插入操作了，栈的插入叫做进栈（进栈、压栈、入栈）、栈的删除叫出栈。 队列：队列(queue)是只允许在一端进行插入操作，而另一端进行删除操作的一种先进先出(First in First out FIFo)的线性表1.循环队列： 123456789101112131415161718192021222324252627282930public class CircleQueue&lt;E&gt; &#123; private Object q[]; private int head = 0; private int tail = 0; private int size; public CircleQueue(int size) &#123; this.size = size; q = new Object[size]; &#125; public CircleQueue() &#123; this(10); &#125; public boolean inQueue(E e) &#123; //表示队列已经满了 if ((tail+1) % size == head) return false; q[tail] = e; tail = (tail + 1) % size; return true; &#125; public E outQueue() &#123; if (head == tail) return null; E o = (E) q[head]; head = (head + 1) % size; return o; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"线性表","slug":"线性表","date":"2020-04-08T12:49:40.000Z","updated":"2020-05-07T11:07:52.322Z","comments":true,"path":"2020/04/08/线性表/","link":"","permalink":"/2020/04/08/线性表/","excerpt":"","text":"线性表理解为将数据结点用一根“线”连接起来存储在物理空间，线性表的数据元素一般具有相同的数据类型。大部分线性表中除了第一个元素（没有前驱）和最后一个元素（没有后继）其他元素都有前驱和后继（也就是各元素之间是一对一的关系）。 顺序存储结构（顺序表） 顺序存储结构就是数据是用一块完整的物理空间来连续存储数据，一般它的大小是固定的。优点：物理空间利用率高，增查效率高。缺点：插入和删除效率低，每次都需要移动目标元素后面的所有数据元素，由于它的length是提前分配固定好不能扩容，会发生存储溢出。 链式存储结构链式存储结构中数据元素的存储方式在物理空间中是随机的，数据结点氛围数据域和指针域，数据域存储数据元素，指针域来关联起来数据结点形成链。链式存储结构一般有单链表、双向链表和循环链表。 单链表 题目：找到单链表倒数第n个节点，保证链表中节点的最少数量为n。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for ListNode. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; * &#125; */ public class Solution &#123; /* * @param head: The first node of linked list. * @param n: An integer * @return: Nth to last node of a singly linked list. */ public ListNode nthToLast(ListNode head, int n) &#123; // write your code here ArrayList&lt;ListNode&gt; list=new ArrayList&lt;&gt;(); if (head!=null)&#123; list.add(head); &#125; else&#123; return head; &#125; while(head.next!=null)&#123; list.add(0,head.next); head=head.next; &#125; ListNode targetNode=list.get(n-1); return targetNode; &#125;&#125; 双向链表双向链表是每个数据结点都有两个指针，分别指向相邻的前驱结点和后继结点，可以方便的访问某个结点的前驱结点和后继结点，存储上会相对多占用一些空间。 代码实现 1 静态链表静态链表就是用数组来实现链式存储结构，所以它的长度是初始化的时候固定分配的定长。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197 public class StaticList &#123; public static void main(String[] args) &#123; run(); &#125; private static void run() &#123; StcList list = new StcList&lt;CharSequence&gt;(); System.out.println(&quot;顺序新增前：&quot;); list.printAll(); System.out.println(&quot;顺序新增后：&quot;); list.add(&quot;A&quot;); list.add(&quot;B&quot;); list.add(&quot;C&quot;); list.add(&quot;E&quot;); list.insert(&quot;D&quot;, 3); list.delete(2); list.printAll(); &#125; //存储结构 public static class StaticListNode&lt;E&gt; &#123; private E data; private int cursor; public StaticListNode(E data, int cursor) &#123; this.data = data; this.cursor = cursor; &#125; public E getData() &#123; return data; &#125; public void setData(E data) &#123; this.data = data; &#125; public int getCursor() &#123; return cursor; &#125; public void setCursor(int cursor) &#123; this.cursor = cursor; &#125; &#125; static class StcList&lt;E&gt; &#123; private static final int MAX_SIZE = 10; StaticListNode&lt;E&gt;[] nodes = new StaticListNode[MAX_SIZE]; public StcList() &#123; initList(nodes, nodes.length); &#125; //初始化备用链表 private void initList(StaticListNode[] nodes, int maxSize) &#123; for (int i = 0; i &lt; maxSize; i++) &#123; nodes[i] = new StaticListNode(null, i + 1); &#125; //将最后一个数据元素的游标指向第一个有值元素 nodes[maxSize - 1] = new StaticListNode(null, 0); &#125; public void printAll() &#123; for (int i = 0; i &lt; nodes.length; i++) &#123; System.out.print(nodes[i].getCursor()); System.out.print(&quot;:&quot;); System.out.print(nodes[i].getData()); System.out.print(&quot;:&quot;); System.out.print(i); System.out.print(&quot;|&quot;); &#125; System.out.println(); &#125; /** * 查找当前备用链表的头的 */ private void findHead() &#123; &#125; /** * 分配空间 分配空间的元素下标 * * @return 0分配失败 */ private int mallocArry() &#123; int index = 0; if (nodes[0].cursor &gt; 0) &#123; index = nodes[0].cursor; nodes[0].cursor = nodes[index].cursor; &#125; return index; &#125; //顺序新增元素 public boolean add(E e) &#123; if (e == null) &#123; System.out.println(&quot;新增失败&quot;); return false; &#125; //不等于零说明链表容量没用完，可以新增 int currentIndex = nodes[0].getCursor(); if (currentIndex &gt; 0) &#123; //当前空元素下标 nodes[currentIndex].setData(e); nodes[0].setCursor(nodes[currentIndex].getCursor());// nodes[currentIndex].setCursor(0); return true; &#125; System.out.println(&quot;新增失败&quot;); return false; &#125; /** * @param e 要插入的数据 * @param index 表示要插入的链中的位置 * @return true插入成功 */ //新增元素 public boolean insert(E e, int index) &#123; if (e == null || index &lt; 0 || index &gt; MAX_SIZE - 1) &#123; System.out.println(&quot;插入元素失败&quot;); return false; &#125; //不等于零说明链表容量没用完，可以新增 int currentIndex = nodes[0].getCursor(); if (currentIndex &gt; 0) &#123; //查找对应的位置 int k = 1; for (int i = 0; i &lt; index - 1; i++) &#123; k = nodes[k].cursor; &#125; //要插入位置记录的游标 int insertCursor = nodes[k].getCursor(); //申请分配的空间的下标 int i = mallocArry(); //插入位置的游标连接到新插入元素 nodes[k].setCursor(i); //新插入元素的游标连接之前插入位置记录的游标 nodes[i].cursor = insertCursor; nodes[i].data = e; return true; &#125; System.out.println(&quot;插入元素失败&quot;); return false; &#125; public boolean delete(int index) &#123; //不等于零说明链表容量没用完，可以新增 int currentEmptyIndex = nodes[0].getCursor(); if (currentEmptyIndex &gt; 0) &#123; //查找前一个的位置 int k = 1; for (int i = 1; i &lt; index - 1; i++) &#123; k = nodes[k].cursor; &#125; int currentIndex = nodes[k].cursor; int nextIndex = nodes[currentIndex].cursor; nodes[k].cursor = nextIndex; //将删除的结点连接到备用链表 free(currentIndex); return true; &#125; else &#123; System.out.println(&quot;删除元素失败&quot;); return false; &#125; &#125; private void free(int i) &#123; nodes[i].cursor=nodes[0].cursor; nodes[0].cursor=i; nodes[i].data = null; &#125; &#125;&#125; 循环链表 有环 循环链表的特点是最后一个结点的指针指向头结点，使整个链表形成环。 空链的判断条件：head==head-&gt;next;rear==rear-&gt;next; 约瑟夫问题 问题描述：N个人围成一个圈，从第一个开始报数，第M个人将被杀掉，最后只剩一个，其他都被杀掉。 循环链表的实现方式就是通过遍历元素，指针移动M位删除该元素，知道剩余一个元素。数学推导方式是发现最终获胜的元素下标是在每一轮“杀人”过程中移动M位从而得到公式：f(N,M)=(f(N−1,M)+M)。 代码实现： 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int n, m, i, winner = 0; printf (&quot;N M = &quot;); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (i = 2; i &lt;= n; i++) &#123; //i是每阶约瑟夫环的人数 winner = (winner + m) % i; &#125; //编号是从零开始，这里加1变成符合习惯的计数 printf (&quot;\\nThe winner is %d\\n&quot;, (winner +1)); &#125; 魔术师发牌问题 问题描述：魔术师手中有A到K十三张黑桃扑克牌，表演前魔术师已经按照一定的顺序叠放好，表演过程：开始，魔术师数1将最上面的那张翻过来，是黑桃A，将其放在桌面上；第二次，魔术师数1、2，将第一张牌放在所有牌最下面，将第二张牌翻转过来，第二张牌正好是黑桃2；第三次，魔术师数1、2、3，将第一、二张牌按照顺序放在所有牌最下面，将第三张牌翻转过来，第三张牌正好是黑桃3；…知道所有牌都翻转过来，顺序刚好是A、2、3…K，现在要知道魔术师在翻牌前叠放的13张牌的顺序。 代码实现 1 拉丁方阵问题 问题描述：拉丁方阵是一种n×n的方阵，方阵中恰有n种不同的元素，每种元素恰有n个，并且每种元素在一行和一列中 恰好出现一次。 特点：每一行除了开始的数递进一位外，其余的数都是按照顺序排列，递进的数排在后面，因此使用循环链表解决。 代码实现 1","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"时间复杂度和空间复杂度","slug":"时间复杂度和空间复杂度","date":"2020-04-07T13:24:37.000Z","updated":"2020-05-07T11:07:22.225Z","comments":true,"path":"2020/04/07/时间复杂度和空间复杂度/","link":"","permalink":"/2020/04/07/时间复杂度和空间复杂度/","excerpt":"","text":"时间复杂度：执行算法所需要的时间 空间复杂度：执行算法所需要的内存空间 时间复杂度的定义：一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得T(n)/f(n)的极限值（当n趋近于无穷大时）为不等于零的常数，则称f(n)是T(n)的同数量级函数 通常将O(1)、O(n)、O(logn)、O(n2)等分别叫做常量阶、线性阶、对数阶、平方阶等 推导大O阶方法：1.用常数1取代运行时间中的所有加法常数；2.修改后的运行次数函数中，值保留最高阶项；3.如果最高阶向存在且不是1，则去除与这个项相乘的常数 常数阶O(1)： 123int sum=0，n=100；sum=（1+n）*n/2;System.out.println(sum); 线性阶O(n): 123for(int i=0;i&lt;n;i++)&#123;//O(1)的算法&#125; 对数阶O(logn): 12345int num=1;while(num&lt;n)&#123;num=num*2;//O(1)的算法&#125; 平方阶O(n^2): 12345for(int i=0;i&lt;n;i++)&#123; for(int j=i;j++)&#123; //O(1)的算法 &#125;&#125; 常用的时间复杂度按照耗费的时间从小到大依次是： O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"/tags/数据结构与算法/"}]},{"title":"面试积累","slug":"面试积累","date":"2020-02-05T06:20:52.000Z","updated":"2020-04-30T02:02:31.849Z","comments":true,"path":"2020/02/05/面试积累/","link":"","permalink":"/2020/02/05/面试积累/","excerpt":"","text":"要求： 薪酬结构 五险一金（全额，非全额要在基础薪资上调整） 技术团队规模 上下班时间 单双休 加班情况 人员配置 发版频率 绩效 年终奖 其他福利 餐补 车补贴 房补贴 项目经验：遇到了什么困难怎么解决的 直播 做了两方面的隔离，一是与其他业务模块的解耦 利用中间控制层 直播模块提供出对其他业务场景的依赖需求 其他业务模块提供这些能力给直播；二是把直播内部分为业务表现层和三方依赖层 具体做法是把三方直播依赖沉淀到baseview 把业务层需要的能力通过统一能力管理输出 （主要是直播画面能力控制和自定义消息协议的控制） 首页 动画控件 级联viewtab java基础： 同步锁同步锁的原理： Arraylist和LinklistArrayList是一个数组实现了RandomAccess接口可以随机访问元素，增删速度相对慢；LinkList是链表，只能顺序访问元素，增删快 线程和进程 位运算常见十进制D、二进制B、八进制Q和十六进制H（逢几进1）n十进制向n进制转化：十进制转化为n进制时 十进制数一直除以n得余数 到一直不能整除为止，小数点部分是将小数部分乘以n 取整 然后小数部分继续乘以n 取整部分倒叙排序就是小数部分的值二进制转n进制：采用r（二进制和n进制之间的位数差 例如八进制是3合1、十六进制时4合1，如果是32进制就是 5合1）合1的方式，如果位数不够r位，整数部分向左补零，小数部分向右补零，然后按照案权展开相加即可得 线程安全 进程保活 HashMap原理 数据结构与算法： 时间复杂度、空间复杂度 网络： tcp的三次握手和四次挥手：第一次：c端发送连接请求 序列号seq=x SYN创建连接状态第二次：b端收到信息后 发送确认码ack=x+1 SYN=1第三次：c端收到后 http2.0 Android下网络优化方案 QUIC协议 Android基础：android sdk 三方库： eventbus原理利用反射触发事件函数的执行关键的一个键值对来存储数据 key是eventType（传递的时事件类型）线程模式 posting：处理函数看post在线程就在什么线程执行main：处理函数在主线程执行background：处理函数在子线程 post如果在主线程辉创建子线程 如果在子线程就直接在子线程触发处理async：新建子线程触发处理函数的执行 butterknife原理 okhttp rxjava retrofit Glide Fresco 三级缓冲7.","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"/tags/面试/"}]},{"title":"Android数据的持久化","slug":"Android数据的持久化","date":"2018-06-28T07:28:40.000Z","updated":"2020-05-07T11:08:53.408Z","comments":true,"path":"2018/06/28/Android数据的持久化/","link":"","permalink":"/2018/06/28/Android数据的持久化/","excerpt":"常见的存储的方式为SQlite数据存储、xml存储以及自定义数据格式的存储方式","text":"常见的存储的方式为SQlite数据存储、xml存储以及自定义数据格式的存储方式","categories":[{"name":"数据存储","slug":"数据存储","permalink":"/categories/数据存储/"}],"tags":[{"name":"Android 存储","slug":"Android-存储","permalink":"/tags/Android-存储/"}]},{"title":"android 中gradle依赖冲突解决","slug":"android-中gradle依赖冲突解决","date":"2017-11-24T07:00:34.000Z","updated":"2020-05-07T11:08:30.756Z","comments":true,"path":"2017/11/24/android-中gradle依赖冲突解决/","link":"","permalink":"/2017/11/24/android-中gradle依赖冲突解决/","excerpt":"","text":"android项目开发中经常会遇到库依赖异常，大多是版本依赖的冲突问题，说明下常见的版本依赖冲突解决方式 首页看下我们项目的依赖关系1./gradlew dependencies :app:dependencies :app表示依赖modulemac下运行可能人别不了命令行，运行+x gradlew ```添加权限1234567可以看到依赖结构是树状结构，各库下又依赖了android的官方提供的一些库，如果依赖的库不是太多的话，可以使用transitive参数，使得依赖库所需的依赖不直接使用，在依赖库的module中同一级上做依赖关系``` implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; compile (&apos;com.alibaba.android:vlayout:1.2.2@aar&apos;) &#123; transitive = false &#125; transitive为false表示单独依赖，true为默认树状依赖 这种解决方式只用于当前的依赖包只是版本导致的，且版本变动不大，起码它的代码package路径一致，如果差异很大可以指定依赖关系中特定包不包含到依赖中1234implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; compile (&apos;com.alibaba.android:vlayout:1.2.2@aar&apos;) &#123; exclude group: &apos;support-v4&apos; &#125;","categories":[],"tags":[{"name":"gradle","slug":"gradle","permalink":"/tags/gradle/"}]},{"title":"git基础知识","slug":"git基础知识","date":"2017-11-07T02:53:40.000Z","updated":"2017-11-16T05:57:00.390Z","comments":true,"path":"2017/11/07/git基础知识/","link":"","permalink":"/2017/11/07/git基础知识/","excerpt":"","text":"git基础知识——创建新的ssh key ssh-keygen -t rsa -C \"793021170@qq.com\"```1234------测试 ssh 链接 github```$ ssh -T git@git.oschina.net ——设置用户名、邮箱 git config --global user.name \"litchi\"```1```$ git config --global user.email &quot;793021170@qq.com&quot; ——提交到远程服务器 git remote add origin ssh://git@dev.lemote.com/rt4ls.git```1```$ git push origin master ——-本地库中缺少md文件时git pull --rebase origin master```1234567-------由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令```$ git push -u origin master ——-关联远程库git remote add origin git@server-name:path/repo-name.git```123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178git checkout master //进入master分支git checkout -b frommaster //以master为源创建分支frommastergit show # 显示某次提交的内容 git show $idgit co -- &lt;file&gt; # 抛弃工作区修改git co . # 抛弃工作区修改git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci &lt;file&gt; git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci -am &quot;some comments&quot;git ci --amend # 修改最后一次提交记录git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象git revert HEAD # 恢复最后一次提交的状态查看文件diffgit diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diffgit diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较git diff --staged # 比较暂存区和版本库差异git diff --cached # 比较暂存区和版本库差异git diff --stat # 仅仅比较统计信息查看提交记录git log git log &lt;file&gt; # 查看该文件每次提交记录git log -p &lt;file&gt; # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log --stat #查看提交统计信息tigMac上可以使用tig代替diff和log，brew install tigGit 本地分支管理查看、切换、创建和删除分支git br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br --merged # 查看已经被合并到当前分支的分支git br --no-merged # 查看尚未被合并到当前分支的分支git co &lt;branch&gt; # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d &lt;branch&gt; # 删除某个分支git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebasegit merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; Git补丁管理(方便在多台机器上开发同步时用)git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch # 打补丁git apply --check ../sync.patch #测试补丁能否成功 Git暂存管理git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支Git远程仓库管理GitHubgit remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm &lt;repository&gt; # 删除远程仓库创建远程仓库git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支也可以命令设置跟踪远程库和本地库git branch --set-upstream master origin/mastergit branch --set-upstream develop origin/develop--------显示command的help```git help &lt;command&gt; # 异常处理：1.如果出现remote origin already exists.需要删除远程库后在执行git remote add origin 具体执行：git remote rm origin git remote add origin git@git.oschina.net:jichengliu/SilkMarke","categories":[],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}]},{"title":"设计模式之工厂模式","slug":"设计模式之工厂模式","date":"2017-11-06T03:10:35.000Z","updated":"2020-05-07T11:07:02.122Z","comments":true,"path":"2017/11/06/设计模式之工厂模式/","link":"","permalink":"/2017/11/06/设计模式之工厂模式/","excerpt":"","text":"设计模式之工厂模式前言最近在看设计模式相关的一些知识，看了一些感觉还是要做一些记录的，一方面用来记录当前情况下个人对设计模式的理解程度，使得这块知识更加深刻，另一方面也是方便把自己的一些拙见拿出来希望能够共同进步，得到众人的指正。 引入工厂模式应该说最常见的模式，看一些介绍模式的书里工厂模式基本都是第一个被提到的，它应用场景比较多，也容易被理解。它是名如其模式，先来分析下它的名字，“工厂”用来生产各种产品，我们可以直接通过工厂来获得需要的各种产品，而不需要来考虑其具体的实现，所谓的“工厂”就类似于“商店”，提供我们需要所需产品。那么“工厂”的产品是怎么样获得的呢，“工厂”会根据我们具体的需求来利用具体的“材料”来“生产”具体的产品，到这里来看图说话。 上图就是对上面文字的一个概括，这里先又了这个概念就OK了，下面深入到代码层面来说明。 代码实现这里用引入中最原始的提到的工厂、产品和消费者举例。例子在android studio中android项目中开发。 工厂、产品和消费者 创建一个工厂类(Factory),提供一个获得产品的方法 123456789101112131415161718192021222324public class Factory &#123; /** * 获得产品对象实例 * * @param clazz clazz * @param &lt;P extends BaseProduct&gt; p * @return p */ public static &lt;P extends BaseProduct&gt; P getProduct(Class&lt;P&gt; clazz) &#123; P p = null; try &#123; p = (P) Class.forName(clazz.getName()).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return p; &#125;&#125; 创建一个接口(IProduct)，商品类将实现produce()方法 12345public interface IProduct &#123; public BaseProduct produce();&#125; 分别创建商品类(BaseProduct、ProductOne、ProductTwo、ProductThree和ProductFour) 123456public abstract class BaseProduct implements IProduct &#123; public void makeBaseComponents() &#123; //制作基础组件 &#125;&#125; 123456789public class ProductOne extends BaseProduct implements IProduct &#123; @Override public BaseProduct produce() &#123; makeBaseComponents(); Log.d(\"ProductOne\", \"make ProductOne\"); return this; &#125;&#125; 123456789public class ProductTwo extends BaseProduct implements IProduct &#123; @Override public BaseProduct produce() &#123; makeBaseComponents(); Log.d(\"ProductTwo\", \"make ProductTwo\"); return this; &#125;&#125; 123456789public class ProductThree extends BaseProduct implements IProduct &#123; @Override public BaseProduct produce() &#123; makeBaseComponents(); Log.d(\"ProductThree\", \"make ProductThree\"); return this; &#125;&#125; 123456789public class ProductFour extends BaseProduct implements IProduct &#123; @Override public BaseProduct produce() &#123; makeBaseComponents(); Log.d(\"ProductFour\", \"make ProductFour\"); return this; &#125;&#125; 在MainActivity类中获得需要的商品类实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void onGetProduct(int productType) &#123; Class&lt;? extends BaseProduct&gt; clazz = null; switch (productType) &#123; case 1: clazz = ProductOne.class; break; case 2: clazz = ProductTwo.class; break; case 3: clazz = ProductThree.class; break; case 4: clazz = ProductFour.class; break; &#125; BaseProduct product = Factory.getProduct(clazz); Toast.makeText(this, product.produce(), Toast.LENGTH_LONG).show(); &#125; public void onGetProductThree(View view) &#123; onGetProduct(3); &#125; public void onGetProductTwo(View view) &#123; onGetProduct(2); &#125; public void onGetProductOne(View view) &#123; onGetProduct(1); &#125; public void onGetProductFour(View view) &#123; onGetProduct(4); &#125;&#125; 最终我们实现在activity中获得了产品的实例对象 github 为什么要用工厂模式在开发过程中常常会独立做一些模块供其他的开发者来用，这种情况下，其实对于其他的开发者来说要求在使用功能时尽量的简单、调用方便，他们不需要去了解里面的具体实现，只要简单调用就可以拿到对应的实例，这个时候对于工厂模式时一个可行的方案，当然在实际开发中可以会和其他的模式混用来达到效果，这个还要具问具析。对于我们可以在什么场景下利用工厂模式，这里列出一些它的利弊，以便在考虑使用时参考： 利: 多类型扩展好，如果新增了一种商品只要实现它的具体类和方法，即可根据类来获取其实例 具体实现是封闭的、不对外的 调用方便，可通过一个类型或者类名就可以获得具体实例 弊产品类创建方式单一，因为是通过类命来创建实例，这样创建不会像常见的直接new灵活不适合单一产品时使用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}]},{"title":"Markdown常用语法","slug":"Markdown常用语法","date":"2017-11-06T03:01:55.000Z","updated":"2017-11-07T04:49:11.000Z","comments":true,"path":"2017/11/06/Markdown常用语法/","link":"","permalink":"/2017/11/06/Markdown常用语法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"hexo command line","slug":"hexo-command-line","date":"2017-11-03T14:34:03.000Z","updated":"2020-02-05T06:21:38.195Z","comments":true,"path":"2017/11/03/hexo-command-line/","link":"","permalink":"/2017/11/03/hexo-command-line/","excerpt":"Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server","text":"Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"linux环境下jdk安装配置","slug":"linux环境下jdk安装配置","date":"2017-11-03T13:54:47.000Z","updated":"2017-11-03T14:46:49.000Z","comments":true,"path":"2017/11/03/linux环境下jdk安装配置/","link":"","permalink":"/2017/11/03/linux环境下jdk安装配置/","excerpt":"jdk下载 wget -O jdk-8u131-linux-x64.tar.gz jdk-8u131-linux-x64.tar.gzAuthParam=1499664230_984ba136862e0fd6281ac5bc2bee90e2 解压文件 tar xf jdk-8u131-linux-x64.tar.gz 创建要存放的目录并复制解压后的jdk文件到目录下","text":"jdk下载 wget -O jdk-8u131-linux-x64.tar.gz jdk-8u131-linux-x64.tar.gzAuthParam=1499664230_984ba136862e0fd6281ac5bc2bee90e2 解压文件 tar xf jdk-8u131-linux-x64.tar.gz 创建要存放的目录并复制解压后的jdk文件到目录下 修改配置文件，指向存放jdk的目录 cd etc(进入etc目录) vi profile（打开profile文件并修改环境变量 source profile（使文件生效) 测试 java -version 能够打印java 版本号信息就表示安装或升级成功","categories":[],"tags":[{"name":"java linux","slug":"java-linux","permalink":"/tags/java-linux/"}]},{"title":"linux环境下Jenkins搭建","slug":"linux环境下Jenkins搭建","date":"2017-11-03T13:46:06.000Z","updated":"2017-11-03T14:30:32.000Z","comments":true,"path":"2017/11/03/linux环境下Jenkins搭建/","link":"","permalink":"/2017/11/03/linux环境下Jenkins搭建/","excerpt":"安装java环境具体查看Linux java环境安装 安装tomcat从tomcat官网上下载最新的安装压缩包，注意区分选择不同操作环境下的压缩包.（Linux一般是 tar.gz，Windows一般用zip压缩包），选择对应的压缩包能保证系统可以直接解压，避免不支持时还需安转压缩工具。 下载压缩包 wget http://apache.fayea.com/tomcat/tomcat-8/v8.5.16/bin/apache-tomcat-8.5.16.tar.gz 解压压缩包 tar xf apache-tomcat-8.5.16.tar.gz 进入解压后的文件夹并将所有的复制到自己要安装的目录下 cd apache-tomcat-8.5.16 cp -rf ./* /usr/local/tomcat/","text":"安装java环境具体查看Linux java环境安装 安装tomcat从tomcat官网上下载最新的安装压缩包，注意区分选择不同操作环境下的压缩包.（Linux一般是 tar.gz，Windows一般用zip压缩包），选择对应的压缩包能保证系统可以直接解压，避免不支持时还需安转压缩工具。 下载压缩包 wget http://apache.fayea.com/tomcat/tomcat-8/v8.5.16/bin/apache-tomcat-8.5.16.tar.gz 解压压缩包 tar xf apache-tomcat-8.5.16.tar.gz 进入解压后的文件夹并将所有的复制到自己要安装的目录下 cd apache-tomcat-8.5.16 cp -rf ./* /usr/local/tomcat/ 安装SDK根据镜像下载sdk包即可，注意最新的sdk可能没有platform tools文件夹，可下在低版本的将platform tolls文件夹移动到最新的sdk文件夹下即可。 有一些插件也可以在没有sdk时自动在Jenkins搭建好后构建时自动下载sdk，如Android Emulator Plugin在配置好后它自己会根据配置参数自动去下载对应的sdk版本，这里后面会说到。 安装Jenkins从Jenkins官网下载并复制jenkins.war到tomcat目录下webapps下。 wget http://mirrors.jenkins.io/war/latest/jenkins.war cp ./jenkins.war /usr/local/tomcat/webapps 启动Tomcat在浏览器中打开http://网址:8080/jenkins/就可以打开Jenkins网页，接下来就可以创建项目，Jenkins玩起来了。 注： 如果要使用其他端口来使用Jenkins可以运行命令： java -jar jenkins.war --httpPort=端口号 java -jar jenkins.war --httpPort=8899 --daemon --logfile=日志路径/jenkins/jenkins.log(在后台运行) 在打开Jenkins网页前要保证对应的端口号可访问，aliyun要配置安全组，开放对应端口。","categories":[],"tags":[{"name":"Jenkins tomcat Linux","slug":"Jenkins-tomcat-Linux","permalink":"/tags/Jenkins-tomcat-Linux/"}]},{"title":"note","slug":"note","date":"2017-11-03T08:56:19.000Z","updated":"2017-12-04T03:24:38.104Z","comments":true,"path":"2017/11/03/note/","link":"","permalink":"/2017/11/03/note/","excerpt":"","text":"hexo官方教程地址http:https://hexo.io/zh-cn/ markdown 教程http:http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-8/","categories":[],"tags":[]},{"title":"Jenkins参数化构建android项目","slug":"Jenkins参数化构建android项目","date":"2017-11-03T01:59:37.000Z","updated":"2017-11-03T15:28:17.000Z","comments":true,"path":"2017/11/03/Jenkins参数化构建android项目/","link":"","permalink":"/2017/11/03/Jenkins参数化构建android项目/","excerpt":"达到的目标： 根据版本类型(release、beta or debug)、版本号、渠道、服务器请求地址等参数进行构建； 构建完成后显示相关构建信息； 展示apk下载二维码、下载地址供直接安装和下载apk 需要的插件： Dynamic Extended Choice Parameter plugin参数化选择需要 Description Setter Plugin构建的信息显示需要 GIt Plugingit 插件","text":"达到的目标： 根据版本类型(release、beta or debug)、版本号、渠道、服务器请求地址等参数进行构建； 构建完成后显示相关构建信息； 展示apk下载二维码、下载地址供直接安装和下载apk 需要的插件： Dynamic Extended Choice Parameter plugin参数化选择需要 Description Setter Plugin构建的信息显示需要 GIt Plugingit 插件 配置项目参数： 设置构建类型参数： 在general模块中复选‘参数化构建过程’，‘添加参数‘中选择’Choice Parameter‘; Name添加参数名，按照Jenkins已有的默认参数集来定义都以大写字母和下划线组成，例：ENVIRONMENT_BUILD，Choices输入item的选项，第一项会变成默认项。 设置列表型参数渠道、版本号、服务器请求地址等： 列表型参数和构建类型一样，设置name、Choices和Description。 配置git参数： 这里首先要保证我们的代码在每个版本都有独立的版本分支，通过不同的版本名来拉取对应的代码，来实现分版本构建。 配置构建命令参数： Tasks输入框输入构建命令行 clean assemble${PRODUCT_FLAVOR_BUILD}${ENVIRONMENT_BUILD}，${参数}表示参数应用，‘PRODUCT_FLAVOR_BUILD’是自定义的参数用来表示构建渠道，‘ENVIRONMENT_BUILD’表示构建类型。 配置构建后描述参数： 在‘构建’模块‘增加构建步骤’列表中选择‘set build description’，在Description输入框输入html代码，例如下，其中的‘${参数}’表示自定义的一些参数，用‘${参数}’来取对应的值。 请求环境：${JENKINS_SERVER_HOST}构建类型：${ENVIRONMENT_BUILD}构建渠道：${PRODUCT_FLAVOR_BUILD}构建版本：${APP_BUILD_VERSION}点击查看二维码点击下载apk 注：如果在构建完后显示还是按照文本显示的，修改一下系统管理／安全配置中‘Markup Formatter‘选择为Safe HTML，来支持html。 配置效果：","categories":[],"tags":[{"name":"Jenkins Android","slug":"Jenkins-Android","permalink":"/tags/Jenkins-Android/"}]}]}