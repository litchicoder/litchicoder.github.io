<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>“死锁”</title>
      <link href="/2020/05/11/%E2%80%9C%E6%AD%BB%E9%94%81%E2%80%9D/"/>
      <url>/2020/05/11/%E2%80%9C%E6%AD%BB%E9%94%81%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<ul><li>死锁的含义  </li></ul><p>死锁就是进程由于争夺资源造成的僵持状态，无外力作用下无法向前推进。</p><p><img src="dead_lock.jpg" alt=""></p><blockquote><p>图中资源-1被线程a持有、资源-2被线程b持有，同时线程a又请求获得资源-2，线程b又请求获得资源-1，这个时候线程a和线程b都处于等待状态无法向前执行就处于了死锁状态。</p></blockquote><ul><li>死锁的四个必要条件<br>1.互斥   一个资源在一段时间内只能被一个进程持有（占用）；<br>2.请求和持有  进程在请求资源阻塞时，对已获得资源保持持有不放；<br>3.不可抢占  进程已获得的资源在未使用完之前不能被其他进程抢占（剥夺），只能由自己释放；<br>4.循环等待 若干进程之间形成一种头尾相接的循环等待资源关系。<br><em>预防死锁的方法就是破坏死锁的四个必要条件</em></li><li>示例  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Package: com.litchi.demo.java</span><br><span class="line"> * Date:    2020/5/11</span><br><span class="line"> * Desc:    com.litchi.demo.java</span><br><span class="line"> *</span><br><span class="line"> * @author liujicheng</span><br><span class="line"> */</span><br><span class="line">class DeadLock &#123;</span><br><span class="line"></span><br><span class="line">    public static Object resourceOne = new Object();</span><br><span class="line">    public static Object resourceTwo = new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new java.lang.Thread(new RunnableA()).start();</span><br><span class="line">        new java.lang.Thread(new RunnableB()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static class RunnableA implements Runnable &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                synchronized (resourceOne) &#123;</span><br><span class="line">                    System.out.println(&quot;Thread A lock resourceOne&quot;);</span><br><span class="line"></span><br><span class="line">                    //停留5s让ThreadB锁住resourceTwo</span><br><span class="line">                    try &#123;</span><br><span class="line">                        java.lang.Thread.sleep(5000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    synchronized (resourceTwo) &#123;</span><br><span class="line">                        System.out.println(&quot;Thread A lock resourceTwo&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class RunnableB implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                synchronized (resourceTwo) &#123;</span><br><span class="line">                    System.out.println(&quot;Thread B lock resourceTwo&quot;);</span><br><span class="line"></span><br><span class="line">                    //停留5s让ThreadB锁住resourceTwo</span><br><span class="line">//                    try &#123;</span><br><span class="line">//                        java.lang.Thread.sleep(5000);</span><br><span class="line">//                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">//                        e.printStackTrace();</span><br><span class="line">//                    &#125;</span><br><span class="line"></span><br><span class="line">                    synchronized (resourceOne) &#123;</span><br><span class="line">                        System.out.println(&quot;Thread B lock resourceOne&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap原理</title>
      <link href="/2020/05/09/HashMap%E5%8E%9F%E7%90%86/"/>
      <url>/2020/05/09/HashMap%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>HashMap的内部存储是以数组+链表+红黑树为组合的复合结构，数组(table)中元素是Entry，键值对(key-value)中key的hashCode值决定了Entry元素在数组中的位置，当发生hash冲突时，相同hash值的Entry元素组成链表，链表的长度是有定长的（TREEIFY_THRESHOLD=8），当链表触发链表树化，就会变成树形结构。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The table, initialized on first use, and resized as</span><br><span class="line">     * necessary. When allocated, length is always a power of two.</span><br><span class="line">     * (We also tolerate length zero in some operations to allow</span><br><span class="line">     * bootstrapping mechanics that are currently not needed.)</span><br><span class="line">     */</span><br><span class="line">    transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><ul><li>hash()  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Computes key.hashCode() and spreads (XORs) higher bits of hash</span><br><span class="line">     * to lower.  Because the table uses power-of-two masking, sets of</span><br><span class="line">     * hashes that vary only in bits above the current mask will</span><br><span class="line">     * always collide. (Among known examples are sets of Float keys</span><br><span class="line">     * holding consecutive whole numbers in small tables.)  So we</span><br><span class="line">     * apply a transform that spreads the impact of higher bits</span><br><span class="line">     * downward. There is a tradeoff between speed, utility, and</span><br><span class="line">     * quality of bit-spreading. Because many common sets of hashes</span><br><span class="line">     * are already reasonably distributed (so don&apos;t benefit from</span><br><span class="line">     * spreading), and because we use trees to handle large sets of</span><br><span class="line">     * collisions in bins, we just XOR some shifted bits in the</span><br><span class="line">     * cheapest possible way to reduce systematic lossage, as well as</span><br><span class="line">     * to incorporate impact of the highest bits that would otherwise</span><br><span class="line">     * never be used in index calculations because of table bounds.</span><br><span class="line">     * </span><br><span class="line">     * 计算key.hashCode()并且移动高位到低位。由于数组使用2的幂次表示，变化仅仅在hash集合       </span><br><span class="line">     * 的上方中这将总是发生碰撞（这其中的例子是Float的key集合在小的table中保持连续的数    </span><br><span class="line">     * 字），所以我们应用高位向下移动的影响来作为转化。在速度、实用和为扩展上需要权衡，由于</span><br><span class="line">     * 许多哈希集已经合理的分布（所以无需从移动位中受益），并且因为我们使用了树来处理容器中</span><br><span class="line">     * 更大的冲突，因此我们仅以最简答单的方式对一些以为后的微bit进行XOR，以减少系统损耗，</span><br><span class="line">     * 以及最高位的影响，否则由于table番位的限制，这些高位将永远不会在索引计算中使用。</span><br><span class="line">     */</span><br><span class="line">    static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到hash方法中将Object key计算出的hashCode右移了16位，这里的原因官方注释中已经很明了，这样做是为了将高位的信息在hash值进行计算索引中降低冲突的概率，因为在一些hash中低位可能会相同，所以这里移位来使得hash更加分布均匀。  </p><ul><li>构造函数  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span><br><span class="line">   * capacity and load factor.</span><br><span class="line">   *</span><br><span class="line">   * @param  initialCapacity the initial capacity</span><br><span class="line">   * @param  loadFactor      the load factor</span><br><span class="line">   * @throws IllegalArgumentException if the initial capacity is negative</span><br><span class="line">   *         or the load factor is nonpositive</span><br><span class="line">   */</span><br><span class="line">  public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">      if (initialCapacity &lt; 0)</span><br><span class="line">          throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">          throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">      this.loadFactor = loadFactor;</span><br><span class="line">      this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span><br><span class="line">   * capacity and the default load factor (0.75).</span><br><span class="line">   *</span><br><span class="line">   * @param  initialCapacity the initial capacity.</span><br><span class="line">   * @throws IllegalArgumentException if the initial capacity is negative.</span><br><span class="line">   */</span><br><span class="line">  public HashMap(int initialCapacity) &#123;</span><br><span class="line">      this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span><br><span class="line">   * (16) and the default load factor (0.75).</span><br><span class="line">   */</span><br><span class="line">  public HashMap() &#123;</span><br><span class="line">      this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span><br><span class="line">   * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span><br><span class="line">   * default load factor (0.75) and an initial capacity sufficient to</span><br><span class="line">   * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span><br><span class="line">   *</span><br><span class="line">   * @param   m the map whose mappings are to be placed in this map</span><br><span class="line">   * @throws  NullPointerException if the specified map is null</span><br><span class="line">   */</span><br><span class="line">  public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">      this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">      putMapEntries(m, false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看到HashMap1.8中四个构造函数，主要就看第一个，两个入参initialCapacity是table数组的大小，默认值DEFAULT_INITIAL_CAPACITY=16，loadFactor负载因子用来控制扩容的阈值默认DEFAULT_LOAD_FACTOR=0.75f，就是当table的threshold到达0.75时触发table扩容。这里tableSizeFor(initialCapacity)方法是利用传入的初始化table容量转为2的幂次数。  </p><ul><li>put方法  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Associates the specified value with the specified key in this map.</span><br><span class="line">     * If the map previously contained a mapping for the key, the old</span><br><span class="line">     * value is replaced.</span><br><span class="line">     *</span><br><span class="line">     * @param key key with which the specified value is to be associated</span><br><span class="line">     * @param value value to be associated with the specified key</span><br><span class="line">     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span><br><span class="line">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span><br><span class="line">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span><br><span class="line">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span><br><span class="line">     */</span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Implements Map.put and related methods</span><br><span class="line">     *</span><br><span class="line">     * @param hash hash for key</span><br><span class="line">     * @param key the key</span><br><span class="line">     * @param value the value to put</span><br><span class="line">     * @param onlyIfAbsent if true, don&apos;t change existing value</span><br><span class="line">     * @param evict if false, the table is in creation mode.</span><br><span class="line">     * @return previous value, or null if none</span><br><span class="line">     */</span><br><span class="line">    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)//（1）</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)//（2）</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;//（3）</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))//（4）</span><br><span class="line">                e = p;</span><br><span class="line">            else if (p instanceof TreeNode)//（5）</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;//（6）</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))//（7）</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;//（8）</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;//（9）</span><br><span class="line">        if (++size &gt; threshold)//(10)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里主要看putVal()方法。<br>（1）这里第一个if判断table是否为空，为空就利用resize方法初始化；<br>（2）第二个if判断如果当前根据hash跟到的table索引下为空就直接将Node对象放入table中；<br>（3）else下是hash发生碰撞；<br>（4）首先第一个if判断的是如果NewNode和table中位置的Node hash值和key都相同就直接可以看作是同一个Node，这里还有个场景是否用新put的values覆盖老的value，onlyIfAbsent为false或者老的value为空就要覆盖掉老值；<br>（5）else if判断如果是一个树结点就调用putTreeVal插入元素；<br>（6）else下循环遍历将p添加到链表尾部，如果这时达到链表最大阈值就需要调用treeifyBin方法进行树化；<br>（7）如果已经在链表中就braek掉；<br>（8）这里判断是否需要覆盖老数据。<br>（9）modCount保证并发访问，这里的put方法是线程不安全的，所以当modCount发现变化不一致就会抛出ConcurrentModificationException。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  final class KeySet extends AbstractSet&lt;K&gt; &#123;</span><br><span class="line">        public final int size()                 &#123; return size; &#125;</span><br><span class="line">        public final void clear()               &#123; HashMap.this.clear(); &#125;</span><br><span class="line">        public final Iterator&lt;K&gt; iterator()     &#123; return new KeyIterator(); &#125;</span><br><span class="line">        public final boolean contains(Object o) &#123; return containsKey(o); &#125;</span><br><span class="line">        public final boolean remove(Object key) &#123;</span><br><span class="line">            return removeNode(hash(key), key, null, false, true) != null;</span><br><span class="line">        &#125;</span><br><span class="line">        public final Spliterator&lt;K&gt; spliterator() &#123;</span><br><span class="line">            return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        public final void forEach(Consumer&lt;? super K&gt; action) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            if (action == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</span><br><span class="line">                int mc = modCount;</span><br><span class="line">                for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</span><br><span class="line">                        action.accept(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                if (modCount != mc)</span><br><span class="line">                    throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line">(10)这里对table扩容。</span><br><span class="line"></span><br><span class="line">* resize方法</span><br></pre></td></tr></table></figure><p>/**</p><pre><code> * Initializes or doubles table size.  If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table *  * 初始化或增加成两倍大的table，如果为空，则根据字段阈值中保持的初始容量目标进行分配。 * 否则，因为我们使用的是2的幂，所以每个bin中的元素必须保持相同的索引，或者在新表中以2 * 的幂偏移。 */final Node&lt;K,V&gt;[] resize() {    Node&lt;K,V&gt;[] oldTab = table;    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    if (oldCap &gt; 0) {        if (oldCap &gt;= MAXIMUM_CAPACITY) {            threshold = Integer.MAX_VALUE;            return oldTab;        }        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1; // double threshold    }    else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    else {               // zero initial threshold signifies using defaults        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    }    if (newThr == 0) {        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    }    threshold = newThr;    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab;    if (oldTab != null) {        for (int j = 0; j &lt; oldCap; ++j) {//（1）            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) {                oldTab[j] = null;                if (e.next == null)                    newTab[e.hash &amp; (newCap - 1)] = e;                else if (e instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else { // preserve order                //（2）                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    do {                        next = e.next;                        if ((e.hash &amp; oldCap) == 0) {                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        }                        else {                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        }                    } while ((e = next) != null);                    if (loTail != null) {                        loTail.next = null;                        newTab[j] = loHead;                    }                    if (hiTail != null) {                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    }                }            }        }    }    return newTab;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">上面的代码基本都很好理解的，这里主要说两个点：  </span><br><span class="line">（1）这个位置是table变成两倍table的元素移动的操作，e.nex=null说明它就是一个元素不存在链和树直接根据e.hash &amp; (newCap - 1)计算出它在新table中的位置并赋值；如果是树通过split方法复制树；  </span><br><span class="line">（2）这里比较重要的操作。这里是链表复制的过程，这里链表上的Node位置有两个场景，一种是不需要移动的Node形成链表还在老的index下，另一种是需要我们移动位置的Node形成新的链表复制到新的index下。*这里为什么会有这个操作，因为index值的确定是根据Node.hash和cap-1取与获得的，那么在变成两倍table后讲道理每一个index都需要重新取计算，但是这里观察变成两倍table的原理其实每次threshold&lt;&lt;1（也就是二进制高位变成1），那么这样Node.hash和cap-1取与过程中发生变化的就只有高位是1的所以这里(e.hash &amp; oldCap) == 0表示在变成两倍table后index不需要变化，如果需要变化那么index=老idnex+oldCap。*  </span><br><span class="line"></span><br><span class="line">![](hashmap_resize.jpg)</span><br><span class="line">&lt;!--你好啊--&gt;</span><br><span class="line"></span><br><span class="line">* get方法</span><br></pre></td></tr></table></figure><p>/**</p><pre><code> * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * {@code k} to a value {@code v} such that {@code (key==null ? k==null : * key.equals(k))}, then this method returns {@code v}; otherwise * it returns {@code null}.  (There can be at most one such mapping.) * * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt; * indicate that the map contains no mapping for the key; it&apos;s also * possible that the map explicitly maps the key to {@code null}. * The {@link #containsKey containsKey} operation may be used to * distinguish these two cases. * * @see #put(Object, Object) */public V get(Object key) {    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? null : e.value;}</code></pre><p>/**</p><pre><code> * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) {        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        if ((e = first.next) != null) {            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            do {                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            } while ((e = e.next) != null);        }    }    return null;}</code></pre><p><code>`</code></p><p>get方法相对简单直接通过key和hash取查找元素，如果是table中的first直接返回如果是tree从tree遍历g得到，如果是链表遍历拿到。  </p><ul><li>总结<br><em>hash()方法的关键是高位右移的操作，目的是为了使得hash趋于均匀分布，避免hash冲突（碰撞），在与table.length取与获得index时尽降低形成链</em><br><em>put()方法完成table创建和初始化和新增Node，新增Node分三个场景直接放置在table[index]位置；形成链表的插入链表中，链表达到阈值形成红黑树</em><br><em>resize()方法完成 两倍扩展以及扩展后的Node的重新放置，这里重要是巧妙的使用 (e.hash &amp; oldCap) == 0来作为是否将老链表数据分开放置的处理，利用扩容和2的幂的关系进行操作</em></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时数据区</title>
      <link href="/2020/05/08/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
      <url>/2020/05/08/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>运行时数据区也就是JVM运行时的内存区域，这里主要划分为堆区、方法区、虚拟机栈、本地方法栈和PC寄存器。<br><img src="vm_stack.jpg" alt="">  </p><ul><li>堆区：<br>堆区是这其中最大的一块区域，保存几乎所有创建出来的对象实例，这块区域是线程共享的，堆区是垃圾回收的主要区域，因此也叫“GC堆”,在GC回收时采用分代收集算法，所以堆区分为新生代和老年代。堆区在物理上时不连续的，在逻辑中看作是连续的。在堆区分配内存给对象实例时如果内存不足，会抛出OutOfMemoryError异常。<br><em>Minor Gc和Major Gc(Full GC)</em>：Minor Gc是指新生代垃圾回收的动作，新创建的对象都会在新生代，所以Minor Gc相对频繁，回收速度相对也快；Major Gc(Full GC)时老年代的垃圾回收动作，Major Gc(Full GC)回收频率较慢，速度也较慢。  </li><li>方法区：<br>方法区线程共享，方法去存储类的信息、常量、静态变量以及<em>运行时常量池</em>(Runtime Constant Pool:常量不一定只能在编译期产生，运行期间也可能产生新的常量，这些常量被放在运行时常量池中，例如通过String.intern()将String放入常量池)。  </li><li>虚拟机栈和本地方法栈：<br><em>虚拟机栈</em>每个线程在创建时都会创建一个虚拟机栈，内部是由一个个的栈帧组成(Stack Frame)，一个栈帧就对应一个Java方法调用。<br>它主管Java程序的运行，保存方法的局部变量（8中基本数据类型、对象引用地址）、部分结果，并参与方法的调用和返回。<br>虚拟机栈的大小允许是固定的或者是动态的：  <blockquote><p>虚拟机栈大小固定情况下，如果线程请求分配的栈容量超过了虚拟机栈允许的最大容量就会报StackOverFlowError异常。<br>虚拟机栈大小动态的情况下，当虚拟机栈请求扩展容量而这时内存不足JVM就会抛出OutOfMemoryError异常，同样在创建线程时如果没有足够的内存空间提供给虚拟机栈，也会报OutOfMemoryError异常。  </p></blockquote></li></ul><p>每个栈帧包含：局部变量表、操作数栈、动态链接和方法返回地址。<br>1.局部变量表：<br><em>局部变量表存储方法参数和定义在方法内的局部变量</em>，局部变量表的存储单位时slot（变量槽），存储的数据类型包括基本数据类型、引用数据类型和返回地址类型。  </p><blockquote><p><em>局部变量表的大小是在编译期间就确定下来的。</em>  </p></blockquote><p>2.操作数栈：<br>操作数栈在方法执行的过程中根据字节码指令写或者提取数据（入栈和出栈）。<br><img src="operate_stack.jpg" alt=""><br>3.动态链接（Dynamic Linking）：<br><em>即指向运行时常量池的引用</em>它是栈帧内部指向运行时常量池中该栈帧所属方法的引用。动态链接的作用是为将符号应用转换为调用方法的直接引用。<br>4.方法返回地址（return address）：<br>方法返回地址存放调用该方法的PC寄存器的值。方法退出救市栈帧出栈的过程，此时需要恢复上层方法的局部变量表、操作数栈，将返回值压入调用者的操作数栈中，更新PC寄存器，调用者继续执行接下来的指令。<br><em>异常完成退出不会给上层调用者产生任何返回值</em>  </p><blockquote><p>本地方法栈结构与Java虚拟机栈相同，只是它服务的是本地方法，也有些虚拟机中将本地方法栈和Java虚拟机栈合二为一。  </p></blockquote><ul><li>PC寄存器（Program Counter Register）：<br><em>PC寄存器</em>用来存放下一行执行指令的地址，由执行引擎读取下条指令。根据是一块很小的内存区域，每个线程都有自己的PC寄存器，它是线程私有的区域，生命周期与线程的生命周期保持一致。PC寄存器是JVM规范中唯一一个不会发生OutOfMemory的区域，也不存在GC。PC寄存器可以保证线程切换时指令不会发生异常，在来回切换后可以回到切换前执行位置继续执行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于作者</title>
      <link href="/2020/05/07/%E5%85%B3%E4%BA%8E%E4%BD%9C%E8%80%85/"/>
      <url>/2020/05/07/%E5%85%B3%E4%BA%8E%E4%BD%9C%E8%80%85/</url>
      
        <content type="html"><![CDATA[<ul><li>litchi</li><li>1992-05-20</li><li>浙江杭州</li><li>Android JAVA</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GC机制</title>
      <link href="/2020/05/07/GC%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/05/07/GC%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>垃圾回收机制是JVM持续运行的关键，当JVM在运行过程中会产生很多“无用”的对象，如果没有及时GC就会导致我们虚拟机运行效率的降低，从而引发系统的异常。在运行时数据区中程序计数器、虚拟机栈、本地方法栈是线程私有的，不需要进行垃圾回收。方法区和堆区线程共享需要进行垃圾回收，堆是Java虚拟机进行垃圾回收的主要场所，其次要场所是方法区。<br>垃圾回收分两步找到垃圾和回收垃圾，一般查找垃圾有两种方法引用计数法和可达性分析算法。<br><em>引用计数法</em>就是给每个创建的对象添加一个引用计数器，当有一地方引用它时引用计数器加1，当有引用消除时引用计数器减1。当引用计数器等于0时就表示该对象可收回。标记计数法存在的问题时当有两个或几个对象互相引用时，它们的引用计数器永远不会为0，就永远不会被回收。<br><em>可达性分析算法（根搜索算法）</em>以根对象作为根结点进行搜索，当有对象不可达时就认为该对象可回收，根对象一般指虚拟机栈中的引用对象、本地方法栈中JNI的引用对象、方法区中运行常量池中的引用对象、方法区中静态属性引用的对象、运行中的线程、由引导类加载器加载的对象、GC控制的对象。<br>垃圾回收算法有：<br>1.<em>标记-清除（mark–sweep）</em><br>标记所有需要回收的对象，之后统一回收。这是最基础的算法，后续的回收算法都是基于这个算法扩展的。缺点明显效率低，产生大量碎片。<br><img src="gc_mark_sweep.jpg" alt=""><br>2.<em>复制（copying）</em><br>将内存空间划分两块相等的区域，每次只使用其中的一块区域，垃圾回收时遍历正在使用的区域内对象，将正在使用的引用对象赋值到另一块区域。每次垃圾回收时只处理正在使用的对象，赋值成本低，赋值过去会进行整理，不存在内存碎片。缺点是需要双倍的内存空间，以空间换时间。<br><img src="gc_copying.jpg" alt=""><br>3.<em>标记-整理或压缩（mark–compact））</em><br>结合了复制和标记清除的优点，第一步标记所有需要回收的对象，第二部回收对象，并对存活对象进行整理（压缩）。<br><img src="gc_mark_compact.jpg" alt=""><br>4.<em>分代收集算法</em><br>根据对象生命周期的不同将对象分为新生代和老年代对象。新生代对象一般又分为Eden区(伊甸园)和两个Survivor区。新创建的u对象都在Eden区，当Eden区内存到达阈值就会出发Minor GC，这是就会把Eden区中的对象复制到其中一个Survivor区中，此时这些存活对象的生命存活计数会加1.这是Eden区空置，Eden区继续存放新创建的对象，当再次触发Minor Gc时，将此时Eden区的存活对象和之前一个Survivor区的存活对象复制到另外一个Survivor区中，同时它们的生命存活计数器加1，这个过程持续发生，当对象的存活计数器达到一定的阈值后触发“晋升”，新生代中的该对象就被放置到了老年代中。<br>老年代中的对象经过多次的GC就会是生命周期很长的对象。当老年代的内存达到阈值时触发Major GC，这是采用标记-整理或压缩（mark–compact）算法。<br><img src="gc_eden_survivor_minor_major.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM结构</title>
      <link href="/2020/05/02/JVM%E7%BB%93%E6%9E%84/"/>
      <url>/2020/05/02/JVM%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>JVM(JavaVirtualMachine，Java虚拟机)JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台（write once run anywhere）。JVM包含在JDK中的一部分。</p><p><img src="JVM.jpg" alt=""></p><ul><li>类加载器子系统<br>类加载器子系统主要负责将二进制字节码文件加载成JVM识别的数据结构，并对其文件进行规则校验和一些初始化工作。具体分为三个阶段loading、linking和initialization：<br>loading阶段将字节码文件加载到JVM中，这里有四类加载器来完成，Bootstrap ClassLoader(C++实现，加载Java核心类库/java_home/lib/rt.jar里的类集合)、Extension ClassLoader（加载/java_home/lib/ext里的类集合）、App ClassLoader(package下定义的类)、User define ClassLoader（自定义类加载器）；<br>linking阶段又分为三个阶段：verify、prepare、resolution，verify阶段验证Class文件是否符合JVM语法规则（具体包括类文件信息、元数据信息、字节码验证和符号引用验证）；prepare阶段为变量设置默认初始值，也就是0值，ps：int是0 String null；resolution阶段将符号引用转化为直接应用；<br>initialization阶段完成静态变量的显式赋值和静态代码块的执行。</li><li>运行时数据区<br>运行时数据区包括PC寄存器、虚拟机栈、本地方法栈、方法区、堆五部分组成。<br>1.PC寄存器保存下一条将要被执行指令的地址和线程一一对应，这样保证了再线程来回切换时可以回到之前执行的位置；<br>2.虚拟机栈用来描述java方法执行的内存模型，每个线程对应一个栈，栈内的栈帧对应java方法，栈帧结构又包括：局部变量表、操作数栈、动态链接和方法返回地址；<br>3.本地方法栈的功能和结构与虚拟机栈类似，区别在于它服务的对象是native方法；<br>4.方法区是一块线程共享的内存区域，保存类的版本/字段/方法/接口等描述信息以及常量、静态场景等，还有运行时常量池（Runtime Constant Pool）；<br>5.堆用来保存创建对象的主体，是最大的一块数据区，也是线程共享的内存区域。  </li><li>执行引擎<br>执行引擎是将JVM字节码指令转化为本地物理机可识别的机器指令执行，是JVM的核心部分之一。  </li><li>本地方法接口<br>本地接口的作用是融合不同的编程语言为java所用。</li><li>本地方法库<br>为本地方法提供依赖支持。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器子系统</title>
      <link href="/2020/04/26/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/04/26/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="classloader.jpg" alt=""></p><h3><span id="类加载过程包括加载load-链接linking和初始化init">类加载过程包括加载（load）、链接（linking）和初始化（init）</span></h3><ul><li>加载<br><strong><em>将字节码文件从数据源中加载到JVM内存中，生成JVM的认可的数据结构（也就是Class对象）</em></strong>，数据源可以是来自物理硬盘或者网络的jar文件、war文件、class文件等一些JVM可识别的文件格式结构（文件格式异常回报ClassFormatError）。  </li><li>链接<br>链接是类加载的核心部分，分三个步骤：验证、准备和解析<br>1.验证（Verify）：保证字节流信息符合JVM规范，避免恶意数据危害JVM的安全运行（异常抛出VerifyError）。<br>2.准备（Prepare）：为类变量分配内存和为变量设置初始值。<br>3.解析（Resolve）：将符号应用转换为直接应用，符号应用就是一组符号来描述所应用的目标，直接应用就是直接指向目标的指针或句柄。  </li><li>初始化<br>初始化主要是将静态变量赋值和执行静态代码块的一系列操作。</li></ul><h3><span id="双亲委派机制">双亲委派机制</span></h3><p><img src="parents_delegate.jpg" alt=""></p><p>双亲委派机制是在类加载过程中加载部分里的机制，加载器大致有启动类加载器Bootstrap ClassLoader（加载核心的类）、扩展类加载器Extension ClassLoader（ext path下的类）和应用类加载器Application ClassLoader（自定义）。<br>在执行类加载请求时，子加载器会先委托父类加载器执行；如果父类加载器还存在父类加载器就继续委托，一次递归找到其顶部启动类加载器；如果启动类加载器可以完成任务则将结果返回，倘若启动类加载器不能完成任务这时一次再让子类加载器尝试加载，这个过程叫双亲委派机制。</p><h3><span id="双亲委派机制优点">双亲委派机制优点</span></h3><p>1.避免类重复加载<br>2.保护程序安全，防止核心API被篡改（java.lang.String）</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法</title>
      <link href="/2020/04/21/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2020/04/21/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>插值查找</li><li>黄金分割法</li><li>线性索引查找</li><li>二叉排序树</li><li>平衡二叉树</li><li>B树</li><li>散列表（哈希表）查找<br>*</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2020/04/17/%E5%9B%BE/"/>
      <url>/2020/04/17/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<ul><li>图的特点：<br>1.通常用V(Vertex)表示一组定点的集合；<br>2.通常用E(Edge)表示一组边的集合。</li><li>顶点：<br>图中的一个结点</li><li>图的边：<br>顶点和顶点间的连线，有向图中的边叫做弧</li><li>相邻顶点：<br>由一条边连接在一起的顶点</li><li>顶点的度：<br>相邻顶点的数量叫做顶点的度</li><li>连通图：<br>在无向图中，若任意两个顶点Vi与Vj都有路径相通，则称该无向图为连通图</li><li>强连通图：<br>在有向图中，若任意两个顶点Vi与Vj都有路径相通，则称该有向图为强连通图</li><li>连通网：<br>在连通图中，若图的边具有一定的意义，每一条边都有一个对应数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网</li><li>生成树：<br>一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则会形成环</li><li><p>图的深度优先遍历：<br>假设初始状态是图中所有顶点都未被访问，从图中某个顶点v出发，先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到；若此时还有剩余顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p></li><li><p>图的广度优先遍历：<br>假设从图中某个顶点v出发，在访问了顶点v之后依次访问顶点v的各个未曾访问过的邻接顶点，然后分别从这些邻接顶点再出发依次访问它们的邻接顶点，并使“先被访问的顶点的邻接顶点”先于“后被访问的顶点的邻接顶点”被访问，直到图中所有已被访问的顶点的邻接点都被访问到；若此时图中还有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p></li><li><p>最小生成树：<br>在连通网的所有生成树中，所有边的代价总和最小的生成树，称为最小生成树</p></li></ul><p>1.普里姆算法(Prim算法)：</p><p>描述：<br>1.定义一个加权连通图，其中顶点集合V、Vnew，Vnew是V的子集，边的集合E、Enew，Enew是E的子集；<br>2.初始化集合Vnew{x},x(起始点)是集合V中任意一结点，Enew{}；<br>3.从边的集合E中选取权值最小的边&lt;u, v&gt;(其中u是顶点集合Vnew的元素，v属于顶点集合V，而不在新顶点集合Vnew中。若权值相同时，任意取值)；<br>4.将v加入新顶点集合Vnew，将边&lt;u, v&gt;加入新边集合Enew中；<br>5.重复操作3和4步骤 ，知道Vnew=V时，输出集合Vnew和Enew，Vnew和Enew即是来描述该加权连通图的最小生成树。<br>代码实现： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"> static class GraphMatrix &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 边的数量</span><br><span class="line">         */</span><br><span class="line">        private int edgeNum;</span><br><span class="line">        /**</span><br><span class="line">         * 顶点集合</span><br><span class="line">         */</span><br><span class="line">        private char[] vertex;</span><br><span class="line">        /**</span><br><span class="line">         * 邻接矩阵</span><br><span class="line">         */</span><br><span class="line">        private int[][] matrix;</span><br><span class="line"></span><br><span class="line">        public GraphMatrix(char[] vertex, int[][] matrix) &#123;</span><br><span class="line">            this.vertex = vertex;</span><br><span class="line">            this.matrix = matrix;</span><br><span class="line">            getEdgeNum();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void getEdgeNum() &#123;</span><br><span class="line">            int length = vertex.length;</span><br><span class="line">            for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">                for (int j = i + 1; j &lt; length; j++) &#123;</span><br><span class="line">                    //矩阵值等于Integer.MAX_VALUE表示不相邻，等于0是自己到自己</span><br><span class="line">                    if (matrix[i][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                        edgeNum++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * print matrix</span><br><span class="line">         */</span><br><span class="line">        private void printMatrix() &#123;</span><br><span class="line">            System.out.println(&quot;矩阵:&quot;);</span><br><span class="line">            for (int[] m : matrix) &#123;</span><br><span class="line">                for (int c : m) &#123;</span><br><span class="line">                    System.out.print(c + &quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 获取字符在结点里的位置</span><br><span class="line">         *</span><br><span class="line">         * @param c 字符</span><br><span class="line">         * @return 返回-1没该字符，其他位置</span><br><span class="line">         */</span><br><span class="line">        private int getVertexPosition(char c) &#123;</span><br><span class="line">            for (int i = 0; i &lt; vertex.length; i++) &#123;</span><br><span class="line">                if (c == vertex[i]) &#123;</span><br><span class="line">                    return i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 输入开始顶点位置</span><br><span class="line">         *</span><br><span class="line">         * @param x 开始顶点位置</span><br><span class="line">         */</span><br><span class="line">        public void prime(int x) &#123;</span><br><span class="line">            int num = vertex.length;</span><br><span class="line">            //邻边权重</span><br><span class="line">            int[] weights = new int[num];</span><br><span class="line">            //prime最小生成树结果</span><br><span class="line">            char[] result = new char[num];</span><br><span class="line">            //result当前索引</span><br><span class="line">            int index = 0;</span><br><span class="line"></span><br><span class="line">            //复制第一个顶点值</span><br><span class="line">            result[index] = vertex[x];</span><br><span class="line">            index++;</span><br><span class="line"></span><br><span class="line">            //init weight 找到顶点相邻边的权重赋值weights[i]</span><br><span class="line">            for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">                weights[i] = matrix[x][i];</span><br><span class="line">            &#125;</span><br><span class="line">            weights[x] = 0;</span><br><span class="line"></span><br><span class="line">            //循环遍历娶到最短权重值添加到result中</span><br><span class="line">            for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">                if (x == i) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                int minWeight = Integer.MAX_VALUE;</span><br><span class="line">                int minWeightIndex = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                for (int j = 0; j &lt; num; j++) &#123;</span><br><span class="line">                    if (weights[j] != 0 &amp;&amp; weights[j] &lt; minWeight) &#123;</span><br><span class="line">                        minWeight = weights[j];</span><br><span class="line">                        minWeightIndex = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //保存最短权重顶点</span><br><span class="line">                result[index] = vertex[minWeightIndex];</span><br><span class="line">                index++;</span><br><span class="line">                weights[minWeightIndex] = 0;</span><br><span class="line"></span><br><span class="line">                for (int j = 0; j &lt; num; j++) &#123;</span><br><span class="line">                    if (weights[j] != 0 &amp;&amp; matrix[minWeightIndex][j] &lt; weights[j]) &#123;</span><br><span class="line">                        weights[j] = matrix[minWeightIndex][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //计算最小生成树的权重</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int i = 1; i &lt; index; i++) &#123;</span><br><span class="line">                int min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">                int n = getVertexPosition(result[i]);</span><br><span class="line">                //求当前节点到上面其他节点的最小值</span><br><span class="line">                for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                    int m = getVertexPosition(result[j]);</span><br><span class="line">                    if (matrix[m][n] &lt; min) &#123;</span><br><span class="line">                        min = matrix[m][n];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                sum += min;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //打印最小生成树</span><br><span class="line">            System.out.printf(&quot;PRIME(%c):&quot;, vertex[x]);</span><br><span class="line">            for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">                System.out.printf(&quot;%c &quot;, result[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.printf(&quot;权重：%d&quot;, sum);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">2.克鲁斯卡尔算法(Kruskal算法)：</span><br><span class="line"></span><br><span class="line">描述：  </span><br><span class="line">首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。  </span><br><span class="line">代码实现：</span><br></pre></td></tr></table></figure><p> /**</p><pre><code> * 克鲁斯卡尔算法 */public void Kruskal() {    //结果数组的当前索引    int index = 0;    //输出的结果数组    Edge[] results = new Edge[edgeNum];    //保存某个顶点在该最小生成树的终点    int[] vends = new int[edgeNum];    //获取图中所有的边    Edge[] edges = getEdges();    //将边按权重从小到大排序    sortEdges(edges);    for (int i = 0; i &lt; edgeNum; i++) {        int p1 = getVertexPosition(edges[i].start);        int p2 = getVertexPosition(edges[i].end);        int m = getEdgesEnd(vends, p1);        int n = getEdgesEnd(vends, p2);        if (m != n) {//表示没有形成闭环            vends[m] = n;            results[index++] = edges[i];        }    }    //统计并打印最小生成树的信息    int length = 0;    for (int i = 0; i &lt; index; i++) {        length += results[i].weight;    }    System.out.println(&quot;Kruskal：&quot;);    for (int i = 0; i &lt; index; i++) {        System.out.printf(&quot;(%c,%c) &quot;, results[i].start, results[i].end);    }    System.out.println();    System.out.println(&quot;Kruskal的权重：&quot; + length);}//连通图的边结构private static class Edge {    char start;//边的起点    char end;//边的终点    int weight;//边的权重    public Edge(char start, char end, int weight) {        this.start = start;        this.end = end;        this.weight = weight;    }}/** * 获取图中的边 */private Edge[] getEdges() {    int index = 0;    Edge[] edges = new Edge[edgeNum];    for (int i = 0; i &lt; vertex.length; i++) {        for (int j = i + 1; j &lt; vertex.length; j++) {            if (matrix[i][j] != Integer.MAX_VALUE) {                edges[index++] = new Edge(vertex[i], vertex[j], matrix[i][j]);            }        }    }    return edges;}/** * 根据权重从小到大排序 * * @param edges edges */private void sortEdges(Edge[] edges) {    Edge tmp;    for (int i = 0; i &lt; edges.length; i++) {        for (int j = (i + 1); j &lt; edges.length; j++) {            if (edges[i].weight &gt; edges[j].weight) {//若大于则交换位置                tmp = edges[i];                edges[i] = edges[j];                edges[j] = tmp;            }        }    }}/** * 取终点 */private int getEdgesEnd(int[] vends, int i) {    //若C-&gt;D,D-&gt;F则取F的值    while (vends[i] != 0) {        i = vends[i];    }    return i;}</code></pre><p><code>`</code></p><ul><li>最短路径：</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2020/04/14/%E6%A0%91/"/>
      <url>/2020/04/14/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。</p><p><img src="tree.jpg" alt=""></p><ul><li>特点：</li></ul><p>1.在非空树中，根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点；<br>2.子树的个数没有限制，但它们互不相交；</p><ul><li>度：</li></ul><p>结点的度：结点拥有的子树个数叫做结点的度，结点A的度是3，C的度是2，H的度是1。<br>树的度：树中最大的结点度。图中树的度是3</p><ul><li>结点的关系</li></ul><p>1.结点子树的根结点称为该结点的 <strong>孩子结点</strong>，该结点叫做孩子结点的<strong>双亲结点</strong>。图中E是B的孩子结点，B是E的双亲结点；<br>2.同一双亲的结点叫做<strong>兄弟结点</strong>，图中的F、G是E的兄弟结点；<br>3.同一层的结点叫做<strong>堂兄结点</strong>，通中的H、I、J、K、L是E的堂兄结点；<br>4.从根到该结点经过的左右分支结点叫做该结点的祖先结点，图中M的祖先结点有A、B、E。<br>5.该结点的子树任意一个结点都称为该结点的子孙结点，E的子孙结点有M和N。</p><ul><li>结点的层次</li></ul><p>从根开始定义，根为第一层，根的孩子为第二层，根的孩子的孩子为第三层…。<br>树的深度：树中结点的最大层次数称为树的深度或高度，图中深度为4</p><h4><span id="二叉树">二叉树</span></h4><p>二叉树(Binary Tree)是n(n&gt;=0)个结点的有限集合，该集合或者为空集(空二叉树)，或者由一个跟结点和两个互补相交的、分别称为根的结点在左子树和右子树组成。每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。</p><p><img src="binary_tree.jpg" alt=""></p><ul><li>二叉树的特点</li></ul><p>1.每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点；<br>2.左子树和右子树是有顺序的，次序不能任意颠倒；<br>3.即使树中某结点只有一棵子树，也要区分它是左子树还是右子树；</p><ul><li>二叉树的性质</li></ul><p>1.在二叉树中第i层上最多有2的i-1次方个结点(i&gt;=1)；<br>2.二叉树中如果深度为k,那么最多有2k-1个节点(k&gt;=1）；</p><ul><li>斜树</li></ul><p>所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p><p><img src="xie_binary_tree.jpg" alt=""></p><ul><li>满二叉树<br>在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。<br>满二叉树的特点有：<br>1.叶子只能出现在最下一层。出现在其它层就不可能达成平衡。<br>2.非叶子结点的度一定是2。<br>3.在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li></ul><p><img src="man_binary_tree.jpg" alt=""></p><ul><li>完全二叉树<br>若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。<br>完全二叉树的特点：<br>1.叶子结点只出现在最下层和次下层；<br>2.最下层叶子结点集中在树的左部；<br>3.如果结点度为1，则该结点只有左孩子，即没有右子树；<br>4.相同结点数的二叉树，完全二叉树的深度最小；<br>5.满二叉树一定是完全二叉树，但反过来不一定成立。</li></ul><p><img src="wanquan_binary_tree.jpg" alt=""></p><ul><li>二叉树存储结构</li></ul><p>1.*** 顺序存储结构<br>二叉树的顺序存储结构就是使用一维数组存储二叉树中的结点，并且结点的存储位置，就是数组的下标索引。</p><p><img src="order_storage.jpg" alt=""></p><p>如果索引下为空表示该位置下没有存储结点。</p><p>2.*** 链式存储结构 </p><p>结构定义  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class BinaryNode&lt;E&gt; &#123;</span><br><span class="line">    //数据</span><br><span class="line">    E data;</span><br><span class="line">    //左子树</span><br><span class="line">    BinaryNode leftChild;</span><br><span class="line">    //右子树</span><br><span class="line">    BinaryNode rightChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二叉树的遍历</li></ul><p>1.前序遍历(DLR)<br>首先访问根，再先序遍历左（右）子树，最后先序遍历右（左）子树<br>图中结果：ABDECFG</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 前序遍历</span><br><span class="line">     *</span><br><span class="line">     * @param root 根</span><br><span class="line">     */</span><br><span class="line">    public void DLR(BinaryNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //TODO do something</span><br><span class="line"></span><br><span class="line">        if (root.leftChild != null) &#123;</span><br><span class="line">            DLR(root.leftChild);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.rightChild != null) &#123;</span><br><span class="line">            DLR(root.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2.中序遍历(LDR)<br>首先中序遍历左（右）子树，再访问根，最后中序遍历右（左）子树。<br>图中结果：DBEAFCG</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 中序遍历</span><br><span class="line">     *</span><br><span class="line">     * @param root 根</span><br><span class="line">     */</span><br><span class="line">    public void LDR(BinaryNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.leftChild != null) &#123;</span><br><span class="line">            LDR(root.leftChild);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //TODO do something</span><br><span class="line"></span><br><span class="line">        if (root.rightChild != null) &#123;</span><br><span class="line">            LDR(root.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3.后序遍历(LRD)<br>首先后序遍历左（右）子树，再后序遍历右（左）子树，最后访问根<br>图中结果：DEBFGA</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 后序遍历</span><br><span class="line">     *</span><br><span class="line">     * @param root 根</span><br><span class="line">     */</span><br><span class="line">    public void LRD(BinaryNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.leftChild != null) &#123;</span><br><span class="line">            LRD(root.leftChild);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.rightChild != null) &#123;</span><br><span class="line">            LRD(root.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //TODO do something</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4.层序遍历<br>按照层次访问，通常用队列来做。访问根，访问子女，再访问子女的子女</p><ul><li>线索二叉树</li></ul><p>二叉树线索化的过程中，会把树中的空指针利用起来作为寻找当前节点前驱和后继的线索，这样就出现了一个问题，即线索和数中原有指向孩子节点的指针无法区分。上边的这种节点设计就是为了区分这两类指针。其中，ltag和rtag为标识域，它们的具体意义如下:<br>1.如果ltag==0，表示lchild为指针，指向结点的左子树；<br>2.如果ltag==1，表示lchild为线索，指向结点的直接前驱;<br>3.如果rtag==0，表示rchild为指针，指向结点的右子树；<br>4.如果rtag==1，表示rchild为线索，指向结点的直接后继。</p><ul><li>哈夫曼树</li></ul><p>当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。</p><p><img src="huffman_tree.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配算法</title>
      <link href="/2020/04/14/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
      <url>/2020/04/14/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3><span id="bf算法">BF算法</span></h3><p>首先原串与字串左端对齐，，如果第一个字符不匹配，字串向后移动逐一移动，当发现死一个第一个字符匹配后，当前位置下比较剩余字串的字符与原串是否匹配，直到全部匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对齐:</span><br><span class="line">litchicoder</span><br><span class="line">coder</span><br><span class="line"></span><br><span class="line">逐一移动 找到匹配字符:</span><br><span class="line">litchicoder</span><br><span class="line">      coder</span><br></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class BF &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int r = queryByBF(&quot;HelloWord&quot;, &quot;Word&quot;);</span><br><span class="line">        System.out.print(r == 0 ? &quot;字符串匹配失败&quot; : &quot;子字符串在原串的位置：&quot; + r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param s 原字符串</span><br><span class="line">     * @param t 需要匹配的子字符串位置</span><br><span class="line">     */</span><br><span class="line">    public static int queryByBF(String s, String t) &#123;</span><br><span class="line">        char[] a = s.toCharArray();</span><br><span class="line">        char[] b = t.toCharArray();</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        while (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123;</span><br><span class="line">            //比较字符</span><br><span class="line">            if (a[i] == b[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //i后退重新匹配</span><br><span class="line">                i++;</span><br><span class="line">                j = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j &gt;= t.length()) &#123;</span><br><span class="line">            return i - t.length();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //匹配失败</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="kmp算法">KMP算法</span></h3><p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归和分治</title>
      <link href="/2020/04/14/%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB/"/>
      <url>/2020/04/14/%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<h3><span id="递归">递归</span></h3><p>高级语言中，函数自己调用和调用其他函数并没有本质的不同，我们把一个直接调用自己或者通过一系列调用语句间接地调用自己的函数，称作递归函数。（ps：每个递归定义必须至少有一个条件，当满足这个条件时递归不再进行，即函数不再调用自身而是返回值）</p><h4><span id="斐波那契fibonacci数列">斐波那契(Fibonacci)数列</span></h4><p>如果说兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔子都不会死去，能够一直干下去，那么一年以后可以繁殖多少对兔子呢？</p><p><img src="fibonacci.jpg" alt=""></p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int Fib(int i)</span><br><span class="line">&#123;</span><br><span class="line">    if( i &lt; 2 )</span><br><span class="line">        return i == 0 ? 0 : 1;</span><br><span class="line">    return Fib(i-1) + Fib(i-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="分治">分治</span></h3><p>在遥远的周朝，人们受生产力水平所限，无法管理庞大的土地和众多的人民，因此采用了封邦建国的封建制度，把土地一层一层划分下去，以达到分而治之的目的，这也许是最古老的分治法了：</p><p><img src="fenzhi.png" alt=""></p><h4><span id="汉诺塔问题">汉诺塔问题</span></h4><p>汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><p><img src="hanoi.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Hanoi &#123;</span><br><span class="line">    /**</span><br><span class="line">    * </span><br><span class="line">    * @param n 盘子的个数</span><br><span class="line">    * @param a 原来的柱子</span><br><span class="line">    * @param b 中间辅助柱子</span><br><span class="line">    * @param c 最终到达的目标珠子</span><br><span class="line">    */</span><br><span class="line">    public void hanoi(int n, char a, char b, char c) &#123;</span><br><span class="line">        if (n == 1) &#123;</span><br><span class="line">            move(a, c);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          //将n-1个盘子从a利用c移动到b盘子</span><br><span class="line">            hanoi(n - 1, a, c, b);</span><br><span class="line">            //将第n个盘子从a移动到c</span><br><span class="line">            move(a, c);</span><br><span class="line">            //将n-1个盘子从b利用a移动到c</span><br><span class="line">            hanoi(n - 1, b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 移动盘子</span><br><span class="line">    private void move(char origin, char target) &#123;</span><br><span class="line">        System.out.println(&quot;方向:&quot; + origin + &quot;---&gt;&quot; + target);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hanoi hanoi = new Hanoi();</span><br><span class="line">        hanoi.hanoi(3, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="快速排序">快速排序</span></h4><h4><span id="找出第n大的值">找出第n大的值</span></h4><h4><span id="直尺">直尺</span></h4><h4><span id="八皇后问题">八皇后问题</span></h4>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="/2020/04/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2020/04/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3><span id="栈">栈：</span></h3><p>栈(Stack)是一个后进先出(Last in first out LIFO)的线性表，要求只在表尾进行删除和插入操作了，栈的插入叫做进栈（进栈、压栈、入栈）、栈的删除叫出栈。</p><p><img src="stack.jpg" alt=""></p><h3><span id="队列">队列：</span></h3><p>队列(queue)是只允许在一端进行插入操作，而另一端进行删除操作的一种先进先出(First in First out FIFo)的线性表<br>1.循环队列：</p><p><img src="circle_queue.jpg" alt="循环队列"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class CircleQueue&lt;E&gt; &#123;</span><br><span class="line">    private Object q[];</span><br><span class="line">    private int head = 0;</span><br><span class="line">    private int tail = 0;</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public CircleQueue(int size) &#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">        q = new Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CircleQueue() &#123;</span><br><span class="line">        this(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean inQueue(E e) &#123;</span><br><span class="line">        //表示队列已经满了</span><br><span class="line">        if ((tail+1) % size == head) return false;</span><br><span class="line">        q[tail] = e;</span><br><span class="line">        tail = (tail + 1) % size;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E outQueue() &#123;</span><br><span class="line">        if (head == tail) return null;</span><br><span class="line">        E o = (E) q[head];</span><br><span class="line">        head = (head + 1) % size;</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/2020/04/08/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2020/04/08/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4><span id="线性表理解为将数据结点用一根线连接起来存储在物理空间线性表的数据元素一般具有相同的数据类型-大部分线性表中除了第一个元素没有前驱和最后一个元素没有后继其他元素都有前驱和后继也就是各元素之间是一对一的关系">线性表理解为将数据结点用一根“线”连接起来存储在物理空间，线性表的数据元素一般具有相同的数据类型。大部分线性表中除了第一个元素（没有前驱）和最后一个元素（没有后继）其他元素都有前驱和后继（也就是各元素之间是一对一的关系）。</span></h4><ul><li><h3><span id="顺序存储结构顺序表">顺序存储结构（顺序表）</span></h3></li></ul><p>顺序存储结构就是数据是用一块完整的物理空间来连续存储数据，一般它的大小是固定的。<br>优点：物理空间利用率高，增查效率高。<br>缺点：插入和删除效率低，每次都需要移动目标元素后面的所有数据元素，由于它的length是提前分配固定好不能扩容，会发生存储溢出。</p><ul><li><h3><span id="链式存储结构">链式存储结构</span></h3>链式存储结构中数据元素的存储方式在物理空间中是随机的，数据结点氛围数据域和指针域，数据域存储数据元素，指针域来关联起来数据结点形成链。链式存储结构一般有单链表、双向链表和循环链表。<ol><li>单链表</li></ol></li></ul><p><img src="single_linked_list.jpg" alt=""></p><p>题目：找到单链表倒数第n个节点，保证链表中节点的最少数量为n。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for ListNode.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int val) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /*</span><br><span class="line">     * @param head: The first node of linked list.</span><br><span class="line">     * @param n: An integer</span><br><span class="line">     * @return: Nth to last node of a singly linked list. </span><br><span class="line">     */</span><br><span class="line">    public ListNode nthToLast(ListNode head, int n) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        ArrayList&lt;ListNode&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">        if (head!=null)&#123;</span><br><span class="line">            list.add(head);</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(head.next!=null)&#123;</span><br><span class="line">            list.add(0,head.next);</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode targetNode=list.get(n-1);</span><br><span class="line">        return targetNode;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>双向链表<br>双向链表是每个数据结点都有两个指针，分别指向相邻的前驱结点和后继结点，可以方便的访问某个结点的前驱结点和后继结点，存储上会相对多占用一些空间。<br><img src="duLinkList.jpg" alt=""></p><p>代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>静态链表<br>静态链表就是用数组来实现链式存储结构，所以它的长度是初始化的时候固定分配的定长。</li></ol><p><img src="static_list.jpg" alt=""></p><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">public class StaticList &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void run() &#123;</span><br><span class="line">        StcList list = new StcList&lt;CharSequence&gt;();</span><br><span class="line">        System.out.println(&quot;顺序新增前：&quot;);</span><br><span class="line">        list.printAll();</span><br><span class="line">        System.out.println(&quot;顺序新增后：&quot;);</span><br><span class="line">        list.add(&quot;A&quot;);</span><br><span class="line">        list.add(&quot;B&quot;);</span><br><span class="line">        list.add(&quot;C&quot;);</span><br><span class="line">        list.add(&quot;E&quot;);</span><br><span class="line">        list.insert(&quot;D&quot;, 3);</span><br><span class="line">        list.delete(2);</span><br><span class="line">        list.printAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //存储结构</span><br><span class="line">    public static class StaticListNode&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private E data;</span><br><span class="line">        private int cursor;</span><br><span class="line"></span><br><span class="line">        public StaticListNode(E data, int cursor) &#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">            this.cursor = cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public E getData() &#123;</span><br><span class="line">            return data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setData(E data) &#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getCursor() &#123;</span><br><span class="line">            return cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setCursor(int cursor) &#123;</span><br><span class="line">            this.cursor = cursor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class StcList&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private static final int MAX_SIZE = 10;</span><br><span class="line">        StaticListNode&lt;E&gt;[] nodes = new StaticListNode[MAX_SIZE];</span><br><span class="line"></span><br><span class="line">        public StcList() &#123;</span><br><span class="line">            initList(nodes, nodes.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //初始化备用链表</span><br><span class="line">        private void initList(StaticListNode[] nodes, int maxSize) &#123;</span><br><span class="line">            for (int i = 0; i &lt; maxSize; i++) &#123;</span><br><span class="line">                nodes[i] = new StaticListNode(null, i + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            //将最后一个数据元素的游标指向第一个有值元素</span><br><span class="line">            nodes[maxSize - 1] = new StaticListNode(null, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void printAll() &#123;</span><br><span class="line">            for (int i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">                System.out.print(nodes[i].getCursor());</span><br><span class="line">                System.out.print(&quot;:&quot;);</span><br><span class="line">                System.out.print(nodes[i].getData());</span><br><span class="line">                System.out.print(&quot;:&quot;);</span><br><span class="line">                System.out.print(i);</span><br><span class="line">                System.out.print(&quot;|&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 查找当前备用链表的头的</span><br><span class="line">         */</span><br><span class="line">        private void findHead() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 分配空间 分配空间的元素下标</span><br><span class="line">         *</span><br><span class="line">         * @return 0分配失败</span><br><span class="line">         */</span><br><span class="line">        private int mallocArry() &#123;</span><br><span class="line">            int index = 0;</span><br><span class="line">            if (nodes[0].cursor &gt; 0) &#123;</span><br><span class="line">                index = nodes[0].cursor;</span><br><span class="line">                nodes[0].cursor = nodes[index].cursor;</span><br><span class="line">            &#125;</span><br><span class="line">            return index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //顺序新增元素</span><br><span class="line">        public boolean add(E e) &#123;</span><br><span class="line">            if (e == null) &#123;</span><br><span class="line">                System.out.println(&quot;新增失败&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //不等于零说明链表容量没用完，可以新增</span><br><span class="line">            int currentIndex = nodes[0].getCursor();</span><br><span class="line">            if (currentIndex &gt; 0) &#123;</span><br><span class="line">                //当前空元素下标</span><br><span class="line">                nodes[currentIndex].setData(e);</span><br><span class="line">                nodes[0].setCursor(nodes[currentIndex].getCursor());</span><br><span class="line">//                nodes[currentIndex].setCursor(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;新增失败&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * @param e     要插入的数据</span><br><span class="line">         * @param index 表示要插入的链中的位置</span><br><span class="line">         * @return true插入成功</span><br><span class="line">         */</span><br><span class="line">        //新增元素</span><br><span class="line">        public boolean insert(E e, int index) &#123;</span><br><span class="line">            if (e == null || index &lt; 0 || index &gt; MAX_SIZE - 1) &#123;</span><br><span class="line">                System.out.println(&quot;插入元素失败&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //不等于零说明链表容量没用完，可以新增</span><br><span class="line">            int currentIndex = nodes[0].getCursor();</span><br><span class="line">            if (currentIndex &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">                //查找对应的位置</span><br><span class="line">                int k = 1;</span><br><span class="line">                for (int i = 0; i &lt; index - 1; i++) &#123;</span><br><span class="line">                    k = nodes[k].cursor;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //要插入位置记录的游标</span><br><span class="line">                int insertCursor = nodes[k].getCursor();</span><br><span class="line"></span><br><span class="line">                //申请分配的空间的下标</span><br><span class="line">                int i = mallocArry();</span><br><span class="line"></span><br><span class="line">                //插入位置的游标连接到新插入元素</span><br><span class="line">                nodes[k].setCursor(i);</span><br><span class="line">                //新插入元素的游标连接之前插入位置记录的游标</span><br><span class="line">                nodes[i].cursor = insertCursor;</span><br><span class="line">                nodes[i].data = e;</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;插入元素失败&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean delete(int index) &#123;</span><br><span class="line"></span><br><span class="line">            //不等于零说明链表容量没用完，可以新增</span><br><span class="line">            int currentEmptyIndex = nodes[0].getCursor();</span><br><span class="line">            if (currentEmptyIndex &gt; 0) &#123;</span><br><span class="line">                //查找前一个的位置</span><br><span class="line">                int k = 1;</span><br><span class="line">                for (int i = 1; i &lt; index - 1; i++) &#123;</span><br><span class="line">                    k = nodes[k].cursor;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                int currentIndex = nodes[k].cursor;</span><br><span class="line">                int nextIndex = nodes[currentIndex].cursor;</span><br><span class="line">                nodes[k].cursor = nextIndex;</span><br><span class="line"></span><br><span class="line">                //将删除的结点连接到备用链表</span><br><span class="line">                free(currentIndex);</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;删除元素失败&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void free(int i) &#123;</span><br><span class="line">            nodes[i].cursor=nodes[0].cursor;</span><br><span class="line">            nodes[0].cursor=i;</span><br><span class="line">            nodes[i].data = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>循环链表 有环</li></ol><p>循环链表的特点是最后一个结点的指针指向头结点，使整个链表形成环。</p><p>空链的判断条件：head==head-&gt;next;rear==rear-&gt;next;</p><ul><li><h3><span id="约瑟夫问题">约瑟夫问题</span></h3></li></ul><p>问题描述：<br>N个人围成一个圈，从第一个开始报数，第M个人将被杀掉，最后只剩一个，其他都被杀掉。</p><p><img src="josephus_problem.jpg" alt=""></p><p>循环链表的实现方式就是通过遍历元素，指针移动M位删除该元素，知道剩余一个元素。<br>数学推导方式是发现最终获胜的元素下标是在每一轮“杀人”过程中移动M位从而得到公式：f(N,M)=(f(N−1,M)+M)。</p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, i, winner = 0;</span><br><span class="line">    printf (&quot;N M = &quot;);</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    for (i = 2; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       //i是每阶约瑟夫环的人数</span><br><span class="line">        winner = (winner + m) % i;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">    //编号是从零开始，这里加1变成符合习惯的计数</span><br><span class="line">    printf (&quot;\nThe winner is %d\n&quot;, (winner +1));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3><span id="魔术师发牌问题">魔术师发牌问题</span></h3></li></ul><p>问题描述：<br>魔术师手中有A到K十三张黑桃扑克牌，表演前魔术师已经按照一定的顺序叠放好，表演过程：开始，魔术师数1将最上面的那张翻过来，是黑桃A，将其放在桌面上；第二次，魔术师数1、2，将第一张牌放在所有牌最下面，将第二张牌翻转过来，第二张牌正好是黑桃2；第三次，魔术师数1、2、3，将第一、二张牌按照顺序放在所有牌最下面，将第三张牌翻转过来，第三张牌正好是黑桃3；…知道所有牌都翻转过来，顺序刚好是A、2、3…K，现在要知道魔术师在翻牌前叠放的13张牌的顺序。</p><p> 代码实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><ul><li><h3><span id="拉丁方阵问题">拉丁方阵问题</span></h3></li></ul><p>问题描述：<br>拉丁方阵是一种n×n的方阵，方阵中恰有n种不同的元素，每种元素恰有n个，并且每种元素在一行和一列中 恰好出现一次。</p><p><img src="ladingfangzhen.jpg" alt=""></p><p>特点：<br>每一行除了开始的数递进一位外，其余的数都是按照顺序排列，递进的数排在后面，因此使用循环链表解决。</p><p> 代码实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度和空间复杂度</title>
      <link href="/2020/04/07/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2020/04/07/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>时间复杂度：执行算法所需要的时间</p><p>空间复杂度：执行算法所需要的内存空间</p><p>时间复杂度的定义：一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得T(n)/f(n)的极限值（当n趋近于无穷大时）为不等于零的常数，则称f(n)是T(n)的同数量级函数</p><ul><li>通常将O(1)、O(n)、O(logn)、O(n2)等分别叫做常量阶、线性阶、对数阶、平方阶等</li><li>推导大O阶方法：1.用常数1取代运行时间中的所有加法常数；2.修改后的运行次数函数中，值保留最高阶项；3.如果最高阶向存在且不是1，则去除与这个项相乘的常数</li><li>常数阶O(1)：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int sum=0，n=100；</span><br><span class="line">sum=（1+n）*n/2;</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure><ul><li>线性阶O(n):</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">//O(1)的算法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对数阶O(logn):</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int num=1;</span><br><span class="line">while(num&lt;n)&#123;</span><br><span class="line">num=num*2;</span><br><span class="line">//O(1)的算法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>平方阶O(n^2):</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">    for(int j=i;j++)&#123;</span><br><span class="line">    //O(1)的算法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>常用的时间复杂度按照耗费的时间从小到大依次是：</li></ul><p><code>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试积累</title>
      <link href="/2020/02/05/%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF/"/>
      <url>/2020/02/05/%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<h2><span id="要求">要求：</span></h2><ul><li>薪酬结构</li><li>五险一金（全额，非全额要在基础薪资上调整）</li><li>技术团队规模</li><li>上下班时间 单双休 加班情况</li><li>人员配置 发版频率</li><li>绩效 年终奖</li><li>其他福利 餐补 车补贴 房补贴</li></ul><h2><span id="项目经验">项目经验：</span></h2><p>遇到了什么困难怎么解决的</p><ol><li>直播</li></ol><p>做了两方面的隔离，一是与其他业务模块的解耦 利用中间控制层 直播模块提供出对其他业务场景的依赖需求 其他业务模块提供这些能力给直播；二是把直播内部分为业务表现层和三方依赖层  具体做法是把三方直播依赖沉淀到baseview 把业务层需要的能力通过统一能力管理输出 （主要是直播画面能力控制和自定义消息协议的控制）</p><ol start="2"><li><p>首页</p></li><li><p>动画控件</p></li></ol><p>级联view<br>tab</p><h2><span id="java基础">java基础：</span></h2><ol><li><p>同步锁<br>同步锁的原理：</p></li><li><p>Arraylist和Linklist<br>ArrayList是一个数组实现了RandomAccess接口可以随机访问元素，增删速度相对慢；<br>LinkList是链表，只能顺序访问元素，增删快</p></li><li>线程和进程</li></ol><ol start="4"><li><p>位运算<br>常见十进制D、二进制B、八进制Q和十六进制H（逢几进1）n<br>十进制向n进制转化：十进制转化为n进制时 十进制数一直除以n得余数 到一直不能整除为止，小数点部分是将小数部分乘以n 取整 然后小数部分继续乘以n 取整部分倒叙排序就是小数部分的值<br>二进制转n进制：采用r（二进制和n进制之间的位数差 例如八进制是3合1、十六进制时4合1，如果是32进制就是 5合1）合1的方式，如果位数不够r位，整数部分向左补零，小数部分向右补零，然后按照案权展开相加即可得</p></li><li><p>线程安全</p></li></ol><ol start="6"><li><p>进程保活</p></li><li><p>HashMap原理</p></li></ol><h2><span id="数据结构与算法">数据结构与算法：</span></h2><ol><li>时间复杂度、空间复杂度</li><li></li></ol><h2><span id="网络">网络：</span></h2><ol><li><p>tcp的三次握手和四次挥手：<br>第一次：c端发送连接请求 序列号seq=x SYN创建连接状态<br>第二次：b端收到信息后 发送确认码ack=x+1 SYN=1<br>第三次：c端收到后</p></li><li><p>http2.0</p></li><li>Android下网络优化方案</li><li>QUIC协议</li><li><h2><span id="android基础">Android基础：</span></h2>android sdk</li></ol><h2><span id="三方库">三方库：</span></h2><ol><li><p>eventbus原理<br>利用反射触发事件函数的执行<br>关键的一个键值对来存储数据 key是eventType（传递的时事件类型）<br>线程模式 posting：处理函数看post在线程就在什么线程执行<br>main：处理函数在主线程执行<br>background：处理函数在子线程 post如果在主线程辉创建子线程 如果在子线程就直接在子线程触发处理<br>async：新建子线程触发处理函数的执行</p></li><li><p>butterknife原理</p></li><li>okhttp</li><li>rxjava</li><li>retrofit</li><li>Glide Fresco 三级缓冲<br>7.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android数据的持久化</title>
      <link href="/2018/06/28/Android%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2018/06/28/Android%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>常见的存储的方式为SQlite数据存储、xml存储以及自定义数据格式的存储方式<br><a id="more"></a></p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android 中gradle依赖冲突解决</title>
      <link href="/2017/11/24/android-%E4%B8%ADgradle%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/"/>
      <url>/2017/11/24/android-%E4%B8%ADgradle%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>android项目开发中经常会遇到库依赖异常，大多是版本依赖的冲突问题，说明下常见的版本依赖冲突解决方式</p><p>首页看下我们项目的依赖关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew dependencies :app:dependencies</span><br></pre></td></tr></table></figure></p><p><img src="2847241-08589a6078bf5336.png" alt="依赖包结构" title="依赖包结构"></p><blockquote><p>:app表示依赖module<br>mac下运行可能人别不了命令行，运行<figure class="highlight plain"><figcaption><span>+x gradlew ```添加权限</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以看到依赖结构是树状结构，各库下又依赖了android的官方提供的一些库，如果依赖的库不是太多的话，可以使用transitive参数，使得依赖库所需的依赖不直接使用，在依赖库的module中同一级上做依赖关系</span><br><span class="line">``` </span><br><span class="line">implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; </span><br><span class="line">    compile (&apos;com.alibaba.android:vlayout:1.2.2@aar&apos;) &#123;</span><br><span class="line">        transitive = false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>transitive为false表示单独依赖，true为默认树状依赖</p><p>这种解决方式只用于当前的依赖包只是版本导致的，且版本变动不大，起码它的代码package路径一致，如果差异很大可以指定依赖关系中特定包不包含到依赖中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;</span><br><span class="line">    compile (&apos;com.alibaba.android:vlayout:1.2.2@aar&apos;) &#123;</span><br><span class="line">        exclude group: &apos;support-v4&apos;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基础知识</title>
      <link href="/2017/11/07/git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2017/11/07/git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1><span id="git基础知识">git基础知识</span></h1><p>——创建新的ssh key</p><figure class="highlight plain"><figcaption><span>ssh-keygen -t rsa -C "793021170@qq.com"```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">------测试 ssh 链接 github</span><br><span class="line"></span><br><span class="line">```$ ssh -T git@git.oschina.net</span><br></pre></td></tr></table></figure><p>——设置用户名、邮箱</p><figure class="highlight plain"><figcaption><span>git config --global user.name "litchi"```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```$ git config --global user.email &quot;793021170@qq.com&quot;</span><br></pre></td></tr></table></figure><p>——提交到远程服务器</p><figure class="highlight plain"><figcaption><span>git remote add origin ssh://git@dev.lemote.com/rt4ls.git```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```$ git push origin master</span><br></pre></td></tr></table></figure><p>——-本地库中缺少md文件时<br><figure class="highlight plain"><figcaption><span>git pull --rebase origin master```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-------由于远程库是空的，我们第一次推送master分支时，</span><br><span class="line">加上了-u参数，Git不但会把本地的master分支内容推送的远</span><br><span class="line">程新的master分支，还会把本地的master分支和远程的master</span><br><span class="line">分支关联起来，在以后的推送或者拉取时就可以简化命令</span><br><span class="line"></span><br><span class="line">```$　git push -u origin master</span><br></pre></td></tr></table></figure></p><p>——-关联远程库<br><figure class="highlight plain"><figcaption><span>git remote add origin git@server-name:path/repo-name.git```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git checkout master //进入master分支</span><br><span class="line"></span><br><span class="line">git checkout -b frommaster //以master为源创建分支frommaster</span><br><span class="line"></span><br><span class="line">git show # 显示某次提交的内容 git show $id</span><br><span class="line"></span><br><span class="line">git co -- &lt;file&gt; # 抛弃工作区修改</span><br><span class="line"></span><br><span class="line">git co . # 抛弃工作区修改</span><br><span class="line"></span><br><span class="line">git add &lt;file&gt; # 将工作文件修改提交到本地暂存区</span><br><span class="line"></span><br><span class="line">git add . # 将所有修改过的工作文件提交暂存区</span><br><span class="line"></span><br><span class="line">git rm &lt;file&gt; # 从版本库中删除文件</span><br><span class="line"></span><br><span class="line">git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件</span><br><span class="line"></span><br><span class="line">git reset &lt;file&gt; # 从暂存区恢复到工作文件</span><br><span class="line"></span><br><span class="line">git reset -- . # 从暂存区恢复到工作文件</span><br><span class="line"></span><br><span class="line">git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改</span><br><span class="line"></span><br><span class="line">git ci &lt;file&gt; git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　git ci -am &quot;some comments&quot;</span><br><span class="line"></span><br><span class="line">git ci --amend # 修改最后一次提交记录</span><br><span class="line"></span><br><span class="line">git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象</span><br><span class="line"></span><br><span class="line">git revert HEAD # 恢复最后一次提交的状态</span><br><span class="line"></span><br><span class="line">查看文件diff</span><br><span class="line"></span><br><span class="line">git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diff</span><br><span class="line"></span><br><span class="line">git diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异</span><br><span class="line"></span><br><span class="line">git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较</span><br><span class="line"></span><br><span class="line">git diff --staged # 比较暂存区和版本库差异</span><br><span class="line"></span><br><span class="line">git diff --cached # 比较暂存区和版本库差异</span><br><span class="line"></span><br><span class="line">git diff --stat # 仅仅比较统计信息</span><br><span class="line"></span><br><span class="line">查看提交记录</span><br><span class="line"></span><br><span class="line">git log git log &lt;file&gt; # 查看该文件每次提交记录</span><br><span class="line"></span><br><span class="line">git log -p &lt;file&gt; # 查看每次详细修改内容的diff</span><br><span class="line"></span><br><span class="line">git log -p -2 # 查看最近两次详细修改内容的diff</span><br><span class="line"></span><br><span class="line">git log --stat #查看提交统计信息</span><br><span class="line"></span><br><span class="line">tig</span><br><span class="line"></span><br><span class="line">Mac上可以使用tig代替diff和log，brew install tig</span><br><span class="line"></span><br><span class="line">Git 本地分支管理</span><br><span class="line"></span><br><span class="line">查看、切换、创建和删除分支</span><br><span class="line"></span><br><span class="line">git br -r # 查看远程分支</span><br><span class="line"></span><br><span class="line">git br &lt;new_branch&gt; # 创建新的分支</span><br><span class="line"></span><br><span class="line">git br -v # 查看各个分支最后提交信息</span><br><span class="line"></span><br><span class="line">git br --merged # 查看已经被合并到当前分支的分支</span><br><span class="line"></span><br><span class="line">git br --no-merged # 查看尚未被合并到当前分支的分支</span><br><span class="line"></span><br><span class="line">git co &lt;branch&gt; # 切换到某个分支</span><br><span class="line"></span><br><span class="line">git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去</span><br><span class="line"></span><br><span class="line">git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branch</span><br><span class="line"></span><br><span class="line">git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除</span><br><span class="line"></span><br><span class="line">git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支</span><br><span class="line"></span><br><span class="line">git br -d &lt;branch&gt; # 删除某个分支</span><br><span class="line"></span><br><span class="line">git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)</span><br><span class="line"></span><br><span class="line"> 分支合并和rebase</span><br><span class="line"></span><br><span class="line">git merge &lt;branch&gt; # 将branch分支合并到当前分支</span><br><span class="line"></span><br><span class="line">git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交</span><br><span class="line"></span><br><span class="line">git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"> Git补丁管理(方便在多台机器上开发同步时用)</span><br><span class="line"></span><br><span class="line">git diff &gt; ../sync.patch # 生成补丁</span><br><span class="line"></span><br><span class="line">git apply ../sync.patch # 打补丁</span><br><span class="line"></span><br><span class="line">git apply --check ../sync.patch #测试补丁能否成功</span><br><span class="line"></span><br><span class="line"> Git暂存管理</span><br><span class="line"></span><br><span class="line">git stash # 暂存</span><br><span class="line"></span><br><span class="line">git stash list # 列所有stash</span><br><span class="line"></span><br><span class="line">git stash apply # 恢复暂存的内容</span><br><span class="line"></span><br><span class="line">git stash drop # 删除暂存区</span><br><span class="line"></span><br><span class="line">Git远程分支管理</span><br><span class="line"></span><br><span class="line">git pull # 抓取远程仓库所有分支更新并合并到本地</span><br><span class="line"></span><br><span class="line">git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并</span><br><span class="line"></span><br><span class="line">git fetch origin # 抓取远程仓库更新</span><br><span class="line"></span><br><span class="line">git merge origin/master # 将远程主分支合并到本地当前分支</span><br><span class="line"></span><br><span class="line">git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支</span><br><span class="line"></span><br><span class="line">git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上</span><br><span class="line"></span><br><span class="line">git push # push所有分支</span><br><span class="line"></span><br><span class="line">git push origin master # 将本地主分支推到远程主分支</span><br><span class="line"></span><br><span class="line">git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)</span><br><span class="line"></span><br><span class="line">git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名</span><br><span class="line"></span><br><span class="line">git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支</span><br><span class="line"></span><br><span class="line">git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支</span><br><span class="line"></span><br><span class="line">Git远程仓库管理</span><br><span class="line"></span><br><span class="line">GitHub</span><br><span class="line"></span><br><span class="line">git remote -v # 查看远程服务器地址和仓库名称</span><br><span class="line"></span><br><span class="line">git remote show origin # 查看远程服务器仓库状态</span><br><span class="line"></span><br><span class="line">git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址</span><br><span class="line"></span><br><span class="line">git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm &lt;repository&gt; # 删除远程仓库</span><br><span class="line"></span><br><span class="line">创建远程仓库</span><br><span class="line"></span><br><span class="line">git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库</span><br><span class="line"></span><br><span class="line">scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上</span><br><span class="line"></span><br><span class="line">mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库</span><br><span class="line"></span><br><span class="line">git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址</span><br><span class="line"></span><br><span class="line">git push -u origin master # 客户端首次提交</span><br><span class="line"></span><br><span class="line">git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track</span><br><span class="line"></span><br><span class="line">git remote set-head origin master # 设置远程仓库的HEAD指向master分支</span><br><span class="line"></span><br><span class="line">也可以命令设置跟踪远程库和本地库</span><br><span class="line"></span><br><span class="line">git branch --set-upstream master origin/master</span><br><span class="line"></span><br><span class="line">git branch --set-upstream develop origin/develop</span><br><span class="line"></span><br><span class="line">--------显示command的help</span><br><span class="line"></span><br><span class="line">```git help &lt;command&gt; #</span><br></pre></td></tr></table></figure></p><p>异常处理：<br>1.如果出现remote origin already exists.需要删除远程库后在执行git remote add origin<br> 具体执行：git remote rm origin<br> git remote add origin <a href="mailto:git@git.oschina.net" target="_blank" rel="noopener">git@git.oschina.net</a>:jichengliu/SilkMarke</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之工厂模式</title>
      <link href="/2017/11/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/11/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1><span id="设计模式之工厂模式">设计模式之工厂模式</span></h1><h2><span id="前言">前言</span></h2><p>最近在看设计模式相关的一些知识，看了一些感觉还是要做一些记录的，一方面用来记录当前情况下个人对设计模式的理解程度，使得这块知识更加深刻，另一方面也是方便把自己的一些拙见拿出来希望能够共同进步，得到众人的指正。</p><h2><span id="引入">引入</span></h2><p>工厂模式应该说最常见的模式，看一些介绍模式的书里工厂模式基本都是第一个被提到的，它应用场景比较多，也容易被理解。它是名如其模式，先来分析下它的名字，“工厂”用来生产各种产品，我们可以直接通过工厂来获得需要的各种产品，而不需要来考虑其具体的实现，所谓的“工厂”就类似于“商店”，提供我们需要所需产品。那么“工厂”的产品是怎么样获得的呢，“工厂”会根据我们具体的需求来利用具体的“材料”来“生产”具体的产品，到这里来看图说话。</p><p><img src="20171106-143320.png" alt="factory" title="factory"></p><blockquote></blockquote><p>上图就是对上面文字的一个概括，这里先又了这个概念就OK了，下面深入到代码层面来说明。</p><h2><span id="代码实现">代码实现</span></h2><p>这里用<a href="#introduced">引入</a>中最原始的提到的工厂、产品和消费者举例。<br>例子在android studio中android项目中开发。</p><h3><span id="工厂-产品和消费者">工厂、产品和消费者</span></h3><p><img src="QQ20171106-175109@2x.png" alt="factory" title="factory"></p><p>创建一个工厂类(Factory),提供一个获得产品的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得产品对象实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P    extends BaseProduct&gt;   p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> p</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;P extends BaseProduct&gt; <span class="function">P <span class="title">getProduct</span><span class="params">(Class&lt;P&gt; clazz)</span> </span>&#123;</span><br><span class="line">        P p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p = (P) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个接口(IProduct)，商品类将实现produce()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseProduct <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别创建商品类(BaseProduct、ProductOne、ProductTwo、ProductThree和ProductFour)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseProduct</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBaseComponents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//制作基础组件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductOne</span> <span class="keyword">extends</span> <span class="title">BaseProduct</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseProduct <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        makeBaseComponents();</span><br><span class="line">        Log.d(<span class="string">"ProductOne"</span>, <span class="string">"make ProductOne"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductTwo</span> <span class="keyword">extends</span> <span class="title">BaseProduct</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseProduct <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        makeBaseComponents();</span><br><span class="line">        Log.d(<span class="string">"ProductTwo"</span>, <span class="string">"make ProductTwo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductThree</span> <span class="keyword">extends</span> <span class="title">BaseProduct</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseProduct <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        makeBaseComponents();</span><br><span class="line">        Log.d(<span class="string">"ProductThree"</span>, <span class="string">"make ProductThree"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFour</span> <span class="keyword">extends</span> <span class="title">BaseProduct</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseProduct <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        makeBaseComponents();</span><br><span class="line">        Log.d(<span class="string">"ProductFour"</span>, <span class="string">"make ProductFour"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MainActivity类中获得需要的商品类实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetProduct</span><span class="params">(<span class="keyword">int</span> productType)</span> </span>&#123;</span><br><span class="line">        Class&lt;? extends BaseProduct&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (productType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                clazz = ProductOne.class;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                clazz = ProductTwo.class;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                clazz = ProductThree.class;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                clazz = ProductFour.class;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BaseProduct product = Factory.getProduct(clazz);</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, product.produce(), Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetProductThree</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        onGetProduct(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetProductTwo</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        onGetProduct(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetProductOne</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        onGetProduct(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetProductFour</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        onGetProduct(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终我们实现在activity中获得了产品的实例对象</p><p><a href="https://github.com/litchicoder/factorypatternpro" target="_blank" rel="noopener">github</a></p><h2><span id="为什么要用工厂模式">为什么要用工厂模式</span></h2><p>在开发过程中常常会独立做一些模块供其他的开发者来用，这种情况下，其实对于其他的开发者来说要求在使用功能时尽量的简单、调用方便，他们不需要去了解里面的具体实现，只要简单调用就可以拿到对应的实例，这个时候对于工厂模式时一个可行的方案，当然在实际开发中可以会和其他的模式混用来达到效果，这个还要具问具析。对于我们可以在什么场景下利用工厂模式，这里列出一些它的利弊，以便在考虑使用时参考：</p><blockquote><p>利:</p><ol><li>多类型扩展好，如果新增了一种商品只要实现它的具体类和方法，即可根据类来获取其实例</li><li>具体实现是封闭的、不对外的</li><li>调用方便，可通过一个类型或者类名就可以获得具体实例</li></ol></blockquote><blockquote><p>弊<br>产品类创建方式单一，因为是通过类命来创建实例，这样创建不会像常见的直接new灵活<br>不适合单一产品时使用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown常用语法</title>
      <link href="/2017/11/06/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2017/11/06/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo command line</title>
      <link href="/2017/11/03/hexo-command-line/"/>
      <url>/2017/11/03/hexo-command-line/</url>
      
        <content type="html"><![CDATA[<h1><span id="create-a-new-post">Create a new post</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h1><span id="run-server">Run server</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h1><span id="generate-static-files">Generate static files</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h1><span id="deploy-to-remote-sites">Deploy to remote sites</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux环境下jdk安装配置</title>
      <link href="/2017/11/03/linux%E7%8E%AF%E5%A2%83%E4%B8%8Bjdk%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/11/03/linux%E7%8E%AF%E5%A2%83%E4%B8%8Bjdk%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<ul><li><p>jdk下载</p><pre><code>wget -O jdk-8u131-linux-x64.tar.gz jdk-8u131-linux-x64.tar.gzAuthParam=1499664230_984ba136862e0fd6281ac5bc2bee90e2</code></pre></li><li><p>解压文件</p><pre><code>tar xf jdk-8u131-linux-x64.tar.gz</code></pre></li><li><p>创建要存放的目录并复制解压后的jdk文件到目录下</p></li></ul><a id="more"></a><ul><li><p>修改配置文件，指向存放jdk的目录</p><pre><code>cd etc(进入etc目录)vi profile（打开profile文件并修改环境变量source profile（使文件生效)</code></pre></li></ul><p><img src="2847241-08589a6078bf5336.png" alt="linux环境下jdk安装配置" title="linux环境下jdk安装配置"></p><ul><li><p>测试</p><pre><code>java -version</code></pre></li></ul><p>能够打印java 版本号信息就表示安装或升级成功</p><p><img src="2847241-dd005818079d56ba.png" alt="linux环境下jdk安装配置" title="linux环境下jdk安装配置"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux环境下Jenkins搭建</title>
      <link href="/2017/11/03/linux%E7%8E%AF%E5%A2%83%E4%B8%8BJenkins%E6%90%AD%E5%BB%BA/"/>
      <url>/2017/11/03/linux%E7%8E%AF%E5%A2%83%E4%B8%8BJenkins%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3><span id="安装java环境">安装java环境</span></h3><p>具体查看Linux java环境安装</p><h3><span id="安装tomcat">安装tomcat</span></h3><p>从tomcat官网上下载最新的安装压缩包，注意区分选择不同操作环境下的压缩包.（Linux一般是 tar.gz，Windows一般用zip压缩包），选择对应的压缩包能保证系统可以直接解压，避免不支持时还需安转压缩工具。</p><ol><li><p>下载压缩包</p><pre><code>wget http://apache.fayea.com/tomcat/tomcat-8/v8.5.16/bin/apache-tomcat-8.5.16.tar.gz</code></pre></li><li><p>解压压缩包</p><pre><code>tar xf apache-tomcat-8.5.16.tar.gz</code></pre></li><li><p>进入解压后的文件夹并将所有的复制到自己要安装的目录下</p><pre><code>cd apache-tomcat-8.5.16cp -rf ./*  /usr/local/tomcat/</code></pre></li></ol><a id="more"></a><h3><span id="安装sdk">安装SDK</span></h3><p>根据镜像下载sdk包即可，注意最新的sdk可能没有platform tools文件夹，可下在低版本的将platform tolls文件夹移动到最新的sdk文件夹下即可。</p><p>有一些插件也可以在没有sdk时自动在Jenkins搭建好后构建时自动下载sdk，如Android Emulator Plugin在配置好后它自己会根据配置参数自动去下载对应的sdk版本，这里后面会说到。</p><h3><span id="安装jenkins">安装Jenkins</span></h3><p>从Jenkins官网下载并复制jenkins.war到tomcat目录下webapps下。</p><pre><code>wget http://mirrors.jenkins.io/war/latest/jenkins.warcp ./jenkins.war /usr/local/tomcat/webapps</code></pre><p>启动Tomcat在浏览器中打开http://网址:8080/jenkins/就可以打开Jenkins网页，接下来就可以创建项目，Jenkins玩起来了。</p><h3><span id="注">注：</span></h3><ol><li><p>如果要使用其他端口来使用Jenkins可以运行命令：</p><pre><code>java -jar jenkins.war --httpPort=端口号java -jar jenkins.war --httpPort=8899 --daemon --logfile=日志路径/jenkins/jenkins.log(在后台运行)</code></pre></li><li><p>在打开Jenkins网页前要保证对应的端口号可访问，aliyun要配置安全组，开放对应端口。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Jenkins tomcat Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>note</title>
      <link href="/2017/11/03/note/"/>
      <url>/2017/11/03/note/</url>
      
        <content type="html"><![CDATA[<p>hexo官方教程地址<a href="http:https://hexo.io/zh-cn/" target="_blank" rel="noopener">http:https://hexo.io/zh-cn/</a></p><p>markdown 教程<a href="http:http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-8/" target="_blank" rel="noopener">http:http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-8/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins参数化构建android项目</title>
      <link href="/2017/11/03/Jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BAandroid%E9%A1%B9%E7%9B%AE/"/>
      <url>/2017/11/03/Jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BAandroid%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3><span id="达到的目标">达到的目标：</span></h3><ol><li>根据版本类型(release、beta or debug)、版本号、渠道、服务器请求地址等参数进行构建；</li><li>构建完成后显示相关构建信息；</li><li>展示apk下载二维码、下载地址供直接安装和下载apk</li></ol><h3><span id="需要的插件">需要的插件：</span></h3><ol><li>Dynamic Extended Choice Parameter plugin参数化选择需要</li><li>Description Setter Plugin构建的信息显示需要</li><li>GIt Plugingit 插件</li></ol><a id="more"></a><h3><span id="配置项目参数">配置项目参数：</span></h3><ul><li>设置构建类型参数：</li></ul><p>在general模块中复选‘参数化构建过程’，‘添加参数‘中选择’Choice Parameter‘;</p><p><img src="/images/2847241-7702d781810fa0aa.png" alt="‘添加参数‘中选择’Choice Parameter‘" title="添加参数‘中选择’Choice Parameter"></p><p>Name添加参数名，按照Jenkins已有的默认参数集来定义都以大写字母和下划线组成，例：ENVIRONMENT_BUILD，Choices输入item的选项，第一项会变成默认项。<br><img src="/images/2847241-b06b00a4496b0abb.png" alt="&#39;设置参数’Choice Parameter&#39;‘" title="设置参数’Choice Parameter"></p><p>设置列表型参数渠道、版本号、服务器请求地址等：</p><p>列表型参数和构建类型一样，设置name、Choices和Description。<br><img src="/images/2847241-209a8bc3095e2fd6.png" alt="&#39;设置参数’Choice Parameter&#39;‘" title="设置参数’Choice Parameter"></p><ul><li>配置git参数：</li></ul><p>这里首先要保证我们的代码在每个版本都有独立的版本分支，通过不同的版本名来拉取对应的代码，来实现分版本构建。<br><img src="/images/2847241-93622e27d0f82c4b.png" alt="&#39;git参数设置’Choice Parameter&#39;‘" title="git参数设置"></p><ul><li>配置构建命令参数：</li></ul><p>Tasks输入框输入构建命令行  clean assemble${PRODUCT_FLAVOR_BUILD}${ENVIRONMENT_BUILD}，${参数}表示参数应用，‘PRODUCT_FLAVOR_BUILD’是自定义的参数用来表示构建渠道，‘ENVIRONMENT_BUILD’表示构建类型。<br><img src="/images/2847241-10b29af455218b6e.png" alt="&#39;配置构建命令参数‘" title="配置构建命令参数"></p><ul><li>配置构建后描述参数：</li></ul><p>在‘构建’模块‘增加构建步骤’列表中选择‘set build description’，在Description输入框输入html代码，例如下，其中的‘${参数}’表示自定义的一些参数，用‘${参数}’来取对应的值。<br><img src="/images/2847241-b271fd19719d9abf.png" alt="&#39;配置构建后描述参数‘" title="配置构建后描述参数"></p><p>请求环境：${JENKINS_SERVER_HOST}<br>构建类型：${ENVIRONMENT_BUILD}<br>构建渠道：${PRODUCT_FLAVOR_BUILD}<br>构建版本：${APP_BUILD_VERSION}<br>点击查看二维码<br>点击下载apk</p><p>注：如果在构建完后显示还是按照文本显示的，修改一下系统管理／安全配置中‘Markup Formatter‘选择为Safe HTML，来支持html。</p><p>配置效果：<br><img src="/images/2847241-d826648aaeaada30.png" alt="&#39;实现效果‘" title="实现效果"><br><img src="/images/2847241-ccc5d7404bf2a218.png" alt="&#39;实现效果‘" title="实现效果"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Jenkins Android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
