<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2020结</title>
      <link href="/2020/12/23/2020%E7%BB%93/"/>
      <url>/2020/12/23/2020%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>View绘制</title>
      <link href="/2020/06/02/View%E7%BB%98%E5%88%B6/"/>
      <url>/2020/06/02/View%E7%BB%98%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<ul><li>View的绘制流程  </li></ul><p>View的绘制是从ViewRootImpl类的performTraversals方法开始经过measure、layout、draw三个过程将View绘制出来的，measure方法用来测量ViewGroup/View的宽高，layout用来确定View的最终宽高和在容器内的位置，draw绘制View到屏幕上。</p><p><img src="view_process.jpg" alt=""></p><p>performTraversals方法会依次调用perfomrMeasure，performLayout和performDraw，这三个方法依次调用底层View的绘制流程，也就是调用onMeasure、onLayout和onDraw，三个方法通过递归方式完成整个布局的绘制。  </p><ul><li>MeasureSpec<br>MeasureSpec可以理解为“测量规则”或“测量标准”。MeasureSpec用一个32位的int值来表示，高2位代表SpecMode（测量模式），低30位代表SpecSize（规格大小）。代码定义这样的：  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Measure specification mode: The parent has not imposed any constraint</span></span><br><span class="line"><span class="comment"> * on the child. It can be whatever size it wants.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Measure specification mode: The parent has determined an exact size</span></span><br><span class="line"><span class="comment"> * for the child. The child is going to be given those bounds regardless</span></span><br><span class="line"><span class="comment"> * of how big it wants to be.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Measure specification mode: The child can be as large as it wants up</span></span><br><span class="line"><span class="comment"> * to the specified size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(@IntRange(from = <span class="number">0</span>, to = (<span class="number">1</span> &lt;&lt; MeasureSpec.MODE_SHIFT)</span> - 1) <span class="keyword">int</span> size,</span></span><br><span class="line"><span class="function">                                  @MeasureSpecMode <span class="keyword">int</span> mode) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">        <span class="keyword">return</span> size + mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MeasureSpecMode</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//noinspection ResourceType</span></span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里可以看到MeasureSpec将SpecMode和SpecSize打包成一个int值，这样可以避免过多的内存分配，getMode和getSize方法利用MODE_MASK与操作来得到需要的mode和size值。<br>SpecMode有三种模式：  </p><ol><li>UNSPECIFIED：[ʌnˈspesɪfaɪd]未说明的，没有明确的。父容器对于View没有任何限制，想要多大就给多大。  </li><li>EXACTLY：[ɪɡˈzæktli] 明确的。它对应LayoutParams中的match_parent或指定大小值的两种场景。<em>父容器给出了一个确定的范围，如果view设置了具体值这个具体没有超出给定的范围那么就是这个具体值，如果超出了那view的大小就是父容器给定的限制值或者直接就指定限制值也就是match_parent的场景</em>  </li><li>AT_MOST:<em>view想要多大就是多大</em>，至到达到指定的值。对应LayoutParams中的wrap_content。 </li></ol><p>这三个值的设置是站在父容器的角度衡量view的，UNSPECIFIED是父容器没有对view做限制，EXACTLY是父容器给出了一个明确限制值（最大边界）来约束view，AT_MOST则是按照view的想要的来展示，但也有指定值来限定。</p><p><em>对于一个普通的View，它的MeasureSpec是由父容器的MeasureSpec和自身设置的LayoutParam参数来决定的，比如View设置了固定的宽或者高那么它在宽或者高方向上的SpecMode就是EXCATLY，无论它的父容器设置什么测量模式</em></p><p><em>View的绘制流程和activity的生命周期是不同步的，所以在onresume中直接获得view宽高是错误的，可以痛殴VIewTreeObser监听绘制过程或者通过View.post方法投递一个消息队列到尾部，等待looper调用该runnable时view已经初始化</em></p><p>postscript：getMeasureWidth和getWidth的区别</p>]]></content>
      
      
      <categories>
          
          <category> Android基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View事件传递</title>
      <link href="/2020/06/01/View%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92/"/>
      <url>/2020/06/01/View%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<ul><li>MotionEvent<br>MotionEvent是View的动作事件参数，包含集中常见的时间类型：  </li></ul><ol><li>ACTION_DOWN：手指刚接触到屏幕时；  </li><li>ACTION_MOVE：手指在屏幕上移动；  </li><li>ACTION_UP：手指从屏幕上离开的瞬间；<br>MotionEvent的两组位置方式：<br>getX()/getY()：表示动作相对于View左上角位置的x、y坐标；<br>getRawX()/getRawY()：表示动作相对于屏幕左上角位置的x、y坐标；  </li></ol><ul><li>事件分发<br><code>public boolean dispatchTouchEvent(MotionEvent event)</code><br>用于事件的分发，如果时间传递到了当前的View，那么该方法一定会被调用，boolean类型的返回值受View的onTouchEvent(MotionEvent event)和其子View的dispatchTouchEvent(MotionEvnet event)的影响，返回true表示消耗当前时间。<br><code>public boolean onInterceptTouchEvent(MotionEvent event)</code><br>用来判断是否拦截当前事件，返回结果表示是否拦截当前事件。<br><code>public boolean onTouchEvent(MotionEvent event)</code><br>在dispatchTouchEvent方法中被调用，用来处理touch事件，返回结果表示是否消耗当前事件。  </li></ul><p><img src="view_event_work.jpg" alt=""><br><img src="view_event_process.jpg" alt=""></p><p>说明：  </p><ol><li>一个事件序列表示手指从接触屏幕（ACTION_DOWN）经历一些列动作事件到手指刚离开屏幕（ACTION_UP）。  </li><li>某个View拦截事件，那么接下来的一个事件序列都有它来处理（时间能到到达的情况下），并且它的onIntercept不会再被调用。  </li><li>如果View再处理事件过程中，不再消耗ACTION_DOWN事件（onTouch返回false），那么事件序列的其他事件将会被其父元素进行消耗。  </li><li>ViewGroup默认不拦截事件。  </li><li>VIew没有onInterveptTouchEvent方法，View默认的onTouchEvent都会消耗事件（默认返回true）。  </li><li>事件传递是由外向内的，即事件总是先传递给父元素，然后通过父元素分发给子View，通过requestDisallowInterceptTouchEvnet方法来干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android系统架构</title>
      <link href="/2020/05/31/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
      <url>/2020/05/31/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>Android采用分层架构，从上到下分别为<em>应用程序层（apps、System apps）、应用程序框架层（Java API Framework）、系统运行库和运行环境层（Libraries+Android Runtime）和Linux核心层（HAL+Linux Kernel）</em>。</p><p><img src="android_framework.png" alt=""></p><ul><li><p>System apps<br>可以理解为内置的系统应用，可以像调用Java APIFramework一样区调用系统应用，例如我们调用日历区添加一个日常提醒。</p></li><li><p>Java ApI Framewor<br>android中常用的组件</p></li><li><p>Native c/c++ Libraries<br>本地库比Java API Framework更加偏低层，这里包含OpenGl、多媒体框架等内容。 </p></li><li><p>Android Runtime<br>Android运行时环境，也就是Android虚拟机。Android5.0之前是使用Dalvik虚拟机，<em>Dalvik虚拟机是基于JIT（Just in TIme）及时编译的引擎。Android5.0之后采用ART虚拟机，ART虚拟机是基于AOT（Ahead Of Time）作为编译引擎</em></p></li><li><p>Hardware Abstrction Layer<br>硬件抽象层主要是媒体、蓝牙、传感器的库模块。</p></li><li><p>Linux Kernel<br>Android平台的最底层，直接与硬件交互，负责硬件驱动、进程管理、内存管理、网络管理等功能。</p></li></ul><p><em>什么是JIT和AOT？</em><br>在Android中Java代码会被转换成DEX字节码文件，DEX字节码文件是Android虚拟机可以识别的，Android虚拟机把字节码在转化为机器能识别的机器码。<br>Dalvik虚拟机给予JIT编译，JIT也叫及时编译器，JIT工作原理是在应用运行时，首先将一部分DEX字节码转化为机器码，在程序执行的过程中再陆续将更多代码编译并缓冲，这样做的好处是内存占用少，但CPU再应用运行期间相对消耗大。<br>AOT叫做提前编译器，它是在应用的安装期间就将DEX字节码转化为了机器码，并将其存储在设备上。这样做的好处是在应用运行时占用CPu资源少一些，因为已经转化成了机器码，相对内存占用上多一些。</p>]]></content>
      
      
      <categories>
          
          <category> Android基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片加载如何避免OOM</title>
      <link href="/2020/05/30/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DOOM/"/>
      <url>/2020/05/30/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DOOM/</url>
      
        <content type="html"><![CDATA[<p>内存中Bitmap大小的计算公式：<br>长占用的像素 <em> 宽占用的像素 </em> 每个像素占用的内存<br>避免OOM也就是要减小图片在内存中的大小，有两种方式等比缩小长宽和减少每个像素占用的内存。</p><ul><li><p>等比缩小长宽：<br>Bitmap的创建是通过BitmapFactory的工厂方法decodeFile()、decodeStream()、decodeByteArray()、decodeResource()。这些方法在创建Bitmap使都一个参数Options，Options中的属性inSampleSize用来对图片进行长宽的设置，inSampleSize的值是2的幂次方，通过设置合适的值来对图片进行缩放操作。  </p></li><li><p>减少像素内存：<br>Options中的属性inPreferredConfig，通过调整这个值的属性来改变每个像素所占的内存，默认值是ARGB_8888,修改为RGB_565或ARGB_4444可以减少一半的内存。  </p></li></ul><table><thead><tr><th>值</th><th>含义  </th></tr></thead><tbody><tr><td>ARGB_8888</td><td>A(Alpha)、R(Red)、G(Green)、B(Blue)各占8位的精度，加起来32位的精度（即4个字节），也就是一个像素占4个字节的长度</td></tr><tr><td>ARGB_4444</td><td>A(Alpha)、R(Red)、G(Green)、B(Blue)各占4位的精度，加起来16位的精度（即2个字节），也就是一个像素占2个字节的长度</td></tr><tr><td>RGB_565</td><td>R(Red)占5位精度、G(Green)占6位精度、B(Blue)占5位精度，一共16位精度，也就是2个字节，不携带透明度信息</td></tr><tr><td>ALPHA_8</td><td>每个像素占位（即一个字节），只办函透明度值，不携带颜色信息</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Android基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPC机制</title>
      <link href="/2020/05/29/IPC%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/05/29/IPC%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<ul><li>进程与线程<br><em>进程一般指一个执行的单元，也可以称作正在运行的程序实例</em>。<em>线程是CPU进行运算调度的最小单元</em>，它的系统资源是有限的，它是包含在进程之中。所以进程与线程是包含与被包含的关系。  </li><li><p>什么是IPC？<br>IPC全称Inter-Process Communication，即进程间通信。一般应用采用多进程有是为了使应用能够获取更多的内存空间。由于一个进程对应分配一个虚拟机，进程与虚拟机的一一对应，造成我们对同一个类的对象在不同进程中就产生了对个副本，例如有processOne和processTwo两个进程，它们都有一个类A.class，那么在两个进程中的A.class是互不干扰的。总结起来对进程会造成一下几个问题：<br><em>1. 静态成员和单例模式失效；</em><br><em>2. 线程同步机制生效；</em><br><em>3. SharedPreferences可靠性降低（进程并发写可能异常）</em><br><em>4. Application多次创建（可以理解成Application的创建和进程的创建是一致的）</em>  </p></li><li><p>Binder机制<br>Binder是android进程间通信的方式，Binder时基于C/S架构，主要有四部分组成：<br><em>1. Client（客户端进程）</em><br><em>2. Server（服务端进程）</em><br><em>3. ServiceManager（提供注册、查询和返回代理服务对象的功能）</em><br><em>4. Binder驱动（主要进程间的连接，进程间数据交互等基础底层操作）</em>      </p><p><em>服务器通过Binder驱动在ServiceManager中注册服务</em><br><em>客户端通过Binder驱动查询Servicemanager中注册的服务</em><br><em>SreviceManager通过Binder驱动返回服务器代理对象</em><br><em>客户端拿到服务器的代理对象后即可进行进程间的通信</em>  </p></li><li><p>IPC方式比较  </p></li></ul><table><thead><tr><th></th><th>优</th><th>缺</th><th>适用场景  </th></tr></thead><tbody><tr><td>Bundle</td><td>使用简单</td><td>传输Bundle支持的数据类型</td><td>四大组件间的数据传递 </td></tr><tr><td>文件共享</td><td>使用简单</td><td>不适合高并发，无法进行即时通信</td><td>用于实时性不高的场景  </td></tr><tr><td> AIDL</td><td>功能强大 支持一对多并发下的通信，支持实时</td><td>使用较复杂，需要做好线程同步问题</td><td>一对多通信且有RPC需求 </td></tr><tr><td> Messenger</td><td>功能一般，支持一对多串行通信，支持实时通信</td><td>不支持RPC、不能很好处理高并发、数据通过Message进行传输，只能传输Bundle支持的数据类型</td><td>低并发的一对多即时通信 </td></tr><tr><td>ContentProvider</td><td>在数据源访问上功能强大，支持一对多的并发数据共享，可通过call操作扩展其他操作</td><td>提供数据源的CRUD操作</td><td>进程一对多的数据共享  </td></tr><tr><td>     Socket</td><td>功能强大，支持网络传输数据流、支持一对多的实时通信</td><td>实现较繁琐</td><td>网络数据共享</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Android基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android性能优化</title>
      <link href="/2020/05/27/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2020/05/27/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>Android的性能优化主要从四方面入手，内存优化、布局优化、网络优化和安装包优化。  </p><ul><li><p>常用检查工具<br><em>LeakCanary</em>是一个三方检测内存泄漏的工具库 ，集成后会自动检测应用运行期间的内存泄漏，并直观的输出。<br>Android自带的<em>Android Profiler</em> ，可以检测CPU、MEMERY、NETWORK三方的性能。<br><em>BlockCanary</em>是一个三方用来检测UI卡顿的工具库，像LeakCanary一样集成后当发生UI卡顿现象时会输出卡顿的信息，通过输出的信息可以很方便的来定位导致卡顿的原因。</p></li><li><p>内存优化<br>内存优化的方式时避免内存泄漏（节流）、增加内存（开源）。<br>常见的内存泄露：</p></li></ul><ol><li>单例导致的泄漏。在创建单例时传入了具体页面的Context，由于单例的静态属性，导致单例一致持有该Context引用，一直到应用程序结束。正确的做法是创建单例时应用传入应用级别的Context，也就是Application的Context，这样就保证了单例生命周期与传入Context的统一。  </li><li>静态变量导致的内存泄漏。JVM中可以知道静态变量是在方法区的，它的生命周期是从类加载到应用程序结束，如果静态变量中持有了具体页面的Context就会导致页面finish后Context不会被GC，这样就导致了内存泄露。  </li><li>非静态内部类导致的内存泄露。非静态内部类创建呢的Handle或Thread在执行延时操作时一直持有当前的Activity引用，这时候在Activity finish后就会导致内存泄漏。解决方式是使用静态内部类并用弱引用调用Activity；另外还可以在onDestroy中调用handler.removeCallbacksAndMessages取消所有事件消息。  </li><li>使用资源没有及时关闭。常见操作有：数据流操作完没有关闭、bitmap没及时Recycle等</li><li>三方的没及时接绑。EventBus（unregister）和Rxjava中（dispose）。  </li><li>动画执行导致的。在Activity finish时动画执行还在进行。解决就是在onDestroy时cacel动画。  </li><li>WebView导致的泄漏。 WebView即使调用了destroy也会导致内存泄漏。解决方式时使用弱引用WeekReference或者将WebView所在的Activity置于另外一个进程中。</li></ol><p>增加内存方案一般会在Application下添加largeHeap=”true”，活着新开进程来时应用的内存总空间增大。</p><ul><li>布局优化  16ms</li></ul><ol><li>使用RelativeLayout减少View层级</li><li>利用<include>抽离常用的布局</include></li><li>使用<viewstub>加载不常用的布局</viewstub></li><li>使用<merge>减少布局嵌套</merge></li><li>减少多余的背景绘制</li><li>canvas.clipRect()裁剪可见区域，其他区域就不会被多余绘制。</li></ol><ul><li>网络优化  </li></ul><ol><li>合理合并网络请求</li><li>网络缓存</li><li>大数据分页请求</li><li>网络数据传输压缩（Gzip）</li><li>图片压缩、缩略图</li></ol><ul><li>安装包优化<br>apk的构成：</li></ul><ol><li>assets文件夹：配置文件、资源文件 文件夹内的资源时通过AssetManager类内方法获取。  </li><li>res：资源文件，文件名会自动生成对应ID映射到.R文件中。  </li><li>META-INF：保存呢应用的签名信息，保证APK的完整性。  </li><li>AndroidManifest.xml：描述应用的配置信息。  </li><li>classes.dex：Dalvik虚拟机可执行的字节码文件，SDK下dx工具将JAVA字节码转化为Dalvik字节码。  </li><li>resources.arsc：资源文件和资源ID间的映射关系。  </li></ol><p>根据spk的构成做一下几方面的优化：  </p><ol><li>混淆：使用proGuard代码混淆工具，它包含了代码的压缩、优化、混淆等功能。  </li><li>资源优化：利用lint工具删除冗余代码，资源文件的最小化等。  </li><li>重复功能库：去除一些功能重复库的引用。  </li><li>插件化：功能模块放在服务器上，按需下载。<br>5.so库优化：保留v7版本，删除armeabi和v8版本的SO库，v7库可以按足市场上绝大多树手机的要求。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android动画分类</title>
      <link href="/2020/05/26/Android%E5%8A%A8%E7%94%BB%E5%88%86%E7%B1%BB/"/>
      <url>/2020/05/26/Android%E5%8A%A8%E7%94%BB%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<ul><li>帧动画<br>通过在xml中的一组图片的播放来实现。</li><li>补间动画<br>分为旋转、移动、缩放、透明度四类动画，以及他们的组合来实现动画效果。  </li><li><p>属性动画<br>属性动画目前使用场景最多，分类两种ViewPropertyAnimator和ObjectAnimator。前者是通用的动画，例如旋转、透明度、位移和缩放,简单通过View.animator()就可得到ViewPropertyAnimator。后者通过ObjectAnimator.of属性()来返回一个ObjectAnimator，ObjectAnimator需要重绘View所以要调用invalidate()来刷新绘制，最后通过start()方法启动动画。  </p></li><li><p>补间动画和属性动画的区别？</p></li></ul><p>补间动画只是在父VIew层利用Matrix不多绘制View，达到移动的效果，其实View并没有发生变化，还在动画之前的位置。<br>属性动画是真正改变了View的属性值，真正的改变View的具体属性值的。</p>]]></content>
      
      
      <categories>
          
          <category> Android基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP和UDP</title>
      <link href="/2020/05/25/TCP%E5%92%8CUDP/"/>
      <url>/2020/05/25/TCP%E5%92%8CUDP/</url>
      
        <content type="html"><![CDATA[<ul><li>TCP（（Transmission Control Protocol，传输控制协议））</li></ul><p>TCP协议是面向连接、可靠的字节流传输服务。TCP协议在C/S间数据交换前，需要先在上方建立一个TCP连接，之后才开始传输数据，并提供超时、重发、丢弃重复数据、数据校验和流量控制等功能。<br>特点：<em>面向连接、可靠通信、面向字节流</em><br>应用层协议：HTTP、HTTPS、SSH、FTP、SMTP</p><ul><li>UDP（User Data Protocol，用户数据报协议）</li></ul><p>UDP是一个面向数据报的传输层协议，不具有可靠性，只是把数据发出去，不保证数据是否能到达S端。因为UDP在传输数据前不需要建立一个连接，所以它的传输效率很快，不能保证数据的可靠。<br>特点：<em>无连接、不可靠、面向数据报</em><br>应用层协议：DHCP、DNS</p><ul><li>TCP协议建立连接的三次握手</li></ul><p><img src="tcp_create_connection.jpg" alt=""></p><p><em>第一次握手</em>（请求建立连接）C端发送建立连接请求，携带序列号seq=x 标示SYN=1，此时C端处于SYN_SEND状态；<br><em>第二次握手</em>（确认请求）S端收到后，发出确认信息，确认信息ACK=x+1，同时携带自己的序列号SYN=1，seq=y；<br><em>第三次握手</em>（建立连接）C端收到S端的确认请求后，向S端发送确认ACK=y+1，S端收到请求后两端都处于Established状态，表示当前的一次TCP连接成功。</p><ul><li>TCP断开连接的四次挥手</li></ul><p><img src="tcp_finish_connection.jpg" alt=""></p><p><em>第一次挥手</em>（请求释放）C端发送释放连接的请求信号FIN=1，seq=u，此时C端处于FIN WAIT状态,不再发送数据给S端；<br><em>第二次挥手</em>（确认请求）S端收到释放请求后，发送确认收到请求释放，ACK=1,ack=u+1,此时S度啊处于CLOSE EAIT状态，不再接收C端数据，但是需要发送给C端的数据可继续发送；<br><em>第三次挥手</em>（确认释放）当S端不再有数据需要发送给C端时，发送却是释放连接，携带FIN=1，seq=w，ACK=1，ack=u+1，此时S端处于LAST ACK状态，等待C端的最终确认；<br><em>第四次挥手</em>（最终释放确认）当C端收到了确认释放后，随即发送最终释放确认，ACK=1，ack=w+1，seq=u+1；此时C端在等待2MSL后关闭连接，S端收到请求后同样关闭。</p><ul><li><p>为什么需要三次握手？<br>如果是两次握手，服务端确认请求后，不知道客户端是否能收到了消息，服务端的消息得不到确认。(服务端消息等不到确认)<br>如果客户端发送的请求网络延迟了，超时后有客户端重新发起请求，倘若在重发请求正常进行完毕后，再收到之前网络拥塞的请求，再和服务端建立连接，这个时候就可能服务端一直等待，导致服务端连接资源浪费。  </p></li><li><p>为什么第三次握手是seq=x+1，而不是x+2？<br>从握手的规律可以看出来seq在确认请求中会变做确认表示即ack，ack会在seq值的基础上加1，<em>同时TCP规定，SYN不携带数据，但会消耗掉一个序列号，SYN=1时会消耗seq的一个值（即加1），第三次握手ACK=1、SYN不等于1，而ACK=1不消耗seq所以seq=x+1而不是x+2，挥手中FIN也和SYN一样</em></p></li><li><p>TCP建立连接后客户端出现故障会怎样？<br>服务端有个计数器，一般两小时，两小时如果没有收到任何数据，会发送探测报文段，发了几个报文段如果还是没反应，服务端就会关闭连接。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP、HTTPS和HTTP2.0</title>
      <link href="/2020/05/23/HTTP%E3%80%81HTTPS%E5%92%8CHTTP2-0/"/>
      <url>/2020/05/23/HTTP%E3%80%81HTTPS%E5%92%8CHTTP2-0/</url>
      
        <content type="html"><![CDATA[<h3><span id="什么是http">* 什么是HTTP</span></h3><p>HTTP（HyperText Transfer Protocol）中文全名超文本传输协议，HTTP是用于客户端与服务器间请求响应的协议。HTTP是应用层的协议，和其他该层协议一样，它是服务于某一类具体应用的协议。</p><h3><span id="什么是httpshyper-text-transfer-protocol-over-securesocket-layer">* 什么是HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer）</span></h3><p>HTTPS是在HTTP的基础上加上了SSL/TLS层<br>TLS（Transport Layer Security，传输层安全协议）、SSL(Secure Sockets Layer 安全套接层)</p><p>SSL由NetScape公司设计，共有三个版本1、2、3。SSL 3.0得到大规模使用，而TLS是SSL标准化后的升级版</p><p>SSL/TLS握手阶段工作流程：  </p><p><img src="https.jpg" alt=""></p><ol><li><p>客户端向服务端发出加密通信请求(ClientHello)</p><blockquote><p>携带支持的协议，例如TLS 1.0版<br>客户端生成的随机数random1，后面用于生成“对话密钥”<br>支持的加密方法，比如RSA公钥加密<br>支持的压缩的方法  </p></blockquote></li><li><p>服务端收到请求，做出响应(ServerHello)</p><blockquote><p>确认加密通信协议，例如TLS 1.0版。如果协议与服务端支持的不一致，则关闭加密通信。<br>服务端生成一个随机数random2，后面用于生成“对话密钥”<br>确认加密方法，例如RSA公钥加密<br>携带服务端证书给客户端  </p></blockquote></li><li><p>客服端做证书验证和公钥对随机数加密发送给服务端(ClientResponse)</p><blockquote><p>验证证书的安全性<br>验证通过后，客户端生成随机数pre-master secret，然后使用证书中的公钥进行加密，发送给服务端  </p></blockquote></li><li><p>服务端私钥解密获得随机数(ServerResponse)</p><blockquote><p>服务端收到公钥加密的内容，在服务端使用私钥解密后得到pre-master secret，然后根据random1、random2和pre-master secret通过一定的算法得出对称加密的秘钥，作为后面交互过程中的对称密钥。同时客户端也使用random1、random2和pre-master secret，同样的算法生成对称密钥。  </p></blockquote></li><li>后续操作使用上一步生成的对称密钥对传输的内容加密和解密。</li></ol><p>如何保证公钥不被篡改？</p><blockquote><p>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p></blockquote><p>什么是对称加密？</p><blockquote><p>加密和解密用的都是相同的密钥，优点是速度快，缺点是安全性低，常见的对称加密DES、AES等</p></blockquote><p>什么是非对称加密？</p><blockquote><p>非对称加密由一对密钥对，分为公钥和私钥。一般私钥自己持有，公钥可以公开给对方，优点是安全性比对称密钥高，缺点是数据传输效率比对称密钥低。采用公钥加密的数据只能由对应的私钥来解密。常见的非对称加密算法RSA。</p></blockquote><p><em>HTTPS在传输过程中采用了对称加密和非对称加密结合使用，使用非对称加密传递密钥，然后使用对称密钥进行数据传输的加密和解密。二者的结合既保证了传输的安全性，也保证了数据传输的效率</em></p><h3><span id="http-20">* HTTP 2.0</span></h3><ol><li>（二进制格式）HTTP 2.0采用二进制格式传输，而HTTP1.x使用纯文本的形式传输数据</li><li>（Header压缩）HTTP 2.0对已经发送的Header使用键值对建立索引表（两端维护的索引表），相同的Header使用索引表示，即Header压缩。</li><li>（服务器推送）服务端可以进行主动推送  </li><li>（多路复用）一个TCP连接被划分为多个流，客户端借助流和服务端建立全双工通信，且流具有优先级。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP状态码</title>
      <link href="/2020/05/22/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2020/05/22/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>状态码分类：</p><table><thead><tr><th>码</th><th>类别</th><th>原因  </th></tr></thead><tbody><tr><td>1xx</td><td>Information（信息性状态码）</td><td>接受的请求正在处理 </td></tr><tr><td>2xx</td><td>Success（成功状态码）</td><td>请求正常处理完成 </td></tr><tr><td>3xx</td><td>Redirection</td><td>需要进行附加操作来完成请求 </td></tr><tr><td>4xx</td><td>Client Error（客户端错误）</td><td>客户端请求出错，服务端无法处理 </td></tr><tr><td>5xx</td><td>Server Error（服务端出错）</td><td>服务端处理请求出错</td></tr></tbody></table><ul><li>200 OK</li></ul><p>客户端发送给服务器的请求<em>正常处理并返回</em>。</p><ul><li>204 No Content</li></ul><p>客户端发送给服务端的请求被服务端成功处理，但是在返回的相应报文中没有实体内容（也就是没有资源返回）。 </p><ul><li>206 Patail Content</li></ul><p>客户端进行了<em>范围请求（响应报文中Content-Range制定了范围的实体）</em>，并且服务器成功执行了这部分的GET请求。</p><ul><li>301 Moved Permanly</li></ul><p><em>请求被永久性重定向</em>，表示请求的资源已经被分配到了新的URI，在今后的请求中使用那个新的URI。可以通过这个响应代码来防止由于URI变更而导致老URI失效。</p><ul><li>302 Found</li></ul><p><em>请求临时性重定向</em>，表示请求希望使用新的URI</p><ul><li>303 See Other</li></ul><p>当前的请求的响应在另外一个URI上被找到，并且客户端应当采用GET请求访问那个资源。</p><ul><li>304 Not Modified</li></ul><p>客户端发送了一个带条件（if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一）的GET请求且已被允许，而资源内容并未被修改过，则服务端返回该错误码。</p><ul><li>307 Temporary Redirect</li></ul><p>临时性重定向，与3030类似，但是这里会准照浏览器标准执行。</p><ul><li>400 Bad Request</li></ul><p><em>当前请求存在语法错误</em></p><ul><li>401 Unauthorized</li></ul><p>未经许可，请求身份验证。</p><ul><li>403 Forbidden</li></ul><p>服务器拒绝访问（访问权限出现问题）</p><ul><li>404 Not Found</li></ul><p><em>服务器找不到请求的资源。</em></p><ul><li>500 Inter Server Error</li></ul><p>服务器在执行请求是发生了错误。</p><ul><li>503 Server Unavailable</li></ul><p>服务不可用，服务器由于超载或停机维护，无法处理请求。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSI网络模型</title>
      <link href="/2020/05/22/OSI%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/05/22/OSI%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="osi.jpg" alt=""></p><p>OSI（Open System Interconnection）全称开放系统互联，它把网络通信的工作分为7层，包括应用层、表现层、会话层、传输层、网络层、数据链路层和物理层。传输层、网络层、数据链路层和物理层叫做低四层，这四层和数据的移动相关。应用层、表现层和会话层叫做高三层，包含了应用程序级别的数据，每一层负责具体的一项工作将数据想向下一层传送。</p><ul><li>应用层</li></ul><p>应用层就是为了满足应用进程间的通信和交互任务。该层的协议有HTTP、HTTPS、FTP、POP3、SMTP等</p><ul><li>表现层</li></ul><p>表现层提供数据的编码和转换功能。数据的压缩和解压缩，加密和解密等工作都是在表现层完成。</p><ul><li>会话层</li></ul><p>会话层提供访问验证和会话管理在内的建立和维护应用间通信的机制，例如服务器验证用户登陆便由会话层完成。</p><ul><li>传输层</li></ul><p>传输层主要负责建立端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务。<em>端口号即是这里的端，TCP和UDP就是这层的协议</em></p><ul><li>网络层</li></ul><p>网络层的任务是选择合适的网间路由和交换结点，确保数据及时传送。</p><ul><li>数据链路层</li></ul><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测（也就是帧编码和误差纠错的功能）。数据链路层协议又分为两个子层：逻辑链路控制（LLC）和媒体访问控制（MAC）。</p><ul><li>物理层</li></ul><p>信号的最终传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList和LinkedList</title>
      <link href="/2020/05/21/ArrayList%E5%92%8CLinkedList/"/>
      <url>/2020/05/21/ArrayList%E5%92%8CLinkedList/</url>
      
        <content type="html"><![CDATA[<ul><li>源码分析</li></ul><ol><li>ArrayList  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">     * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure><p>ArrayList内部实现元素是放在elementData的数组中的，并且默认数组是空的，当增加元素时才扩展到DEFAULT_CAPACITY，这里DEFAULT_CAPACITY的值时10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">     *         is negative</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ArrayList的构造函数有三个，一个无参的设置空数组，有参的一个传入容量初始化数组，另外一个通过Collection对象对数组初始化赋值。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment">     * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment">     * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum size of array to allocate.</span></span><br><span class="line"><span class="comment">     * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment">     * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment">     * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">     * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>add方法中主要的调用是ensureCapacityInternal方法，ensureCapacityInternal方法主要做了一个扩容的处理，这里容器的最小值被赋予了DEFAULT_CAPACITY，也就是10，扩容的处理在grow方法中完成，这里看到新容量的大小等于老容量加上老容量的一半，也就是新容量在老容量的基础上再增加它的一半。后面对数组进行重新创建和赋值。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">     * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment">     * indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the element that was removed from the list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment">     * if it is present.  If the list does not contain the element, it is</span></span><br><span class="line"><span class="comment">     * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span></span><br><span class="line"><span class="comment">     * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment">     * changed as a result of the call).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>remove方法比较简单入参是索引的通过索引找到数组中的元素，通过本地方法System.arraycopy将index+1的元素赋值到索引从index到size-1，这里就相当于对index后面的元素进行了向前移位的操作。<br>如果入参是元素o就通过遍历找到它的索引然后再根据它的索引进行remove。  </p><p><em>这里modCount变量是一个叫做fail-fast的机制，就是当我们对ArrayList元素进行一些操作时，若果又有其他线程对其内容进行修改时，可以第一时间通过modCount的值来判定，当再操作中modCount值不一值就抛出ConcurrentModificationException，也表明ArrayList是线程不安全的</em></p><p>这里get方法就不再赘余，因为ArrayList这里时数组，可以通过下标方便的查找，ArrayList实现RandomAccess接口，作为一种标示说明它的访问时随机的</p><ol start="2"><li>LinkedList  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Pointer to first node.</span></span><br><span class="line"><span class="comment">    * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">    *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Pointer to last node.</span></span><br><span class="line"><span class="comment">    * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">    *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedList的内部实现使用双向链表来存储元素的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends all of the elements in the specified collection to the end of</span></span><br><span class="line"><span class="comment"> * this list, in the order that they are returned by the specified</span></span><br><span class="line"><span class="comment"> * collection's iterator.  The behavior of this operation is undefined if</span></span><br><span class="line"><span class="comment"> * the specified collection is modified while the operation is in</span></span><br><span class="line"><span class="comment"> * progress.  (Note that this will occur if the specified collection is</span></span><br><span class="line"><span class="comment"> * this list, and it's nonempty.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts all of the elements in the specified collection into this</span></span><br><span class="line"><span class="comment"> * list, starting at the specified position.  Shifts the element</span></span><br><span class="line"><span class="comment"> * currently at that position (if any) and any subsequent elements to</span></span><br><span class="line"><span class="comment"> * the right (increases their indices).  The new elements will appear</span></span><br><span class="line"><span class="comment"> * in the list in the order that they are returned by the</span></span><br><span class="line"><span class="comment"> * specified collection's iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which to insert the first element</span></span><br><span class="line"><span class="comment"> *              from the specified collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数有两个，有参的Collection元素集构造函数中调用addAll方法，addAll方法中通过遍历增加链表元素。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Links e as last element.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">       last = newNode;</span><br><span class="line">       <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">           first = newNode;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           l.next = newNode;</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>add方法中主要调用linkLast方法，新建新增的Node元素，Node元素prev变量之前当前的last，next为null，然后找last.next指向newNode。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.  Shifts any</span></span><br><span class="line"><span class="comment"> * subsequent elements to the left (subtracts one from their indices).</span></span><br><span class="line"><span class="comment"> * Returns the element that was removed from the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unlinks non-null node x.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>remove主要通过两个方法实现，node方法通过index找到对应的Node元素，然后通过unlink方法链表重新链接，将x元素从链表中移除并置为null，以便GC回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法直接通过node方法遍历等到Node元素，然后Node.item拿到元素值。</p><ol start="3"><li>两者对比  </li></ol><h5><span id="1-arraylist内部是通过动态数组结构实现空间利用相对有损耗linkedlist内部是通过双向链表实现空间利用上不存在浪费因为元素的多少和链表长度是一致的">1    .ArrayList内部是通过动态数组结构实现，空间利用相对有损耗；LinkedList内部是通过双向链表实现，空间利用上不存在浪费，因为元素的多少和链表长度是一致的。</span></h5><h5><span id="2-arraylist因为是数组实现所以删除-插入操作相对较慢通过systemarraycopy本地方法完成存在元素移动但是它的查找操作可随机访问实现radomaccess接口linkedlist链表在删除-插入效率高不存在元素移动只需要改变目标元素的前驱和后继就可以实现">2. ArrayList因为是数组实现，所以删除、插入操作相对较慢（通过System.arraycopy本地方法完成，存在元素移动），但是它的查找操作可随机访问（实现RadomAccess接口）；LinkedList链表在删除、插入效率高，不存在元素移动，只需要改变目标元素的前驱和后继就可以实现。</span></h5>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java引用类型</title>
      <link href="/2020/05/19/java%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/05/19/java%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>java引用类型分为四类：强引用、软引用、弱引用和虚引用。<br>强引用：就是我们最常用的直接new对象创建的引用，垃圾回收器将永远不会回收被引用的对象。内存不足的情况JVM会直接抛出OOM。<br>软引用（SoftReference）：软引用在内存不足的情况下会被垃圾回收器回收。软引用常被用在存储一些内存敏感的缓冲，例如网页缓冲、图片缓冲等。<br>弱引用（WeekReference）：弱引用的强度比软引用更弱一下，无论内存是否足够，只要当GC开始，被扫描到的弱引用的对象就会被回收。<br>虚引用（PhantomReference）：虚引用是最弱的一种引用关系。它随时可能被回收，并且对象是无法通过虚引用获取的。虚引用主要用来跟踪对象被GC回收的活动，当被虚引用修饰的对象在被回收时，JVM会把虚引用加入到与之关联的引用队列（ReferrenceQueue）中。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2020/05/19/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/19/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>懒汉式</li></ul><p>懒汉式是在调用时创建实例，用时间来换空间。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleTon instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(LazySingleTon.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重判断保证了原子性和可见性（synchronized），同时利用volatile来保证有序性，避免指令的重排。  </p><ul><li>饿汉式  </li></ul><p>饿汉式在类加载的时候就已经创建好对象，在使用时直接就可以拿到实例，标准的空间换时间。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon instance = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态内部类实现  </li></ul><p>当外部类加载时不会导致内部类的立即加载，只有当getInstance方法被调用时才会去加载内部类，实现了加载。因为类的加载只会加载一次，所以它时线程安全的。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticInnerSingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticInnerSingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTonHolde</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerSingleTon instance = <span class="keyword">new</span> StaticInnerSingleTon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerSingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleTonHolde.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举实现  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ESingleTon &#123;</span><br><span class="line">     single;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperate</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"singletonOperate"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final、finally和finalize</title>
      <link href="/2020/05/19/final%E3%80%81finally%E5%92%8Cfinalize/"/>
      <url>/2020/05/19/final%E3%80%81finally%E5%92%8Cfinalize/</url>
      
        <content type="html"><![CDATA[<ul><li>final可以修饰类、方法和变量。修饰类代表这个类不可被继承。修饰方法表示该方法不可被重写。修饰变量表示该变量在赋值后不可改变。  </li><li>finally保证重点代码一定会被执行的一种机制。通常使用组合try-catch-finally。  </li><li>finalize是Object类的一个方法，当垃圾回收器将要回收对象所占内存之前被调用，这个方法来用保证来对象被回收前完成特定的资源回收。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程间通信方式</title>
      <link href="/2020/05/15/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/05/15/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>这里将线程间通信的途径分为两类：同享内存和消息传递。  </p><ul><li>同享内存</li></ul><ol><li>volatile关键字的使用</li></ol><p>就是利用volatile关键字的可见性，多个线程对它进行监控在其变量发生变化后执行对应线程的操作。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadCommunication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> STATE_RUN_A = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> STATE_RUN_B = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> STATE_RUN_C = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> state = STATE_RUN_A;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//这里睡眠3s等待BC线程</span></span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> c = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (state == STATE_RUN_A) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"threadA is running!"</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                            state = STATE_RUN_B;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (state == STATE_RUN_B) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"threadB is running!"</span>);</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            counter = counter &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">while</span> (counter &lt; <span class="number">1</span> &lt;&lt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">                        state = STATE_RUN_C;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (state == STATE_RUN_C) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"threadC is running!"</span>);</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            counter = counter &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">while</span> (counter &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"threadC finish counter："</span> + counter);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="thread_communication_volatile.jpg" alt=""></p><ul><li>消息传递</li></ul><ol><li>Object.wait()\notify()</li></ol><p>在线程中调用该线程锁对象是wait方法是，该线程就被放入等待队列，直到被其他线程通知notify。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadCommunication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"threadB is running!"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            counter = counter &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">while</span> (counter &lt; <span class="number">1</span> &lt;&lt; <span class="number">4</span>);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (counter == <span class="number">1</span> &lt;&lt; <span class="number">4</span>) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"threadC is running!"</span>);</span><br><span class="line">                            <span class="keyword">do</span> &#123;</span><br><span class="line">                                counter = counter &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                            &#125; <span class="keyword">while</span> (counter &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                            System.out.println(<span class="string">"threadC finish counter："</span> + counter);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                lock.wait();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadC.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="thread_communication_wait.jpg" alt=""></p><ol start="2"><li>.join() {Thread.join}</li></ol><p>当一个线程调用另外一个线程的join方法时，当前的线程就会阻塞等待被调用join方法的线程执行完毕后才能继续执行，所以join方法用来保证线程执行的顺序。  </p><ol start="3"><li>CountDownLatch类</li></ol><p>CountDownLatch类可以使线程等待其他线程执行完毕后再执行。<br>通过一个计数器来实现，CountDownLatch初始化传入的count代表等待count个线程执行完毕后等待的线程才能恢复执行。一般有几个应用场景：<br>场景一：<br>有多个线程依赖其他多个线程的执行完的结果，这是等待的await，被等待的线程执行完调用coutdown然后计数器减一，直到减为0就恢复多个线程的执行；<br>场景二：<br>实现多个线程同时执行，多个线程都设置await coutdown设置为1 在主线程中调用countdown让多个线程同时执行运行。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadCommunication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"threadA await"</span>);</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"threadA is running!"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="string">"threadB is running!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        counter = counter &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                        System.out.println(<span class="string">"threadC is running! counter="</span> + counter);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">while</span> (counter &lt; <span class="number">1</span> &lt;&lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="thread_communication_counntdownlatch.jpg" alt=""></p><ol start="4"><li>LockSupport类<br>LockSupport是JDK中用来实现线程阻塞和唤醒的工具。使用它可以在任何场合使线程阻塞，可以指定任何线程进行唤醒。<br>LockSupport的设计核心是“许可”，park是等待一个许可，unpark是为某一线程提供一种许可，如果某线程A调用park，那么除非另外一个线程调用unpark(A)给A一个许可，否则线程A将阻塞在park操作上。还有就是unpark可以在park前调用，也就是先提供许可，等到后面调用park时在消耗之前的许可。  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadCommunication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"threadA park"</span>);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(<span class="string">"threadA is running!"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"threadB park"</span>);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(<span class="string">"threadB is running!"</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"threadB unpark threadA"</span>);</span><br><span class="line">                LockSupport.unpark(threadA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"main thread unpark threadB"</span>);</span><br><span class="line">        LockSupport.unpark(threadB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="thread_communication_locksupport.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA线程池的使用</title>
      <link href="/2020/05/15/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/05/15/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>线程池的作用  </li></ul><ol><li>线程池可以有效控制系统内执行线程的数量；</li><li>根据系统的状况可以手动或自动调整执行线程的数量，让其他线程排队等候；  </li><li>线程池可以有效减少线程创建和销毁的次数，使得线程可以复用，可以执行多任务。  </li></ol><ul><li>JAVA中常用的线程池  </li></ul><ol><li>newSingleThreadExecutor()<br>创建一个单线程的线程池，线程池中只有一个线程在工作（相当于单线程串行执行所有任务）。如果唯一的线程异常结束，将会创建一个新的线程来代替，同时任务按照队列顺序执行。<br>方法解释：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executors.newSingleThreadExecutor()</span></span><br><span class="line"><span class="comment">     * Creates an Executor that uses a single worker thread operating</span></span><br><span class="line"><span class="comment">     * off an unbounded queue.</span></span><br><span class="line"><span class="comment">     * 使用单操作线程创建一个没有限制队列的Executor</span></span><br><span class="line"><span class="comment">     *  (Note however that if this single</span></span><br><span class="line"><span class="comment">     * thread terminates due to a failure during </span></span><br><span class="line"><span class="comment">     * execution prior toshutdown, a new one will </span></span><br><span class="line"><span class="comment">     * take its place if needed to execute</span></span><br><span class="line"><span class="comment">     * subsequent tasks.)</span></span><br><span class="line"><span class="comment">     * 但是请注意，如果该单线程由于在关机之前执行期间失败而终</span></span><br><span class="line"><span class="comment">     * 止，则在执行后续任务时需要使用一个新线程。</span></span><br><span class="line"><span class="comment">     * Tasks are guaranteed to execute</span></span><br><span class="line"><span class="comment">     * sequentially, and no more than one task will </span></span><br><span class="line"><span class="comment">     * be active at any given time. </span></span><br><span class="line"><span class="comment">     * 确保任务按顺序执行，并且在任何给定时间都不会激活一项以上</span></span><br><span class="line"><span class="comment">     * 的任务。</span></span><br><span class="line"><span class="comment">     * Unlike the otherwise equivalent</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> newFixedThreadPool(1)&#125; the returned </span></span><br><span class="line"><span class="comment">     * executor is guaranteed not to be </span></span><br><span class="line"><span class="comment">     * reconfigurable to use additional threads.</span></span><br><span class="line"><span class="comment">     *与其他等效的&#123;<span class="doctag">@code</span> newFixedThreadPool（1）&#125;不同，保</span></span><br><span class="line"><span class="comment">     证返回的执行程序不可重新配置为使用其他线程。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created single-threaded Executor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>newFixedThreadPool(int nThreads)</li></ol><p>创建一个固定线程数量的线程池，每次提交的任务就创建一个线程，直到线程数量达到线程数量限制。其余多的任务进入等待队列，直到有空闲的线程。如果有线程异常结束，那么就会创建一个新的线程来代替它。<br>方法解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executors.newFixedThreadPool(int nThreads)</span></span><br><span class="line"><span class="comment">     * Creates a thread pool that reuses a fixed </span></span><br><span class="line"><span class="comment">     * number of threads operating off a shared </span></span><br><span class="line"><span class="comment">     * unbounded queue.</span></span><br><span class="line"><span class="comment">     * 创建一个线程池，该线程池重用在共享的无边界队列上运行的固</span></span><br><span class="line"><span class="comment">     * 定数量的线程。</span></span><br><span class="line"><span class="comment">     * Atany point, at most&#123;<span class="doctag">@code</span> nThreads&#125; threads </span></span><br><span class="line"><span class="comment">     * will be activeprocessing tasks.</span></span><br><span class="line"><span class="comment">     * 无论何时，最多&#123;<span class="doctag">@code</span> nThreads&#125;个线程都是活动处理任</span></span><br><span class="line"><span class="comment">     * 务。</span></span><br><span class="line"><span class="comment">     * If additional tasks are submitted when all </span></span><br><span class="line"><span class="comment">     * threads are active,they will wait in the queue</span></span><br><span class="line"><span class="comment">     *  until a thread is available.</span></span><br><span class="line"><span class="comment">     *  如果在所有线程都处于活动状态时提交了其他任务，则它们将</span></span><br><span class="line"><span class="comment">     *  在队列中等待，直到某个线程可用为止。</span></span><br><span class="line"><span class="comment">     * If any thread terminates due to a failure </span></span><br><span class="line"><span class="comment">     * during execution prior to shutdown, a new one </span></span><br><span class="line"><span class="comment">     * will take itsplace if needed to execute </span></span><br><span class="line"><span class="comment">     * subsequent tasks.</span></span><br><span class="line"><span class="comment">     * 如果在关闭之前执行过程中由于执行失败导致任何线程终止，则</span></span><br><span class="line"><span class="comment">     * 在执行后续任务时将替换一个新线程。</span></span><br><span class="line"><span class="comment">     * The threads in thepool will exist</span></span><br><span class="line"><span class="comment">     * until it is explicitly &#123;<span class="doctag">@link</span> </span></span><br><span class="line"><span class="comment">     * ExecutorService#shutdown shutdown&#125;.</span></span><br><span class="line"><span class="comment">     *这个线程在池中将一直存在知道明确的shutdown。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nThreads the number of threads in the </span></span><br><span class="line"><span class="comment">     * pool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> </span></span><br><span class="line"><span class="comment">     * nThreads &lt;= 0&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>newCachedThreadPool()</li></ol><p>创意一个可以缓冲的线程池，如果当前线程数超出了执行任务的数量，那么在等待60s无新任务的情况下结束掉。当任务数量增加的情况下，线程池又会自动增加线程数量。线程池对线程的数量没有做限制。<br>方法解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executors.newCachedThreadPool()</span></span><br><span class="line"><span class="comment">     * Creates a thread pool that creates new threads </span></span><br><span class="line"><span class="comment">     * as needed, but</span></span><br><span class="line"><span class="comment">     * will reuse previously constructed threads when </span></span><br><span class="line"><span class="comment">     * they are available.  </span></span><br><span class="line"><span class="comment">     * 创建一个线程池，该线程池根据需要创建新线程，但是将在先前</span></span><br><span class="line"><span class="comment">     * 构造的线程可用时重用它们。</span></span><br><span class="line"><span class="comment">     * These pools will typically improve the </span></span><br><span class="line"><span class="comment">     * performance of programs that execute many </span></span><br><span class="line"><span class="comment">     * short-lived asynchronous tasks.</span></span><br><span class="line"><span class="comment">     * 这些池通常将提高执行许多短期异步任务的程序的性能。</span></span><br><span class="line"><span class="comment">     * Calls to &#123;<span class="doctag">@code</span> execute&#125; will reuse previously </span></span><br><span class="line"><span class="comment">     * constructed threads if available. </span></span><br><span class="line"><span class="comment">     * 调用&#123;<span class="doctag">@code</span> execute&#125;将重用之前构造的可重用的线程</span></span><br><span class="line"><span class="comment">     * If no existing thread is available, a new</span></span><br><span class="line"><span class="comment">     * thread will be created and added to the pool. </span></span><br><span class="line"><span class="comment">     * 如果不存在可重用的线程，那么一个新的线程将会被创建并添加</span></span><br><span class="line"><span class="comment">     * 到池中。</span></span><br><span class="line"><span class="comment">     * Threads that have not been used for sixty </span></span><br><span class="line"><span class="comment">     * seconds are terminated and removed from the</span></span><br><span class="line"><span class="comment">     * cache. </span></span><br><span class="line"><span class="comment">     * 六十秒内未使用的线程将终止并从缓存中删除。</span></span><br><span class="line"><span class="comment">     *  Thus, a pool that remains idle for </span></span><br><span class="line"><span class="comment">     * long enough will not consume any resources. </span></span><br><span class="line"><span class="comment">     * 因此，一个保持足够长的池也不会消耗任何资源。</span></span><br><span class="line"><span class="comment">     * Note that pools with similar properties but </span></span><br><span class="line"><span class="comment">     * different details (for example, timeout </span></span><br><span class="line"><span class="comment">     * parameters) may be created using &#123;<span class="doctag">@link</span> </span></span><br><span class="line"><span class="comment">     * ThreadPoolExecutor&#125; constructors.</span></span><br><span class="line"><span class="comment">     *请注意，可以使用&#123;<span class="doctag">@link</span> ThreadPoolExecutor&#125;构造函数创</span></span><br><span class="line"><span class="comment">     建具有相似属性但不同详细信息（例如，超时参数）的池。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关键字volatile和synchronized</title>
      <link href="/2020/05/13/%E5%85%B3%E9%94%AE%E5%AD%97volatile%E5%92%8Csynchronized/"/>
      <url>/2020/05/13/%E5%85%B3%E9%94%AE%E5%AD%97volatile%E5%92%8Csynchronized/</url>
      
        <content type="html"><![CDATA[<p>volatile ：ˈvälətl<br>synchronized ：ˈsiNGkrəˌnaīzd</p><ul><li>JAVA内存模型（JAVA Memory Model JMM）  </li></ul><p>JAVA内存模型定义了程序中各个变量的访问规则，即JVM将共享变量从内存存取的底层细节。<br><em>主内存是线程共享的区域例如堆和方法区，而工作内存实现线程私有的，例如PC寄存器、虚拟机栈</em><br>JMM规定所有共享变量都存储在主内存中，每条线程拥有自己的工作内存（比作缓冲区的概念），线程的工作内存中保存了主内存变量的拷贝副本。线程对共享变量的操作都在工作内存中进行，工作内存在线程是私有的，其他线程无法访问，变量的传递都是通过主内存来完成。   </p><p><img src="java_memory_model.jpg" alt=""></p><p>主内存与工作内存同步的中操作：  </p><ol><li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程的独占状态；  </li><li>unlock（解锁）：作用于主内存的变量，将一个变量从lock状态解锁，释放出来的该变量才能被其他线程lock；  </li><li>read（读取）：作用于主内存的变量，将一个变量的值从主内存传输大工作内存，以便于后面的load操作使用；  </li><li>load（载入）：作用于工作内存，把read操作从主内存得到的变量值放到工作内存的变量副本中；  </li><li>use（使用）：作用于工作内存的变量，把一个工作内存中的变量值传递给执行引擎，当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作；  </li><li>assign（赋值）：作用于工作内存的变量，把一个从执行引擎收到的值赋值给工作内存的变量，当虚拟机遇到一个需要给变量赋值的字节码指令时就会执行该操作；  </li><li>store（存储）：作用于工作内存的变量，把一个工作内存中的变量的值传送到主内存中，以便于随后的write操作；  </li><li>write（写入）：作用于主内存的变量，把store操作从工作内存中的一个变量的值传送到主内存的变量中。  </li></ol><p>3个特性：<br>1.原子性（Atomicity）：原子代表不可分割的最小单位。原子性指一个操作或多个操作要么全部执行，要么就都不执行。例如银行转账操作 A账户减去10000元和B账户增加10000元必须全部执行，否则就会出现错误，这两个操作不可再分割。<br>read、load、use、assign、store、write操作都保证了原子性的操作，基本数据类型的读取大致都具有原子性。更大范围保证原子性JMM提供了lock和unlock操作，JVM提供了更高层次的字节码指令monitorenter和monitorexit来隐式使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。<br>2.可见性（Visibility）：一个线程中堆共享变量（类中的成员变量或静态变量）的修改，其他线程立即得知这个修改。<br>保证可见性的操作：<br>volatile：volatile的特殊规则保证了新值立即同步到主内存中，以及每次使用前立即从主内存中刷新。<br>synchronized：synchronized关键字在释放锁之前，必须到此变量同步回主内存中（执行了store、write操作）。<br>final：final修饰的变量，一旦完成初始化，其他线程就能看见final字段的值。<br>3.有序性（Orderly）：有序性主要涉及了指令重排序现象和“工作内存与主内存同步延迟”现象。总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。<br>为了执行的效率，有时候会发生指令重排，这在单线程中指令重排之后的输出与我们的代码逻辑输出还是一致的。但在多线程中就可能发生问题，volatile在一定程度上可以避免指令重排。</p><ul><li><p>volatile和synchronized  </p><blockquote><p>synchronized保证了原子性和可见性，JMM中synchronized块执行流程清空工作内存-&gt;在主内存中拷贝变量值到工作内存的副本中-&gt;执行完代码-&gt;将更新后的共享变量值刷新到主内存中-&gt;释放同步锁<br>volatile保证了可见性和有序性。线程中volatile修饰的变量对其他线程共享变量的修改是可立即看见的。有序性上volatile可以一定程度避免指令重排，volatile在生成指令上回家一个lock前缀，这个前缀相当于内存屏障可以避免指令重排序不能把后面的指令重排序到内存屏障之前的位置。<br>synchronized作用于代码块和方法，而volatile是变量修饰符。<br>volatile不会造成线程的阻塞,而synchronized可能会造成线程阻塞。  </p></blockquote></li><li><p>synchronized用法<br>1.（普通class）当一个线程访问对象中的synchronized(this)同步代码块时，其他试图访问这个对象的synchronized(this)同步代码块的线程将被阻塞。  </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">(String threadName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> counter = <span class="number">0</span>; counter &lt; <span class="number">5</span>; counter++) &#123;</span><br><span class="line">                    System.out.println(threadName + <span class="string">" counter is"</span> + counter);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.runTest(<span class="string">"threadA"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.runTest(<span class="string">"threadB"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br></pre></td></tr></table></figure><blockquote><p>threadA counter is0<br>threadA counter is1<br>threadA counter is2<br>threadA counter is3<br>threadA counter is4<br>threadB counter is0<br>threadB counter is1<br>threadB counter is2<br>threadB counter is3<br>threadB counter is4</p></blockquote><p>2.当一个线程访问对象的synchronized(this)代码块时，其他线程可以访问该对象的其他非同步代码块。  </p><p>3.当一个线程访问对象的synchronized(obj)代码块时,相当于给obj对象加了锁，那么访问其他试图访问obj对象的线程将会阻塞，直到该对象对obj的访问结束。synchronized(obj)可以理解为哪个线程拿到了obj的锁就可以访问同步代码块的代码。  </p><p>3.当synchronized修饰一个普通方法时，同步代码块对整个方法生效。<br>4.当synchronized修饰一个静态方法时，<em>同步锁生效的是整个类</em>。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">(String threadName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> counter = <span class="number">0</span>; counter &lt; <span class="number">5</span>; counter++) &#123;</span><br><span class="line">                System.out.println(threadName + <span class="string">" counter is"</span> + counter);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">       Test test2 = <span class="keyword">new</span> Test();</span><br><span class="line">       Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               test.runTest(<span class="string">"threadA test"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               test2.runTest(<span class="string">"threadB test2"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       threadA.start();</span><br><span class="line">       threadB.start();</span><br></pre></td></tr></table></figure><blockquote><p>threadA test counter is0<br>threadA test counter is1<br>threadA test counter is2<br>threadA test counter is3<br>threadA test counter is4<br>threadB test2 counter is0<br>threadB test2 counter is1<br>threadB test2 counter is2<br>threadB test2 counter is3<br>threadB test2 counter is4</p></blockquote><p>5.当synchronized修饰的是一个类时，场景与4相同，属于类锁。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>join方法</title>
      <link href="/2020/05/13/join%E6%96%B9%E6%B3%95/"/>
      <url>/2020/05/13/join%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>join()是用来保证线程间顺序调度的一个方法，是Thread类的方法。例如在ThreadA中执行了ThreadB.join(),此时ThreadA进入等待状态，直到ThreadB执行结束后才唤醒ThreadA继续执行后续的方法。<br>join()可传时间也可不传，传值下等待具体时间后唤醒，不传值要等到被调线程结束后唤醒。  </p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Package: com.litchi.demo.java</span></span><br><span class="line"><span class="comment"> * Date:    2020/5/13</span></span><br><span class="line"><span class="comment"> * Desc:    演示join方法调度线程执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liujicheng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoinTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"threadB run start"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//这里sleep为了让threadA开始执行</span></span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">1</span> &lt;&lt; <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">while</span> ((i = i &gt;&gt; <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"threadB run i="</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"threadB finish"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"threadA run start"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"threadA call threadB.join()"</span>);</span><br><span class="line">                    threadB.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"threadA continue"</span>);</span><br><span class="line">                System.out.println(<span class="string">"threadA continue"</span>);</span><br><span class="line">                System.out.println(<span class="string">"threadA finish"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="join_test_1.jpg" alt=""></p><p>如果不加join()的执行结果：<br><img src="join_test_2.jpg" alt=""></p><p><em>这里threadB.join()为什么去执行threadB，因为join()内部是用wait()实现的，所以这里把threadB看作是Object，Object.wait()就是操作当前线程去等待，也就是这里的threadB.join()使得threadA调用Object.wait()方法。</em></p><p>join()的内部实现原理其实是wait()  </p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Waits at most &#123;<span class="doctag">@code</span> millis&#125; milliseconds for this thread to</span></span><br><span class="line"><span class="comment">     * die. A timeout of &#123;<span class="doctag">@code</span> 0&#125; means to wait forever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; This implementation uses a loop of &#123;<span class="doctag">@code</span> this.wait&#125; calls</span></span><br><span class="line"><span class="comment">     * conditioned on &#123;<span class="doctag">@code</span> this.isAlive&#125;. As a thread terminates the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> this.notifyAll&#125; method is invoked. It is recommended that</span></span><br><span class="line"><span class="comment">     * applications not use &#123;<span class="doctag">@code</span> wait&#125;, &#123;<span class="doctag">@code</span> notify&#125;, or</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> notifyAll&#125; on &#123;<span class="doctag">@code</span> Thread&#125; instances.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">     *         the time to wait in milliseconds</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">     *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">     *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment">     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment">     *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>millis小于0抛出IllegalArgumentException异常；  </li><li>millis等于0循环isAlive()判断当前线程是否存活，存活就调用wait(0),把当前线程放入对象的等待集合中，直到对象线程结束才唤醒当前线程；  </li><li>millis大于0 循环isAlive()判断当前线程是否存活，存活就调用wait()传入等待时间，等到时间到后唤醒当前线程的执行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“sleep方法和wait方法”</title>
      <link href="/2020/05/12/sleep%E6%96%B9%E6%B3%95%E5%92%8Cwait%E6%96%B9%E6%B3%95/"/>
      <url>/2020/05/12/sleep%E6%96%B9%E6%B3%95%E5%92%8Cwait%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>sleep()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Causes the currently executing thread to sleep (temporarily cease</span></span><br><span class="line"><span class="comment">     * execution) for the specified number of milliseconds, subject to</span></span><br><span class="line"><span class="comment">     * the precision and accuracy of system timers and schedulers. The thread</span></span><br><span class="line"><span class="comment">     * does not lose ownership of any monitors.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">     *         the length of time to sleep in milliseconds</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">     *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">     *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment">     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment">     *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment">     * 根据系统计时器和调度程序的精度和准确性，使得当前的执行线程进入睡眠状态（暂时停止继续执行）达到指定的毫秒数。在这期间该线程不会失去任何所有权。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>sleep()是Thread类的静态方法。调用该方式使得当前线程进入指定毫秒数的睡眠状态，并且不会释放同步资源锁。sleep()需要catch InterruptedException，否则线程在被其他线程中执行对该线程的interrupt()方法，sleep()就会报InterruptedException 线程就会被终止。  </p><ul><li>wait()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Causes the current thread to wait until either another thread invokes the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> java.lang.Object#notify()&#125; method or the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> java.lang.Object#notifyAll()&#125; method for this object, or a</span></span><br><span class="line"><span class="comment">     * specified amount of time has elapsed.</span></span><br><span class="line"><span class="comment">     * 导致当前线程去等待，直到其他线程触发</span></span><br><span class="line"><span class="comment">     * java.lang.Object#notify()方法或者一个特定的时间值执</span></span><br><span class="line"><span class="comment">     * 行过去（设置的执行时间完成）</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The current thread must own this object's monitor.</span></span><br><span class="line"><span class="comment">     * 当前线程必须拥有该对象的监视器。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This method causes the current thread (call it &lt;var&gt;T&lt;/var&gt;) to</span></span><br><span class="line"><span class="comment">     * place itself in the wait set for this object and then to relinquish</span></span><br><span class="line"><span class="comment">     * any and all synchronization claims on this object. </span></span><br><span class="line"><span class="comment">     * 这个方法导致当前线程将自己放在一个对象的等待集中，并且放弃了任何的同步声明在当前对对象中。</span></span><br><span class="line"><span class="comment">     * Thread &lt;var&gt;T&lt;/var&gt;</span></span><br><span class="line"><span class="comment">     * becomes disabled for thread scheduling purposes and lies dormant</span></span><br><span class="line"><span class="comment">     * until one of four things happens:</span></span><br><span class="line"><span class="comment">     * 线程称为不可调度并处于休眠状态，直到一下四种状况发生：</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Some other thread invokes the &#123;<span class="doctag">@code</span> notify&#125; method for this</span></span><br><span class="line"><span class="comment">     * object and thread &lt;var&gt;T&lt;/var&gt; happens to be arbitrarily chosen as</span></span><br><span class="line"><span class="comment">     * the thread to be awakened.</span></span><br><span class="line"><span class="comment">     * 某些其他线程触发notify方法，对于当前对象和线程恰好被任</span></span><br><span class="line"><span class="comment">     * 意选择为要唤醒的线程。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Some other thread invokes the &#123;<span class="doctag">@code</span> </span></span><br><span class="line"><span class="comment">     * notifyAll&#125; method for this</span></span><br><span class="line"><span class="comment">     * object.</span></span><br><span class="line"><span class="comment">     * 某些其他线程触发notifyAll方法针对当前对象</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Some other thread &#123;<span class="doctag">@linkplain</span> </span></span><br><span class="line"><span class="comment">     * Thread#interrupt() interrupts&#125;</span></span><br><span class="line"><span class="comment">     * thread &lt;var&gt;T&lt;/var&gt;.</span></span><br><span class="line"><span class="comment">     * 某些其他线程触发了interrupts方法。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;The specified amount of real time has </span></span><br><span class="line"><span class="comment">     * elapsed, more or less.  If</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> timeout&#125; is zero, however, then real </span></span><br><span class="line"><span class="comment">     * time is not taken into</span></span><br><span class="line"><span class="comment">     * consideration and the thread simply waits </span></span><br><span class="line"><span class="comment">     * until notified.</span></span><br><span class="line"><span class="comment">     * 特定的时间大致过去。如果这个时间是0，则不考虑时间，线程</span></span><br><span class="line"><span class="comment">     * 只能等待通知</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * The thread &lt;var&gt;T&lt;/var&gt; is then removed from </span></span><br><span class="line"><span class="comment">     * the wait set for this</span></span><br><span class="line"><span class="comment">     * object and re-enabled for thread scheduling. </span></span><br><span class="line"><span class="comment">     * 这个线程然后从等待集中移除，并且重新能够被线程调度。</span></span><br><span class="line"><span class="comment">     * It then competes in the</span></span><br><span class="line"><span class="comment">     * usual manner with other threads for the right to synchronize on the</span></span><br><span class="line"><span class="comment">     * object; </span></span><br><span class="line"><span class="comment">     * 然后它与其他线程一样以通常的方式在对象上竞争同步的权利；</span></span><br><span class="line"><span class="comment">     * once it has gained control of the object, all </span></span><br><span class="line"><span class="comment">     * its synchronization claims on the object are</span></span><br><span class="line"><span class="comment">     *  restored to the status quo</span></span><br><span class="line"><span class="comment">     * ante - that is, to the situation as of the time that the &#123;<span class="doctag">@code</span> wait&#125;</span></span><br><span class="line"><span class="comment">     * method was invoked. </span></span><br><span class="line"><span class="comment">     * 一旦获得了对象的控制权，所有它的同步声明将恢复原状即调用方法是的情况。</span></span><br><span class="line"><span class="comment">     * Thread &lt;var&gt;T&lt;/var&gt; then returns from the</span></span><br><span class="line"><span class="comment">     * invocation of the &#123;<span class="doctag">@code</span> wait&#125; method. </span></span><br><span class="line"><span class="comment">     * 线程返回方法的调用。</span></span><br><span class="line"><span class="comment">     * Thus, on return from the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> wait&#125; method, the synchronization state of the object and of</span></span><br><span class="line"><span class="comment">     * thread &#123;<span class="doctag">@code</span> T&#125; is exactly as it was when the &#123;<span class="doctag">@code</span> wait&#125; method</span></span><br><span class="line"><span class="comment">     * was invoked.</span></span><br><span class="line"><span class="comment">     * 因此，从&#123;<span class="doctag">@code</span> wait&#125;方法返回时，对象和线程&#123;<span class="doctag">@code</span> T&#125;</span></span><br><span class="line"><span class="comment">     * 的同步状态与调用&#123;<span class="doctag">@code</span> wait&#125;方法时的状态完全相同。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * A thread can also wake up without being notified, interrupted, or</span></span><br><span class="line"><span class="comment">     * timing out, a so-called &lt;i&gt;spurious wakeup&lt;/</span></span><br><span class="line"><span class="comment">     * i&gt;.  </span></span><br><span class="line"><span class="comment">     * 线程也可以在不被通知，中断或中断的情况下唤醒</span></span><br><span class="line"><span class="comment">      *超时，即所谓的虚假唤醒。</span></span><br><span class="line"><span class="comment">     * While this will rarely</span></span><br><span class="line"><span class="comment">     * occur in practice, applications must guard </span></span><br><span class="line"><span class="comment">     * against it by testing for</span></span><br><span class="line"><span class="comment">     * the condition that should have caused the </span></span><br><span class="line"><span class="comment">     * thread to be awakened, and</span></span><br><span class="line"><span class="comment">     * continuing to wait if the condition is not </span></span><br><span class="line"><span class="comment">     * satisfied.  </span></span><br><span class="line"><span class="comment">     * 尽管在实践中这种情况很少发生，但是应用程序必须通过测试应</span></span><br><span class="line"><span class="comment">     * 该导致线程唤醒的条件来防范它，并在条件不满足时继续等待。</span></span><br><span class="line"><span class="comment">     * In other words,</span></span><br><span class="line"><span class="comment">     * waits should always occur in loops, like this </span></span><br><span class="line"><span class="comment">     * one:</span></span><br><span class="line"><span class="comment">     * 换句话说，等待应该总是在循环中发生，就像这样：</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *     synchronized (obj) &#123;</span></span><br><span class="line"><span class="comment">     *         while (&amp;lt;condition does not hold&amp;gt;)</span></span><br><span class="line"><span class="comment">     *             obj.wait(timeout);</span></span><br><span class="line"><span class="comment">     *         ... // Perform action appropriate to condition</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * (For more information on this topic, see Section 3.2.3 in Doug Lea's</span></span><br><span class="line"><span class="comment">     * "Concurrent Programming in Java (Second Edition)" (Addison-Wesley,</span></span><br><span class="line"><span class="comment">     * 2000), or Item 50 in Joshua Bloch's "Effective Java Programming</span></span><br><span class="line"><span class="comment">     * Language Guide" (Addison-Wesley, 2001).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the current thread is &#123;<span class="doctag">@linkplain</span> java.lang.Thread#interrupt()</span></span><br><span class="line"><span class="comment">     * interrupted&#125; by any thread before or while it is waiting, then an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> InterruptedException&#125; is thrown. </span></span><br><span class="line"><span class="comment">     * 如果当前线程被任何其他线程中断则将会抛出</span></span><br><span class="line"><span class="comment">     * InterruptedException</span></span><br><span class="line"><span class="comment">     *  This exception is not</span></span><br><span class="line"><span class="comment">     * thrown until the lock status of this object has been restored as</span></span><br><span class="line"><span class="comment">     * described above.</span></span><br><span class="line"><span class="comment">     * 上述的异常在对象锁定状态恢复之前不会发生。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note that the &#123;<span class="doctag">@code</span> wait&#125; method, as it </span></span><br><span class="line"><span class="comment">     * places the current thread</span></span><br><span class="line"><span class="comment">     * into the wait set for this object, unlocks </span></span><br><span class="line"><span class="comment">     * only this object; </span></span><br><span class="line"><span class="comment">     * 注意wait方法被放置在当前线程对于该独享的等待集中，解锁</span></span><br><span class="line"><span class="comment">     * 仅针对该对象</span></span><br><span class="line"><span class="comment">     * any other objects on which the current thread </span></span><br><span class="line"><span class="comment">     * may be synchronized remain locked while the </span></span><br><span class="line"><span class="comment">     * thread waits.</span></span><br><span class="line"><span class="comment">     * 在当前线程的其他对象可能在同步时保持锁定在线程等待时。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This method should only be called by a thread </span></span><br><span class="line"><span class="comment">     * that is the owner of this object's monitor. </span></span><br><span class="line"><span class="comment">     * 该方法只能由线程调用是该对象的监视器的所有者。</span></span><br><span class="line"><span class="comment">     * See the &#123;<span class="doctag">@code</span> notify&#125; method for a</span></span><br><span class="line"><span class="comment">     * description of the ways in which a thread can</span></span><br><span class="line"><span class="comment">     *  become the owner of</span></span><br><span class="line"><span class="comment">     * a monitor.</span></span><br><span class="line"><span class="comment">     *有关线程可以成为监视器所有者的方式的描述，请参见&#123;<span class="doctag">@codenotify</span>&#125;方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      timeout   the maximum time to wait in milliseconds.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException      if the value of timeout is</span></span><br><span class="line"><span class="comment">     *               negative.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment">     *               the owner of the object's monitor.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  InterruptedException if any thread interrupted the</span></span><br><span class="line"><span class="comment">     *             current thread before or while the current thread</span></span><br><span class="line"><span class="comment">     *             was waiting for a notification.  The &lt;i&gt;interrupted</span></span><br><span class="line"><span class="comment">     *             status&lt;/i&gt; of the current thread is cleared when</span></span><br><span class="line"><span class="comment">     *             this exception is thrown.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>        java.lang.Object#notify()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>        java.lang.Object#notifyAll()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>wait()是Object类的方法.主要用来协调多线程对共享资源的存取。当线程调用wait()方法时，该线程就和对象放置在等待集（或叫等待池）中，同时释放对象锁，当满足一定条件等待结束时，唤醒当前在等待集中的该线程（此时该线程与其他线程一起争夺对象的同步权）,从等待集中移除的方式有：<br>1.某些其他线程触发notify方法，对于当前对象和线程恰好被任意选择为要唤醒的线程；<br>2.某些其他线程触发notifyAll方法；<br>3.某些其他线程触发了interrupts方法；<br>4.设置的特定wait时间到了。如果这个时间是0，则不考虑时间，线程只能等待通知。  </p><p><em>其他线程调用interrupts方法中断时如果当前对象正在被其他线程占用，那么InterruptedException会在对象锁定状态恢复后抛出</em><br>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Package: com.litchi.demo.java</span></span><br><span class="line"><span class="comment"> * Date:    2020/5/12</span></span><br><span class="line"><span class="comment"> * Desc:    com.litchi.demo.java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liujicheng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> java.lang.Object resourceOne = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableA());</span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableB(threadA));</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceOne) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread A lock resourceOne"</span> + TimeUtil.getTime(System.currentTimeMillis()));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        resourceOne.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"ThreadA:"</span> + TimeUtil.getTime(System.currentTimeMillis()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RunnableB</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i = i &gt;&gt; <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceOne) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread B lock resourceOne:"</span> + TimeUtil.getTime(System.currentTimeMillis()));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Thread B request interrupt threadA:"</span> + TimeUtil.getTime(System.currentTimeMillis()));</span><br><span class="line">                        thread.interrupt();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            java.lang.Thread.sleep(<span class="number">8000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            java.lang.Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="sleep_wait_lock.jpg" alt=""></p><p>这里可以看到catch内的执行是在Thread B线程释放锁resourceOne对象后抛出的。  </p><ul><li>两者区别比较：  </li></ul><p>1.sleep()时Thread类的静态方法，wait()是Object类的方法；<br>2.sleep()只是让当前线程休眠，不会释放同步锁，资源会被持续占有，wait()会释放同步锁，会把线程放入对象的wait集合中；<br>3.sleep()可以在任何地方使用，wait()方法、notify()方法和notiftAll()方法用于协调多线程对共享数据的存取，所以只能在同步方法或者同步块中使用，否则抛出IllegalMonitorStateException；<br>4.sleep()必须传入时间，而wait()可以传，也可以不传，如果不传要通过otify()方法和notiftAll()方法唤醒。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“死锁”</title>
      <link href="/2020/05/11/%E2%80%9C%E6%AD%BB%E9%94%81%E2%80%9D/"/>
      <url>/2020/05/11/%E2%80%9C%E6%AD%BB%E9%94%81%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<ul><li>死锁的含义  </li></ul><p>死锁就是进程由于争夺资源造成的僵持状态，无外力作用下无法向前推进。</p><p><img src="dead_lock.jpg" alt=""></p><blockquote><p>图中资源-1被线程a持有、资源-2被线程b持有，同时线程a又请求获得资源-2，线程b又请求获得资源-1，这个时候线程a和线程b都处于等待状态无法向前执行就处于了死锁状态。</p></blockquote><ul><li>死锁的四个必要条件<br>1.互斥   一个资源在一段时间内只能被一个进程持有（占用）；<br>2.请求和持有  进程在请求资源阻塞时，对已获得资源保持持有不放；<br>3.不可抢占  进程已获得的资源在未使用完之前不能被其他进程抢占（剥夺），只能由自己释放；<br>4.循环等待 若干进程之间形成一种头尾相接的循环等待资源关系。<br><em>预防死锁的方法就是破坏死锁的四个必要条件</em></li><li>示例  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Package: com.litchi.demo.java</span><br><span class="line"> * Date:    2020/5/11</span><br><span class="line"> * Desc:    com.litchi.demo.java</span><br><span class="line"> *</span><br><span class="line"> * @author liujicheng</span><br><span class="line"> */</span><br><span class="line">class DeadLock &#123;</span><br><span class="line"></span><br><span class="line">    public static Object resourceOne = new Object();</span><br><span class="line">    public static Object resourceTwo = new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new java.lang.Thread(new RunnableA()).start();</span><br><span class="line">        new java.lang.Thread(new RunnableB()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static class RunnableA implements Runnable &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                synchronized (resourceOne) &#123;</span><br><span class="line">                    System.out.println(&quot;Thread A lock resourceOne&quot;);</span><br><span class="line"></span><br><span class="line">                    //停留5s让ThreadB锁住resourceTwo</span><br><span class="line">                    try &#123;</span><br><span class="line">                        java.lang.Thread.sleep(5000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    synchronized (resourceTwo) &#123;</span><br><span class="line">                        System.out.println(&quot;Thread A lock resourceTwo&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class RunnableB implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                synchronized (resourceTwo) &#123;</span><br><span class="line">                    System.out.println(&quot;Thread B lock resourceTwo&quot;);</span><br><span class="line"></span><br><span class="line">                    //停留5s让ThreadB锁住resourceTwo</span><br><span class="line">//                    try &#123;</span><br><span class="line">//                        java.lang.Thread.sleep(5000);</span><br><span class="line">//                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">//                        e.printStackTrace();</span><br><span class="line">//                    &#125;</span><br><span class="line"></span><br><span class="line">                    synchronized (resourceOne) &#123;</span><br><span class="line">                        System.out.println(&quot;Thread B lock resourceOne&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap原理</title>
      <link href="/2020/05/09/HashMap%E5%8E%9F%E7%90%86/"/>
      <url>/2020/05/09/HashMap%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>HashMap的内部存储是以数组+链表+红黑树为组合的复合结构，数组(table)中元素是Entry，键值对(key-value)中key的hashCode值决定了Entry元素在数组中的位置，当发生hash冲突时，相同hash值的Entry元素组成链表，链表的长度是有定长的（TREEIFY_THRESHOLD=8），当链表触发链表树化，就会变成树形结构。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">     * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">     * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">     * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><ul><li>hash()  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment">     * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment">     * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment">     * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment">     * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment">     * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment">     * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment">     * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment">     * are already reasonably distributed (so don't benefit from</span></span><br><span class="line"><span class="comment">     * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment">     * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment">     * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment">     * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment">     * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 计算key.hashCode()并且移动高位到低位。由于数组使用2的幂次表示，变化仅仅在hash集合       </span></span><br><span class="line"><span class="comment">     * 的上方中这将总是发生碰撞（这其中的例子是Float的key集合在小的table中保持连续的数    </span></span><br><span class="line"><span class="comment">     * 字），所以我们应用高位向下移动的影响来作为转化。在速度、实用和为扩展上需要权衡，由于</span></span><br><span class="line"><span class="comment">     * 许多哈希集已经合理的分布（所以无需从移动位中受益），并且因为我们使用了树来处理容器中</span></span><br><span class="line"><span class="comment">     * 更大的冲突，因此我们仅以最简答单的方式对一些以为后的微bit进行XOR，以减少系统损耗，</span></span><br><span class="line"><span class="comment">     * 以及最高位的影响，否则由于table番位的限制，这些高位将永远不会在索引计算中使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到hash方法中将Object key计算出的hashCode右移了16位，这里的原因官方注释中已经很明了，这样做是为了将高位的信息在hash值进行计算索引中降低冲突的概率，因为在一些hash中低位可能会相同，所以这里移位来使得hash更加分布均匀。  </p><ul><li>构造函数  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">   * capacity and load factor.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">   *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">      <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">      <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">   * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">   * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment">   * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment">   * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment">   * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">      putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看到HashMap1.8中四个构造函数，主要就看第一个，两个入参initialCapacity是table数组的大小，默认值DEFAULT_INITIAL_CAPACITY=16，loadFactor负载因子用来控制扩容的阈值默认DEFAULT_LOAD_FACTOR=0.75f，就是当table的threshold到达0.75时触发table扩容。这里tableSizeFor(initialCapacity)方法是利用传入的初始化table容量转为2的幂次数。  </p><ul><li>put方法  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">     * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">     * value is replaced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)<span class="comment">//（1）</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//（2）</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//（3）</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">//（4）</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">//（5）</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//（6）</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">//（7）</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;<span class="comment">//（8）</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;<span class="comment">//（9）</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//(10)</span></span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里主要看putVal()方法。<br>（1）这里第一个if判断table是否为空，为空就利用resize方法初始化；<br>（2）第二个if判断如果当前根据hash跟到的table索引下为空就直接将Node对象放入table中；<br>（3）else下是hash发生碰撞；<br>（4）首先第一个if判断的是如果NewNode和table中位置的Node hash值和key都相同就直接可以看作是同一个Node，这里还有个场景是否用新put的values覆盖老的value，onlyIfAbsent为false或者老的value为空就要覆盖掉老值；<br>（5）else if判断如果是一个树结点就调用putTreeVal插入元素；<br>（6）else下循环遍历将p添加到链表尾部，如果这时达到链表最大阈值就需要调用treeifyBin方法进行树化；<br>（7）如果已经在链表中就braek掉；<br>（8）这里判断是否需要覆盖老数据。<br>（9）modCount保证并发访问，这里的put方法是线程不安全的，所以当modCount发现变化不一致就会抛出ConcurrentModificationException。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line">(<span class="number">10</span>)这里对table扩容。</span><br><span class="line"></span><br><span class="line">* resize方法  </span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 初始化或增加成两倍大的table，如果为空，则根据字段阈值中保持的初始容量目标进行分配。</span></span><br><span class="line"><span class="comment">     * 否则，因为我们使用的是2的幂，所以每个bin中的元素必须保持相同的索引，或者在新表中以2</span></span><br><span class="line"><span class="comment">     * 的幂偏移。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;<span class="comment">//（1）</span></span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">//（2）</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的代码基本都很好理解的，这里主要说两个点：<br>（1）这个位置是table变成两倍table的元素移动的操作，e.nex=null说明它就是一个元素不存在链和树直接根据e.hash &amp; (newCap - 1)计算出它在新table中的位置并赋值；如果是树通过split方法复制树；<br>（2）这里比较重要的操作。这里是链表复制的过程，这里链表上的Node位置有两个场景，一种是不需要移动的Node形成链表还在老的index下，另一种是需要我们移动位置的Node形成新的链表复制到新的index下。<em>这里为什么会有这个操作，因为index值的确定是根据Node.hash和cap-1取与获得的，那么在变成两倍table后讲道理每一个index都需要重新取计算，但是这里观察变成两倍table的原理其实每次threshold&lt;&lt;1（也就是二进制高位变成1），那么这样Node.hash和cap-1取与过程中发生变化的就只有高位是1的所以这里(e.hash &amp; oldCap) == 0表示在变成两倍table后index不需要变化，如果需要变化那么index=老idnex+oldCap。</em>  </p><p><img src="hashmap_resize.jpg" alt=""></p><ul><li>get方法  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment">     * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment">     * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment">     * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment">     * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment">     * distinguish these two cases.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>get方法相对简单直接通过key和hash取查找元素，如果是table中的first直接返回如果是tree从tree遍历g得到，如果是链表遍历拿到。  </p><ul><li>总结<br><em>hash()方法的关键是高位右移的操作，目的是为了使得hash趋于均匀分布，避免hash冲突（碰撞），在与table.length取与获得index时尽降低形成链</em><br><em>put()方法完成table创建和初始化和新增Node，新增Node分三个场景直接放置在table[index]位置；形成链表的插入链表中，链表达到阈值形成红黑树</em><br><em>resize()方法完成 两倍扩展以及扩展后的Node的重新放置，这里重要是巧妙的使用 (e.hash &amp; oldCap) == 0来作为是否将老链表数据分开放置的处理，利用扩容和2的幂的关系进行操作</em></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时数据区</title>
      <link href="/2020/05/08/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
      <url>/2020/05/08/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>运行时数据区也就是JVM运行时的内存区域，这里主要划分为堆区、方法区、虚拟机栈、本地方法栈和PC寄存器。<br><img src="vm_stack.jpg" alt="">  </p><ul><li>堆区：<br>堆区是这其中最大的一块区域，保存几乎所有创建出来的对象实例，这块区域是线程共享的，堆区是垃圾回收的主要区域，因此也叫“GC堆”,在GC回收时采用分代收集算法，所以堆区分为新生代和老年代。堆区在物理上时不连续的，在逻辑中看作是连续的。在堆区分配内存给对象实例时如果内存不足，会抛出OutOfMemoryError异常。<br><em>Minor Gc和Major Gc(Full GC)</em>：Minor Gc是指新生代垃圾回收的动作，新创建的对象都会在新生代，所以Minor Gc相对频繁，回收速度相对也快；Major Gc(Full GC)时老年代的垃圾回收动作，Major Gc(Full GC)回收频率较慢，速度也较慢。  </li><li>方法区：<br>方法区线程共享，方法去存储类的信息、常量、静态变量以及<em>运行时常量池</em>(Runtime Constant Pool:常量不一定只能在编译期产生，运行期间也可能产生新的常量，这些常量被放在运行时常量池中，例如通过String.intern()将String放入常量池)。  </li><li>虚拟机栈和本地方法栈：<br><em>虚拟机栈</em>每个线程在创建时都会创建一个虚拟机栈，内部是由一个个的栈帧组成(Stack Frame)，一个栈帧就对应一个Java方法调用。<br>它主管Java程序的运行，保存方法的局部变量（8中基本数据类型、对象引用地址）、部分结果，并参与方法的调用和返回。<br>虚拟机栈的大小允许是固定的或者是动态的：  <blockquote><p>虚拟机栈大小固定情况下，如果线程请求分配的栈容量超过了虚拟机栈允许的最大容量就会报StackOverFlowError异常。<br>虚拟机栈大小动态的情况下，当虚拟机栈请求扩展容量而这时内存不足JVM就会抛出OutOfMemoryError异常，同样在创建线程时如果没有足够的内存空间提供给虚拟机栈，也会报OutOfMemoryError异常。  </p></blockquote></li></ul><p>每个栈帧包含：局部变量表、操作数栈、动态链接和方法返回地址。<br>1.局部变量表：<br><em>局部变量表存储方法参数和定义在方法内的局部变量</em>，局部变量表的存储单位时slot（变量槽），存储的数据类型包括基本数据类型、引用数据类型和返回地址类型。  </p><blockquote><p><em>局部变量表的大小是在编译期间就确定下来的。</em>  </p></blockquote><p>2.操作数栈：<br>操作数栈在方法执行的过程中根据字节码指令写或者提取数据（入栈和出栈）。<br><img src="operate_stack.jpg" alt=""><br>3.动态链接（Dynamic Linking）：<br><em>即指向运行时常量池的引用</em>它是栈帧内部指向运行时常量池中该栈帧所属方法的引用。动态链接的作用是为将符号应用转换为调用方法的直接引用。<br>4.方法返回地址（return address）：<br>方法返回地址存放调用该方法的PC寄存器的值。方法退出救市栈帧出栈的过程，此时需要恢复上层方法的局部变量表、操作数栈，将返回值压入调用者的操作数栈中，更新PC寄存器，调用者继续执行接下来的指令。<br><em>异常完成退出不会给上层调用者产生任何返回值</em>  </p><blockquote><p>本地方法栈结构与Java虚拟机栈相同，只是它服务的是本地方法，也有些虚拟机中将本地方法栈和Java虚拟机栈合二为一。  </p></blockquote><ul><li>PC寄存器（Program Counter Register）：<br><em>PC寄存器</em>用来存放下一行执行指令的地址，由执行引擎读取下条指令。根据是一块很小的内存区域，每个线程都有自己的PC寄存器，它是线程私有的区域，生命周期与线程的生命周期保持一致。PC寄存器是JVM规范中唯一一个不会发生OutOfMemory的区域，也不存在GC。PC寄存器可以保证线程切换时指令不会发生异常，在来回切换后可以回到切换前执行位置继续执行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于作者</title>
      <link href="/2020/05/07/%E5%85%B3%E4%BA%8E%E4%BD%9C%E8%80%85/"/>
      <url>/2020/05/07/%E5%85%B3%E4%BA%8E%E4%BD%9C%E8%80%85/</url>
      
        <content type="html"><![CDATA[<ul><li>litchi</li><li>1992-05-20</li><li>浙江杭州</li><li>Android JAVA</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GC机制</title>
      <link href="/2020/05/07/GC%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/05/07/GC%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>垃圾回收机制是JVM持续运行的关键，当JVM在运行过程中会产生很多“无用”的对象，如果没有及时GC就会导致我们虚拟机运行效率的降低，从而引发系统的异常。在运行时数据区中程序计数器、虚拟机栈、本地方法栈是线程私有的，不需要进行垃圾回收。方法区和堆区线程共享需要进行垃圾回收，堆是Java虚拟机进行垃圾回收的主要场所，其次要场所是方法区。<br>垃圾回收分两步找到垃圾和回收垃圾，一般查找垃圾有两种方法引用计数法和可达性分析算法。<br><em>引用计数法</em>就是给每个创建的对象添加一个引用计数器，当有一地方引用它时引用计数器加1，当有引用消除时引用计数器减1。当引用计数器等于0时就表示该对象可收回。标记计数法存在的问题时当有两个或几个对象互相引用时，它们的引用计数器永远不会为0，就永远不会被回收。<br><em>可达性分析算法（根搜索算法）</em>以根对象作为根结点进行搜索，当有对象不可达时就认为该对象可回收，根对象一般指虚拟机栈中的引用对象、本地方法栈中JNI的引用对象、方法区中运行常量池中的引用对象、方法区中静态属性引用的对象、运行中的线程、由引导类加载器加载的对象、GC控制的对象。<br>垃圾回收算法有：<br>1.<em>标记-清除（mark–sweep）</em><br>标记所有需要回收的对象，之后统一回收。这是最基础的算法，后续的回收算法都是基于这个算法扩展的。缺点明显效率低，产生大量碎片。<br><img src="gc_mark_sweep.jpg" alt=""><br>2.<em>复制（copying）</em><br>将内存空间划分两块相等的区域，每次只使用其中的一块区域，垃圾回收时遍历正在使用的区域内对象，将正在使用的引用对象赋值到另一块区域。每次垃圾回收时只处理正在使用的对象，赋值成本低，赋值过去会进行整理，不存在内存碎片。缺点是需要双倍的内存空间，以空间换时间。<br><img src="gc_copying.jpg" alt=""><br>3.<em>标记-整理或压缩（mark–compact））</em><br>结合了复制和标记清除的优点，第一步标记所有需要回收的对象，第二部回收对象，并对存活对象进行整理（压缩）。<br><img src="gc_mark_compact.jpg" alt=""><br>4.<em>分代收集算法</em><br>根据对象生命周期的不同将对象分为新生代和老年代对象。新生代对象一般又分为Eden区(伊甸园)和两个Survivor区。新创建的u对象都在Eden区，当Eden区内存到达阈值就会出发Minor GC，这是就会把Eden区中的对象复制到其中一个Survivor区中，此时这些存活对象的生命存活计数会加1.这是Eden区空置，Eden区继续存放新创建的对象，当再次触发Minor Gc时，将此时Eden区的存活对象和之前一个Survivor区的存活对象复制到另外一个Survivor区中，同时它们的生命存活计数器加1，这个过程持续发生，当对象的存活计数器达到一定的阈值后触发“晋升”，新生代中的该对象就被放置到了老年代中。<br>老年代中的对象经过多次的GC就会是生命周期很长的对象。当老年代的内存达到阈值时触发Major GC，这是采用标记-整理或压缩（mark–compact）算法。<br><img src="gc_eden_survivor_minor_major.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM结构</title>
      <link href="/2020/05/02/JVM%E7%BB%93%E6%9E%84/"/>
      <url>/2020/05/02/JVM%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>JVM(JavaVirtualMachine，Java虚拟机)JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台（write once run anywhere）。JVM包含在JDK中的一部分。</p><p><img src="JVM.jpg" alt=""></p><ul><li>类加载器子系统<br>类加载器子系统主要负责将二进制字节码文件加载成JVM识别的数据结构，并对其文件进行规则校验和一些初始化工作。具体分为三个阶段loading、linking和initialization：<br>loading阶段将字节码文件加载到JVM中，这里有四类加载器来完成，Bootstrap ClassLoader(C++实现，加载Java核心类库/java_home/lib/rt.jar里的类集合)、Extension ClassLoader（加载/java_home/lib/ext里的类集合）、App ClassLoader(package下定义的类)、User define ClassLoader（自定义类加载器）；<br>linking阶段又分为三个阶段：verify、prepare、resolution，verify阶段验证Class文件是否符合JVM语法规则（具体包括类文件信息、元数据信息、字节码验证和符号引用验证）；prepare阶段为变量设置默认初始值，也就是0值，ps：int是0 String null；resolution阶段将符号引用转化为直接应用；<br>initialization阶段完成静态变量的显式赋值和静态代码块的执行。</li><li>运行时数据区<br>运行时数据区包括PC寄存器、虚拟机栈、本地方法栈、方法区、堆五部分组成。<br>1.PC寄存器保存下一条将要被执行指令的地址和线程一一对应，这样保证了再线程来回切换时可以回到之前执行的位置；<br>2.虚拟机栈用来描述java方法执行的内存模型，每个线程对应一个栈，栈内的栈帧对应java方法，栈帧结构又包括：局部变量表、操作数栈、动态链接和方法返回地址；<br>3.本地方法栈的功能和结构与虚拟机栈类似，区别在于它服务的对象是native方法；<br>4.方法区是一块线程共享的内存区域，保存类的版本/字段/方法/接口等描述信息以及常量、静态场景等，还有运行时常量池（Runtime Constant Pool）；<br>5.堆用来保存创建对象的主体，是最大的一块数据区，也是线程共享的内存区域。  </li><li>执行引擎<br>执行引擎是将JVM字节码指令转化为本地物理机可识别的机器指令执行，是JVM的核心部分之一。  </li><li>本地方法接口<br>本地接口的作用是融合不同的编程语言为java所用。</li><li>本地方法库<br>为本地方法提供依赖支持。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器子系统</title>
      <link href="/2020/04/26/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/04/26/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="classloader.jpg" alt=""></p><h3><span id="类加载过程包括加载load-链接linking和初始化init">类加载过程包括加载（load）、链接（linking）和初始化（init）</span></h3><ul><li>加载<br><strong><em>将字节码文件从数据源中加载到JVM内存中，生成JVM的认可的数据结构（也就是Class对象）</em></strong>，数据源可以是来自物理硬盘或者网络的jar文件、war文件、class文件等一些JVM可识别的文件格式结构（文件格式异常回报ClassFormatError）。  </li><li>链接<br>链接是类加载的核心部分，分三个步骤：验证、准备和解析<br>1.验证（Verify）：保证字节流信息符合JVM规范，避免恶意数据危害JVM的安全运行（异常抛出VerifyError）。<br>2.准备（Prepare）：为类变量分配内存和为变量设置初始值。<br>3.解析（Resolve）：将符号应用转换为直接应用，符号应用就是一组符号来描述所应用的目标，直接应用就是直接指向目标的指针或句柄。  </li><li>初始化<br>初始化主要是将静态变量赋值和执行静态代码块的一系列操作。</li></ul><h3><span id="双亲委派机制">双亲委派机制</span></h3><p><img src="parents_delegate.jpg" alt=""></p><p>双亲委派机制是在类加载过程中加载部分里的机制，加载器大致有启动类加载器Bootstrap ClassLoader（加载核心的类）、扩展类加载器Extension ClassLoader（ext path下的类）和应用类加载器Application ClassLoader（自定义）。<br>在执行类加载请求时，子加载器会先委托父类加载器执行；如果父类加载器还存在父类加载器就继续委托，一次递归找到其顶部启动类加载器；如果启动类加载器可以完成任务则将结果返回，倘若启动类加载器不能完成任务这时一次再让子类加载器尝试加载，这个过程叫双亲委派机制。</p><h3><span id="双亲委派机制优点">双亲委派机制优点</span></h3><p>1.避免类重复加载<br>2.保护程序安全，防止核心API被篡改（java.lang.String）</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法</title>
      <link href="/2020/04/21/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2020/04/21/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>插值查找</li><li>黄金分割法</li><li>线性索引查找</li><li>二叉排序树</li><li>平衡二叉树</li><li>B树</li><li>散列表（哈希表）查找<br>*</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2020/04/17/%E5%9B%BE/"/>
      <url>/2020/04/17/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<ul><li>图的特点：<br>1.通常用V(Vertex)表示一组定点的集合；<br>2.通常用E(Edge)表示一组边的集合。</li><li>顶点：<br>图中的一个结点</li><li>图的边：<br>顶点和顶点间的连线，有向图中的边叫做弧</li><li>相邻顶点：<br>由一条边连接在一起的顶点</li><li>顶点的度：<br>相邻顶点的数量叫做顶点的度</li><li>连通图：<br>在无向图中，若任意两个顶点Vi与Vj都有路径相通，则称该无向图为连通图</li><li>强连通图：<br>在有向图中，若任意两个顶点Vi与Vj都有路径相通，则称该有向图为强连通图</li><li>连通网：<br>在连通图中，若图的边具有一定的意义，每一条边都有一个对应数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网</li><li>生成树：<br>一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则会形成环</li><li><p>图的深度优先遍历：<br>假设初始状态是图中所有顶点都未被访问，从图中某个顶点v出发，先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到；若此时还有剩余顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p></li><li><p>图的广度优先遍历：<br>假设从图中某个顶点v出发，在访问了顶点v之后依次访问顶点v的各个未曾访问过的邻接顶点，然后分别从这些邻接顶点再出发依次访问它们的邻接顶点，并使“先被访问的顶点的邻接顶点”先于“后被访问的顶点的邻接顶点”被访问，直到图中所有已被访问的顶点的邻接点都被访问到；若此时图中还有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p></li><li><p>最小生成树：<br>在连通网的所有生成树中，所有边的代价总和最小的生成树，称为最小生成树</p></li></ul><p>1.普里姆算法(Prim算法)：</p><p>描述：<br>1.定义一个加权连通图，其中顶点集合V、Vnew，Vnew是V的子集，边的集合E、Enew，Enew是E的子集；<br>2.初始化集合Vnew{x},x(起始点)是集合V中任意一结点，Enew{}；<br>3.从边的集合E中选取权值最小的边&lt;u, v&gt;(其中u是顶点集合Vnew的元素，v属于顶点集合V，而不在新顶点集合Vnew中。若权值相同时，任意取值)；<br>4.将v加入新顶点集合Vnew，将边&lt;u, v&gt;加入新边集合Enew中；<br>5.重复操作3和4步骤 ，知道Vnew=V时，输出集合Vnew和Enew，Vnew和Enew即是来描述该加权连通图的最小生成树。<br>代码实现： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphMatrix</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 边的数量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> edgeNum;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 顶点集合</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span>[] vertex;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 邻接矩阵</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">GraphMatrix</span><span class="params">(<span class="keyword">char</span>[] vertex, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.vertex = vertex;</span><br><span class="line">            <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">            getEdgeNum();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getEdgeNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> length = vertex.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">                    <span class="comment">//矩阵值等于Integer.MAX_VALUE表示不相邻，等于0是自己到自己</span></span><br><span class="line">                    <span class="keyword">if</span> (matrix[i][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                        edgeNum++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * print matrix</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"矩阵:"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] m : matrix) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c : m) &#123;</span><br><span class="line">                    System.out.print(c + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取字符在结点里的位置</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> c 字符</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 返回-1没该字符，其他位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getVertexPosition</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == vertex[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输入开始顶点位置</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> x 开始顶点位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = vertex.length;</span><br><span class="line">            <span class="comment">//邻边权重</span></span><br><span class="line">            <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">            <span class="comment">//prime最小生成树结果</span></span><br><span class="line">            <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[num];</span><br><span class="line">            <span class="comment">//result当前索引</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//复制第一个顶点值</span></span><br><span class="line">            result[index] = vertex[x];</span><br><span class="line">            index++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//init weight 找到顶点相邻边的权重赋值weights[i]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                weights[i] = matrix[x][i];</span><br><span class="line">            &#125;</span><br><span class="line">            weights[x] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环遍历娶到最短权重值添加到result中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == i) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minWeight = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">int</span> minWeightIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (weights[j] != <span class="number">0</span> &amp;&amp; weights[j] &lt; minWeight) &#123;</span><br><span class="line">                        minWeight = weights[j];</span><br><span class="line">                        minWeightIndex = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//保存最短权重顶点</span></span><br><span class="line">                result[index] = vertex[minWeightIndex];</span><br><span class="line">                index++;</span><br><span class="line">                weights[minWeightIndex] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (weights[j] != <span class="number">0</span> &amp;&amp; matrix[minWeightIndex][j] &lt; weights[j]) &#123;</span><br><span class="line">                        weights[j] = matrix[minWeightIndex][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算最小生成树的权重</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> n = getVertexPosition(result[i]);</span><br><span class="line">                <span class="comment">//求当前节点到上面其他节点的最小值</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> m = getVertexPosition(result[j]);</span><br><span class="line">                    <span class="keyword">if</span> (matrix[m][n] &lt; min) &#123;</span><br><span class="line">                        min = matrix[m][n];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                sum += min;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打印最小生成树</span></span><br><span class="line">            System.out.printf(<span class="string">"PRIME(%c):"</span>, vertex[x]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%c "</span>, result[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.printf(<span class="string">"权重：%d"</span>, sum);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.克鲁斯卡尔算法(Kruskal算法)：</span><br><span class="line"></span><br><span class="line">描述：  </span><br><span class="line">首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。  </span><br><span class="line">代码实现：  </span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 克鲁斯卡尔算法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//结果数组的当前索引</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//输出的结果数组</span></span><br><span class="line">            Edge[] results = <span class="keyword">new</span> Edge[edgeNum];</span><br><span class="line">            <span class="comment">//保存某个顶点在该最小生成树的终点</span></span><br><span class="line">            <span class="keyword">int</span>[] vends = <span class="keyword">new</span> <span class="keyword">int</span>[edgeNum];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取图中所有的边</span></span><br><span class="line">            Edge[] edges = getEdges();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将边按权重从小到大排序</span></span><br><span class="line">            sortEdges(edges);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeNum; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = getVertexPosition(edges[i].start);</span><br><span class="line">                <span class="keyword">int</span> p2 = getVertexPosition(edges[i].end);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> m = getEdgesEnd(vends, p1);</span><br><span class="line">                <span class="keyword">int</span> n = getEdgesEnd(vends, p2);</span><br><span class="line">                <span class="keyword">if</span> (m != n) &#123;<span class="comment">//表示没有形成闭环</span></span><br><span class="line">                    vends[m] = n;</span><br><span class="line">                    results[index++] = edges[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//统计并打印最小生成树的信息</span></span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">                length += results[i].weight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Kruskal："</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"(%c,%c) "</span>, results[i].start, results[i].end);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">"Kruskal的权重："</span> + length);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连通图的边结构</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">            <span class="keyword">char</span> start;<span class="comment">//边的起点</span></span><br><span class="line">            <span class="keyword">char</span> end;<span class="comment">//边的终点</span></span><br><span class="line">            <span class="keyword">int</span> weight;<span class="comment">//边的权重</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">char</span> start, <span class="keyword">char</span> end, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.start = start;</span><br><span class="line">                <span class="keyword">this</span>.end = end;</span><br><span class="line">                <span class="keyword">this</span>.weight = weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取图中的边</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Edge[] getEdges() &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            Edge[] edges = <span class="keyword">new</span> Edge[edgeNum];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; vertex.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                        edges[index++] = <span class="keyword">new</span> Edge(vertex[i], vertex[j], matrix[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> edges;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据权重从小到大排序</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> edges edges</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortEdges</span><span class="params">(Edge[] edges)</span> </span>&#123;</span><br><span class="line">            Edge tmp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = (i + <span class="number">1</span>); j &lt; edges.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (edges[i].weight &gt; edges[j].weight) &#123;<span class="comment">//若大于则交换位置</span></span><br><span class="line">                        tmp = edges[i];</span><br><span class="line">                        edges[i] = edges[j];</span><br><span class="line">                        edges[j] = tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 取终点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getEdgesEnd</span><span class="params">(<span class="keyword">int</span>[] vends, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//若C-&gt;D,D-&gt;F则取F的值</span></span><br><span class="line">            <span class="keyword">while</span> (vends[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                i = vends[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>最短路径：</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2020/04/14/%E6%A0%91/"/>
      <url>/2020/04/14/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。</p><p><img src="tree.jpg" alt=""></p><ul><li>特点：</li></ul><p>1.在非空树中，根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点；<br>2.子树的个数没有限制，但它们互不相交；</p><ul><li>度：</li></ul><p>结点的度：结点拥有的子树个数叫做结点的度，结点A的度是3，C的度是2，H的度是1。<br>树的度：树中最大的结点度。图中树的度是3</p><ul><li>结点的关系</li></ul><p>1.结点子树的根结点称为该结点的 <strong>孩子结点</strong>，该结点叫做孩子结点的<strong>双亲结点</strong>。图中E是B的孩子结点，B是E的双亲结点；<br>2.同一双亲的结点叫做<strong>兄弟结点</strong>，图中的F、G是E的兄弟结点；<br>3.同一层的结点叫做<strong>堂兄结点</strong>，通中的H、I、J、K、L是E的堂兄结点；<br>4.从根到该结点经过的左右分支结点叫做该结点的祖先结点，图中M的祖先结点有A、B、E。<br>5.该结点的子树任意一个结点都称为该结点的子孙结点，E的子孙结点有M和N。</p><ul><li>结点的层次</li></ul><p>从根开始定义，根为第一层，根的孩子为第二层，根的孩子的孩子为第三层…。<br>树的深度：树中结点的最大层次数称为树的深度或高度，图中深度为4</p><h4><span id="二叉树">二叉树</span></h4><p>二叉树(Binary Tree)是n(n&gt;=0)个结点的有限集合，该集合或者为空集(空二叉树)，或者由一个跟结点和两个互补相交的、分别称为根的结点在左子树和右子树组成。每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。</p><p><img src="binary_tree.jpg" alt=""></p><ul><li>二叉树的特点</li></ul><p>1.每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点；<br>2.左子树和右子树是有顺序的，次序不能任意颠倒；<br>3.即使树中某结点只有一棵子树，也要区分它是左子树还是右子树；</p><ul><li>二叉树的性质</li></ul><p>1.在二叉树中第i层上最多有2的i-1次方个结点(i&gt;=1)；<br>2.二叉树中如果深度为k,那么最多有2k-1个节点(k&gt;=1）；</p><ul><li>斜树</li></ul><p>所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p><p><img src="xie_binary_tree.jpg" alt=""></p><ul><li>满二叉树<br>在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。<br>满二叉树的特点有：<br>1.叶子只能出现在最下一层。出现在其它层就不可能达成平衡。<br>2.非叶子结点的度一定是2。<br>3.在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li></ul><p><img src="man_binary_tree.jpg" alt=""></p><ul><li>完全二叉树<br>若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。<br>完全二叉树的特点：<br>1.叶子结点只出现在最下层和次下层；<br>2.最下层叶子结点集中在树的左部；<br>3.如果结点度为1，则该结点只有左孩子，即没有右子树；<br>4.相同结点数的二叉树，完全二叉树的深度最小；<br>5.满二叉树一定是完全二叉树，但反过来不一定成立。</li></ul><p><img src="wanquan_binary_tree.jpg" alt=""></p><ul><li>二叉树存储结构</li></ul><p>1.*** 顺序存储结构<br>二叉树的顺序存储结构就是使用一维数组存储二叉树中的结点，并且结点的存储位置，就是数组的下标索引。</p><p><img src="order_storage.jpg" alt=""></p><p>如果索引下为空表示该位置下没有存储结点。</p><p>2.*** 链式存储结构 </p><p>结构定义  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class BinaryNode&lt;E&gt; &#123;</span><br><span class="line">    //数据</span><br><span class="line">    E data;</span><br><span class="line">    //左子树</span><br><span class="line">    BinaryNode leftChild;</span><br><span class="line">    //右子树</span><br><span class="line">    BinaryNode rightChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二叉树的遍历</li></ul><p>1.前序遍历(DLR)<br>首先访问根，再先序遍历左（右）子树，最后先序遍历右（左）子树<br>图中结果：ABDECFG</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 前序遍历</span><br><span class="line">     *</span><br><span class="line">     * @param root 根</span><br><span class="line">     */</span><br><span class="line">    public void DLR(BinaryNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //TODO do something</span><br><span class="line"></span><br><span class="line">        if (root.leftChild != null) &#123;</span><br><span class="line">            DLR(root.leftChild);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.rightChild != null) &#123;</span><br><span class="line">            DLR(root.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2.中序遍历(LDR)<br>首先中序遍历左（右）子树，再访问根，最后中序遍历右（左）子树。<br>图中结果：DBEAFCG</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 中序遍历</span><br><span class="line">     *</span><br><span class="line">     * @param root 根</span><br><span class="line">     */</span><br><span class="line">    public void LDR(BinaryNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.leftChild != null) &#123;</span><br><span class="line">            LDR(root.leftChild);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //TODO do something</span><br><span class="line"></span><br><span class="line">        if (root.rightChild != null) &#123;</span><br><span class="line">            LDR(root.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3.后序遍历(LRD)<br>首先后序遍历左（右）子树，再后序遍历右（左）子树，最后访问根<br>图中结果：DEBFGA</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 后序遍历</span><br><span class="line">     *</span><br><span class="line">     * @param root 根</span><br><span class="line">     */</span><br><span class="line">    public void LRD(BinaryNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.leftChild != null) &#123;</span><br><span class="line">            LRD(root.leftChild);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.rightChild != null) &#123;</span><br><span class="line">            LRD(root.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //TODO do something</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4.层序遍历<br>按照层次访问，通常用队列来做。访问根，访问子女，再访问子女的子女</p><ul><li>线索二叉树</li></ul><p>二叉树线索化的过程中，会把树中的空指针利用起来作为寻找当前节点前驱和后继的线索，这样就出现了一个问题，即线索和数中原有指向孩子节点的指针无法区分。上边的这种节点设计就是为了区分这两类指针。其中，ltag和rtag为标识域，它们的具体意义如下:<br>1.如果ltag==0，表示lchild为指针，指向结点的左子树；<br>2.如果ltag==1，表示lchild为线索，指向结点的直接前驱;<br>3.如果rtag==0，表示rchild为指针，指向结点的右子树；<br>4.如果rtag==1，表示rchild为线索，指向结点的直接后继。</p><ul><li>哈夫曼树</li></ul><p>当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。</p><p><img src="huffman_tree.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配算法</title>
      <link href="/2020/04/14/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
      <url>/2020/04/14/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3><span id="bf算法">BF算法</span></h3><p>首先原串与字串左端对齐，，如果第一个字符不匹配，字串向后移动逐一移动，当发现死一个第一个字符匹配后，当前位置下比较剩余字串的字符与原串是否匹配，直到全部匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对齐:</span><br><span class="line">litchicoder</span><br><span class="line">coder</span><br><span class="line"></span><br><span class="line">逐一移动 找到匹配字符:</span><br><span class="line">litchicoder</span><br><span class="line">      coder</span><br></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class BF &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int r = queryByBF(&quot;HelloWord&quot;, &quot;Word&quot;);</span><br><span class="line">        System.out.print(r == 0 ? &quot;字符串匹配失败&quot; : &quot;子字符串在原串的位置：&quot; + r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param s 原字符串</span><br><span class="line">     * @param t 需要匹配的子字符串位置</span><br><span class="line">     */</span><br><span class="line">    public static int queryByBF(String s, String t) &#123;</span><br><span class="line">        char[] a = s.toCharArray();</span><br><span class="line">        char[] b = t.toCharArray();</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        while (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123;</span><br><span class="line">            //比较字符</span><br><span class="line">            if (a[i] == b[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //i后退重新匹配</span><br><span class="line">                i++;</span><br><span class="line">                j = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j &gt;= t.length()) &#123;</span><br><span class="line">            return i - t.length();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //匹配失败</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="kmp算法">KMP算法</span></h3><p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归和分治</title>
      <link href="/2020/04/14/%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB/"/>
      <url>/2020/04/14/%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<h3><span id="递归">递归</span></h3><p>高级语言中，函数自己调用和调用其他函数并没有本质的不同，我们把一个直接调用自己或者通过一系列调用语句间接地调用自己的函数，称作递归函数。（ps：每个递归定义必须至少有一个条件，当满足这个条件时递归不再进行，即函数不再调用自身而是返回值）</p><h4><span id="斐波那契fibonacci数列">斐波那契(Fibonacci)数列</span></h4><p>如果说兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔子都不会死去，能够一直干下去，那么一年以后可以繁殖多少对兔子呢？</p><p><img src="fibonacci.jpg" alt=""></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( i &lt; <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fib(i-<span class="number">1</span>) + Fib(i-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="分治">分治</span></h3><p>在遥远的周朝，人们受生产力水平所限，无法管理庞大的土地和众多的人民，因此采用了封邦建国的封建制度，把土地一层一层划分下去，以达到分而治之的目的，这也许是最古老的分治法了：</p><p><img src="fenzhi.png" alt=""></p><h4><span id="汉诺塔问题">汉诺塔问题</span></h4><p>汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><p><img src="hanoi.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanoi</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> n 盘子的个数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> a 原来的柱子</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> b 中间辅助柱子</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> c 最终到达的目标珠子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> a, <span class="keyword">char</span> b, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            move(a, c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//将n-1个盘子从a利用c移动到b盘子</span></span><br><span class="line">            hanoi(n - <span class="number">1</span>, a, c, b);</span><br><span class="line">            <span class="comment">//将第n个盘子从a移动到c</span></span><br><span class="line">            move(a, c);</span><br><span class="line">            <span class="comment">//将n-1个盘子从b利用a移动到c</span></span><br><span class="line">            hanoi(n - <span class="number">1</span>, b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 移动盘子</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">char</span> origin, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方向:"</span> + origin + <span class="string">"---&gt;"</span> + target);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hanoi hanoi = <span class="keyword">new</span> Hanoi();</span><br><span class="line">        hanoi.hanoi(<span class="number">3</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="快速排序">快速排序</span></h4><h4><span id="找出第n大的值">找出第n大的值</span></h4><h4><span id="直尺">直尺</span></h4><h4><span id="八皇后问题">八皇后问题</span></h4>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="/2020/04/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2020/04/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3><span id="栈">栈：</span></h3><p>栈(Stack)是一个后进先出(Last in first out LIFO)的线性表，要求只在表尾进行删除和插入操作了，栈的插入叫做进栈（进栈、压栈、入栈）、栈的删除叫出栈。</p><p><img src="stack.jpg" alt=""></p><h3><span id="队列">队列：</span></h3><p>队列(queue)是只允许在一端进行插入操作，而另一端进行删除操作的一种先进先出(First in First out FIFo)的线性表<br>1.循环队列：</p><p><img src="circle_queue.jpg" alt="循环队列"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object q[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        q = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inQueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//表示队列已经满了</span></span><br><span class="line">        <span class="keyword">if</span> ((tail+<span class="number">1</span>) % size == head) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        q[tail] = e;</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % size;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">outQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        E o = (E) q[head];</span><br><span class="line">        head = (head + <span class="number">1</span>) % size;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/2020/04/08/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2020/04/08/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4><span id="线性表理解为将数据结点用一根线连接起来存储在物理空间线性表的数据元素一般具有相同的数据类型-大部分线性表中除了第一个元素没有前驱和最后一个元素没有后继其他元素都有前驱和后继也就是各元素之间是一对一的关系">线性表理解为将数据结点用一根“线”连接起来存储在物理空间，线性表的数据元素一般具有相同的数据类型。大部分线性表中除了第一个元素（没有前驱）和最后一个元素（没有后继）其他元素都有前驱和后继（也就是各元素之间是一对一的关系）。</span></h4><ul><li><h3><span id="顺序存储结构顺序表">顺序存储结构（顺序表）</span></h3></li></ul><p>顺序存储结构就是数据是用一块完整的物理空间来连续存储数据，一般它的大小是固定的。<br>优点：物理空间利用率高，增查效率高。<br>缺点：插入和删除效率低，每次都需要移动目标元素后面的所有数据元素，由于它的length是提前分配固定好不能扩容，会发生存储溢出。</p><ul><li><h3><span id="链式存储结构">链式存储结构</span></h3>链式存储结构中数据元素的存储方式在物理空间中是随机的，数据结点氛围数据域和指针域，数据域存储数据元素，指针域来关联起来数据结点形成链。链式存储结构一般有单链表、双向链表和循环链表。<ol><li>单链表</li></ol></li></ul><p><img src="single_linked_list.jpg" alt=""></p><p>题目：找到单链表倒数第n个节点，保证链表中节点的最少数量为n。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for ListNode.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int val) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /*</span><br><span class="line">     * @param head: The first node of linked list.</span><br><span class="line">     * @param n: An integer</span><br><span class="line">     * @return: Nth to last node of a singly linked list. </span><br><span class="line">     */</span><br><span class="line">    public ListNode nthToLast(ListNode head, int n) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        ArrayList&lt;ListNode&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">        if (head!=null)&#123;</span><br><span class="line">            list.add(head);</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(head.next!=null)&#123;</span><br><span class="line">            list.add(0,head.next);</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode targetNode=list.get(n-1);</span><br><span class="line">        return targetNode;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>双向链表<br>双向链表是每个数据结点都有两个指针，分别指向相邻的前驱结点和后继结点，可以方便的访问某个结点的前驱结点和后继结点，存储上会相对多占用一些空间。<br><img src="duLinkList.jpg" alt=""></p><p>代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>静态链表<br>静态链表就是用数组来实现链式存储结构，所以它的长度是初始化的时候固定分配的定长。</li></ol><p><img src="static_list.jpg" alt=""></p><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">public class StaticList &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void run() &#123;</span><br><span class="line">        StcList list = new StcList&lt;CharSequence&gt;();</span><br><span class="line">        System.out.println(&quot;顺序新增前：&quot;);</span><br><span class="line">        list.printAll();</span><br><span class="line">        System.out.println(&quot;顺序新增后：&quot;);</span><br><span class="line">        list.add(&quot;A&quot;);</span><br><span class="line">        list.add(&quot;B&quot;);</span><br><span class="line">        list.add(&quot;C&quot;);</span><br><span class="line">        list.add(&quot;E&quot;);</span><br><span class="line">        list.insert(&quot;D&quot;, 3);</span><br><span class="line">        list.delete(2);</span><br><span class="line">        list.printAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //存储结构</span><br><span class="line">    public static class StaticListNode&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private E data;</span><br><span class="line">        private int cursor;</span><br><span class="line"></span><br><span class="line">        public StaticListNode(E data, int cursor) &#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">            this.cursor = cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public E getData() &#123;</span><br><span class="line">            return data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setData(E data) &#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getCursor() &#123;</span><br><span class="line">            return cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setCursor(int cursor) &#123;</span><br><span class="line">            this.cursor = cursor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class StcList&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private static final int MAX_SIZE = 10;</span><br><span class="line">        StaticListNode&lt;E&gt;[] nodes = new StaticListNode[MAX_SIZE];</span><br><span class="line"></span><br><span class="line">        public StcList() &#123;</span><br><span class="line">            initList(nodes, nodes.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //初始化备用链表</span><br><span class="line">        private void initList(StaticListNode[] nodes, int maxSize) &#123;</span><br><span class="line">            for (int i = 0; i &lt; maxSize; i++) &#123;</span><br><span class="line">                nodes[i] = new StaticListNode(null, i + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            //将最后一个数据元素的游标指向第一个有值元素</span><br><span class="line">            nodes[maxSize - 1] = new StaticListNode(null, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void printAll() &#123;</span><br><span class="line">            for (int i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">                System.out.print(nodes[i].getCursor());</span><br><span class="line">                System.out.print(&quot;:&quot;);</span><br><span class="line">                System.out.print(nodes[i].getData());</span><br><span class="line">                System.out.print(&quot;:&quot;);</span><br><span class="line">                System.out.print(i);</span><br><span class="line">                System.out.print(&quot;|&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 查找当前备用链表的头的</span><br><span class="line">         */</span><br><span class="line">        private void findHead() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 分配空间 分配空间的元素下标</span><br><span class="line">         *</span><br><span class="line">         * @return 0分配失败</span><br><span class="line">         */</span><br><span class="line">        private int mallocArry() &#123;</span><br><span class="line">            int index = 0;</span><br><span class="line">            if (nodes[0].cursor &gt; 0) &#123;</span><br><span class="line">                index = nodes[0].cursor;</span><br><span class="line">                nodes[0].cursor = nodes[index].cursor;</span><br><span class="line">            &#125;</span><br><span class="line">            return index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //顺序新增元素</span><br><span class="line">        public boolean add(E e) &#123;</span><br><span class="line">            if (e == null) &#123;</span><br><span class="line">                System.out.println(&quot;新增失败&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //不等于零说明链表容量没用完，可以新增</span><br><span class="line">            int currentIndex = nodes[0].getCursor();</span><br><span class="line">            if (currentIndex &gt; 0) &#123;</span><br><span class="line">                //当前空元素下标</span><br><span class="line">                nodes[currentIndex].setData(e);</span><br><span class="line">                nodes[0].setCursor(nodes[currentIndex].getCursor());</span><br><span class="line">//                nodes[currentIndex].setCursor(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;新增失败&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * @param e     要插入的数据</span><br><span class="line">         * @param index 表示要插入的链中的位置</span><br><span class="line">         * @return true插入成功</span><br><span class="line">         */</span><br><span class="line">        //新增元素</span><br><span class="line">        public boolean insert(E e, int index) &#123;</span><br><span class="line">            if (e == null || index &lt; 0 || index &gt; MAX_SIZE - 1) &#123;</span><br><span class="line">                System.out.println(&quot;插入元素失败&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //不等于零说明链表容量没用完，可以新增</span><br><span class="line">            int currentIndex = nodes[0].getCursor();</span><br><span class="line">            if (currentIndex &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">                //查找对应的位置</span><br><span class="line">                int k = 1;</span><br><span class="line">                for (int i = 0; i &lt; index - 1; i++) &#123;</span><br><span class="line">                    k = nodes[k].cursor;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //要插入位置记录的游标</span><br><span class="line">                int insertCursor = nodes[k].getCursor();</span><br><span class="line"></span><br><span class="line">                //申请分配的空间的下标</span><br><span class="line">                int i = mallocArry();</span><br><span class="line"></span><br><span class="line">                //插入位置的游标连接到新插入元素</span><br><span class="line">                nodes[k].setCursor(i);</span><br><span class="line">                //新插入元素的游标连接之前插入位置记录的游标</span><br><span class="line">                nodes[i].cursor = insertCursor;</span><br><span class="line">                nodes[i].data = e;</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;插入元素失败&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean delete(int index) &#123;</span><br><span class="line"></span><br><span class="line">            //不等于零说明链表容量没用完，可以新增</span><br><span class="line">            int currentEmptyIndex = nodes[0].getCursor();</span><br><span class="line">            if (currentEmptyIndex &gt; 0) &#123;</span><br><span class="line">                //查找前一个的位置</span><br><span class="line">                int k = 1;</span><br><span class="line">                for (int i = 1; i &lt; index - 1; i++) &#123;</span><br><span class="line">                    k = nodes[k].cursor;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                int currentIndex = nodes[k].cursor;</span><br><span class="line">                int nextIndex = nodes[currentIndex].cursor;</span><br><span class="line">                nodes[k].cursor = nextIndex;</span><br><span class="line"></span><br><span class="line">                //将删除的结点连接到备用链表</span><br><span class="line">                free(currentIndex);</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;删除元素失败&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void free(int i) &#123;</span><br><span class="line">            nodes[i].cursor=nodes[0].cursor;</span><br><span class="line">            nodes[0].cursor=i;</span><br><span class="line">            nodes[i].data = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>循环链表 有环</li></ol><p>循环链表的特点是最后一个结点的指针指向头结点，使整个链表形成环。</p><p>空链的判断条件：head==head-&gt;next;rear==rear-&gt;next;</p><ul><li><h3><span id="约瑟夫问题">约瑟夫问题</span></h3></li></ul><p>问题描述：<br>N个人围成一个圈，从第一个开始报数，第M个人将被杀掉，最后只剩一个，其他都被杀掉。</p><p><img src="josephus_problem.jpg" alt=""></p><p>循环链表的实现方式就是通过遍历元素，指针移动M位删除该元素，知道剩余一个元素。<br>数学推导方式是发现最终获胜的元素下标是在每一轮“杀人”过程中移动M位从而得到公式：f(N,M)=(f(N−1,M)+M)。</p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, i, winner = 0;</span><br><span class="line">    printf (&quot;N M = &quot;);</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    for (i = 2; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       //i是每阶约瑟夫环的人数</span><br><span class="line">        winner = (winner + m) % i;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">    //编号是从零开始，这里加1变成符合习惯的计数</span><br><span class="line">    printf (&quot;\nThe winner is %d\n&quot;, (winner +1));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3><span id="魔术师发牌问题">魔术师发牌问题</span></h3></li></ul><p>问题描述：<br>魔术师手中有A到K十三张黑桃扑克牌，表演前魔术师已经按照一定的顺序叠放好，表演过程：开始，魔术师数1将最上面的那张翻过来，是黑桃A，将其放在桌面上；第二次，魔术师数1、2，将第一张牌放在所有牌最下面，将第二张牌翻转过来，第二张牌正好是黑桃2；第三次，魔术师数1、2、3，将第一、二张牌按照顺序放在所有牌最下面，将第三张牌翻转过来，第三张牌正好是黑桃3；…知道所有牌都翻转过来，顺序刚好是A、2、3…K，现在要知道魔术师在翻牌前叠放的13张牌的顺序。</p><p> 代码实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><ul><li><h3><span id="拉丁方阵问题">拉丁方阵问题</span></h3></li></ul><p>问题描述：<br>拉丁方阵是一种n×n的方阵，方阵中恰有n种不同的元素，每种元素恰有n个，并且每种元素在一行和一列中 恰好出现一次。</p><p><img src="ladingfangzhen.jpg" alt=""></p><p>特点：<br>每一行除了开始的数递进一位外，其余的数都是按照顺序排列，递进的数排在后面，因此使用循环链表解决。</p><p> 代码实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度和空间复杂度</title>
      <link href="/2020/04/07/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2020/04/07/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>时间复杂度：执行算法所需要的时间</p><p>空间复杂度：执行算法所需要的内存空间</p><p>时间复杂度的定义：一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得T(n)/f(n)的极限值（当n趋近于无穷大时）为不等于零的常数，则称f(n)是T(n)的同数量级函数</p><ul><li>通常将O(1)、O(n)、O(logn)、O(n2)等分别叫做常量阶、线性阶、对数阶、平方阶等</li><li>推导大O阶方法：1.用常数1取代运行时间中的所有加法常数；2.修改后的运行次数函数中，值保留最高阶项；3.如果最高阶向存在且不是1，则去除与这个项相乘的常数</li><li>常数阶O(1)：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>，n=<span class="number">100</span>；</span><br><span class="line">sum=（<span class="number">1</span>+n）*n/<span class="number">2</span>;</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure><ul><li>线性阶O(n):</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="comment">//O(1)的算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对数阶O(logn):</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(num&lt;n)&#123;</span><br><span class="line">num=num*<span class="number">2</span>;</span><br><span class="line"><span class="comment">//O(1)的算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>平方阶O(n^2):</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j++)&#123;</span><br><span class="line">    <span class="comment">//O(1)的算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>常用的时间复杂度按照耗费的时间从小到大依次是：</li></ul><p><code>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试积累</title>
      <link href="/2020/02/05/%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF/"/>
      <url>/2020/02/05/%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<h2><span id="要求">要求：</span></h2><ul><li>薪酬结构</li><li>五险一金（全额，非全额要在基础薪资上调整）</li><li>技术团队规模</li><li>上下班时间 单双休 加班情况</li><li>人员配置 发版频率</li><li>绩效 年终奖</li><li>其他福利 餐补 车补贴 房补贴</li></ul><h2><span id="项目经验">项目经验：</span></h2><p>遇到了什么困难怎么解决的</p><ol><li>直播</li></ol><p>做了两方面的隔离，一是与其他业务模块的解耦 利用中间控制层 直播模块提供出对其他业务场景的依赖需求 其他业务模块提供这些能力给直播；二是把直播内部分为业务表现层和三方依赖层  具体做法是把三方直播依赖沉淀到baseview 把业务层需要的能力通过统一能力管理输出 （主要是直播画面能力控制和自定义消息协议的控制）</p><ol start="2"><li><p>首页</p></li><li><p>动画控件</p></li></ol><p>级联view<br>tab</p><h2><span id="java基础">java基础：</span></h2><ol><li><p>同步锁<br>同步锁的原理：</p></li><li><p>线程和进程</p></li></ol><ol start="4"><li><p>位运算<br>常见十进制D、二进制B、八进制Q和十六进制H（逢几进1）n<br>十进制向n进制转化：十进制转化为n进制时 十进制数一直除以n得余数 到一直不能整除为止，小数点部分是将小数部分乘以n 取整 然后小数部分继续乘以n 取整部分倒叙排序就是小数部分的值<br>二进制转n进制：采用r（二进制和n进制之间的位数差 例如八进制是3合1、十六进制时4合1，如果是32进制就是 5合1）合1的方式，如果位数不够r位，整数部分向左补零，小数部分向右补零，然后按照案权展开相加即可得</p></li><li><p>线程安全</p></li></ol><ol start="6"><li><p>进程保活</p></li><li><p>HashMap原理</p></li><li>HashTable</li><li>序列化</li><li>泛性-类型擦除</li></ol><h2><span id="数据结构与算法">数据结构与算法：</span></h2><ol><li>时间复杂度、空间复杂度</li><li>手写快排<br>手写归并排序<br>手写堆以及堆排序<br>说一下排序算法的区别(时间复杂度和空间复杂度)</li></ol><h2><span id="网络">网络：</span></h2><ol><li><p>tcp的三次握手和四次挥手：<br>第一次：c端发送连接请求 序列号seq=x SYN创建连接状态<br>第二次：b端收到信息后 发送确认码ack=x+1 SYN=1<br>第三次：c端收到后</p></li><li><p>http2.0</p></li><li>Android下网络优化方案</li><li>QUIC协议</li><li><h2><span id="android基础">Android基础：</span></h2>pt px dp<br>android sdk<br>JNI framework<br>安卓系统架构<br>安全机制（网络安全 本地数据安全 apk代码安全）<br>Java内存管理<br>LRUCahe DiskLRUCahe<br>RecyclerView 和ListView</li></ol><h2><span id="三方库">三方库：</span></h2><ol><li><p>eventbus原理<br>利用反射触发事件函数的执行<br>关键的一个键值对来存储数据 key是eventType（传递的时事件类型）<br>线程模式 posting：处理函数看post在线程就在什么线程执行<br>main：处理函数在主线程执行<br>background：处理函数在子线程 post如果在主线程辉创建子线程 如果在子线程就直接在子线程触发处理<br>async：新建子线程触发处理函数的执行</p></li><li><p>butterknife原理</p></li><li>okhttp</li><li>rxjava</li><li>retrofit</li><li>Glide Fresco 三级缓冲</li></ol><h2><span id="其他">其他：</span></h2><p>对称加密和非对称加密<br>工作中解决了什么难题，做了什么有成就感的项目（这个问题一定会问到，所以肯定要做准备）</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android数据的持久化</title>
      <link href="/2018/06/28/Android%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2018/06/28/Android%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>常见的存储的方式为SQlite数据存储、xml存储以及自定义数据格式的存储方式<br><a id="more"></a></p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android 中gradle依赖冲突解决</title>
      <link href="/2017/11/24/android-%E4%B8%ADgradle%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/"/>
      <url>/2017/11/24/android-%E4%B8%ADgradle%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>android项目开发中经常会遇到库依赖异常，大多是版本依赖的冲突问题，说明下常见的版本依赖冲突解决方式</p><p>首页看下我们项目的依赖关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew dependencies :app:dependencies</span><br></pre></td></tr></table></figure></p><p><img src="2847241-08589a6078bf5336.png" alt="依赖包结构" title="依赖包结构"></p><blockquote><p>:app表示依赖module<br>mac下运行可能人别不了命令行，运行<figure class="highlight plain"><figcaption><span>+x gradlew ```添加权限</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以看到依赖结构是树状结构，各库下又依赖了android的官方提供的一些库，如果依赖的库不是太多的话，可以使用transitive参数，使得依赖库所需的依赖不直接使用，在依赖库的module中同一级上做依赖关系</span><br><span class="line">``` </span><br><span class="line">implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; </span><br><span class="line">    compile (&apos;com.alibaba.android:vlayout:1.2.2@aar&apos;) &#123;</span><br><span class="line">        transitive = false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>transitive为false表示单独依赖，true为默认树状依赖</p><p>这种解决方式只用于当前的依赖包只是版本导致的，且版本变动不大，起码它的代码package路径一致，如果差异很大可以指定依赖关系中特定包不包含到依赖中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;</span><br><span class="line">    compile (&apos;com.alibaba.android:vlayout:1.2.2@aar&apos;) &#123;</span><br><span class="line">        exclude group: &apos;support-v4&apos;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基础知识</title>
      <link href="/2017/11/07/git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2017/11/07/git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1><span id="git基础知识">git基础知识</span></h1><p>——创建新的ssh key</p><figure class="highlight plain"><figcaption><span>ssh-keygen -t rsa -C "793021170@qq.com"```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">------测试 ssh 链接 github</span><br><span class="line"></span><br><span class="line">```$ ssh -T git@git.oschina.net</span><br></pre></td></tr></table></figure><p>——设置用户名、邮箱</p><figure class="highlight plain"><figcaption><span>git config --global user.name "litchi"```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```$ git config --global user.email &quot;793021170@qq.com&quot;</span><br></pre></td></tr></table></figure><p>——提交到远程服务器</p><figure class="highlight plain"><figcaption><span>git remote add origin ssh://git@dev.lemote.com/rt4ls.git```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```$ git push origin master</span><br></pre></td></tr></table></figure><p>——-本地库中缺少md文件时<br><figure class="highlight plain"><figcaption><span>git pull --rebase origin master```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-------由于远程库是空的，我们第一次推送master分支时，</span><br><span class="line">加上了-u参数，Git不但会把本地的master分支内容推送的远</span><br><span class="line">程新的master分支，还会把本地的master分支和远程的master</span><br><span class="line">分支关联起来，在以后的推送或者拉取时就可以简化命令</span><br><span class="line"></span><br><span class="line">```$　git push -u origin master</span><br></pre></td></tr></table></figure></p><p>——-关联远程库<br><figure class="highlight plain"><figcaption><span>git remote add origin git@server-name:path/repo-name.git```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git checkout master //进入master分支</span><br><span class="line"></span><br><span class="line">git checkout -b frommaster //以master为源创建分支frommaster</span><br><span class="line"></span><br><span class="line">git show # 显示某次提交的内容 git show $id</span><br><span class="line"></span><br><span class="line">git co -- &lt;file&gt; # 抛弃工作区修改</span><br><span class="line"></span><br><span class="line">git co . # 抛弃工作区修改</span><br><span class="line"></span><br><span class="line">git add &lt;file&gt; # 将工作文件修改提交到本地暂存区</span><br><span class="line"></span><br><span class="line">git add . # 将所有修改过的工作文件提交暂存区</span><br><span class="line"></span><br><span class="line">git rm &lt;file&gt; # 从版本库中删除文件</span><br><span class="line"></span><br><span class="line">git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件</span><br><span class="line"></span><br><span class="line">git reset &lt;file&gt; # 从暂存区恢复到工作文件</span><br><span class="line"></span><br><span class="line">git reset -- . # 从暂存区恢复到工作文件</span><br><span class="line"></span><br><span class="line">git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改</span><br><span class="line"></span><br><span class="line">git ci &lt;file&gt; git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　git ci -am &quot;some comments&quot;</span><br><span class="line"></span><br><span class="line">git ci --amend # 修改最后一次提交记录</span><br><span class="line"></span><br><span class="line">git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象</span><br><span class="line"></span><br><span class="line">git revert HEAD # 恢复最后一次提交的状态</span><br><span class="line"></span><br><span class="line">查看文件diff</span><br><span class="line"></span><br><span class="line">git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diff</span><br><span class="line"></span><br><span class="line">git diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异</span><br><span class="line"></span><br><span class="line">git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较</span><br><span class="line"></span><br><span class="line">git diff --staged # 比较暂存区和版本库差异</span><br><span class="line"></span><br><span class="line">git diff --cached # 比较暂存区和版本库差异</span><br><span class="line"></span><br><span class="line">git diff --stat # 仅仅比较统计信息</span><br><span class="line"></span><br><span class="line">查看提交记录</span><br><span class="line"></span><br><span class="line">git log git log &lt;file&gt; # 查看该文件每次提交记录</span><br><span class="line"></span><br><span class="line">git log -p &lt;file&gt; # 查看每次详细修改内容的diff</span><br><span class="line"></span><br><span class="line">git log -p -2 # 查看最近两次详细修改内容的diff</span><br><span class="line"></span><br><span class="line">git log --stat #查看提交统计信息</span><br><span class="line"></span><br><span class="line">tig</span><br><span class="line"></span><br><span class="line">Mac上可以使用tig代替diff和log，brew install tig</span><br><span class="line"></span><br><span class="line">Git 本地分支管理</span><br><span class="line"></span><br><span class="line">查看、切换、创建和删除分支</span><br><span class="line"></span><br><span class="line">git br -r # 查看远程分支</span><br><span class="line"></span><br><span class="line">git br &lt;new_branch&gt; # 创建新的分支</span><br><span class="line"></span><br><span class="line">git br -v # 查看各个分支最后提交信息</span><br><span class="line"></span><br><span class="line">git br --merged # 查看已经被合并到当前分支的分支</span><br><span class="line"></span><br><span class="line">git br --no-merged # 查看尚未被合并到当前分支的分支</span><br><span class="line"></span><br><span class="line">git co &lt;branch&gt; # 切换到某个分支</span><br><span class="line"></span><br><span class="line">git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去</span><br><span class="line"></span><br><span class="line">git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branch</span><br><span class="line"></span><br><span class="line">git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除</span><br><span class="line"></span><br><span class="line">git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支</span><br><span class="line"></span><br><span class="line">git br -d &lt;branch&gt; # 删除某个分支</span><br><span class="line"></span><br><span class="line">git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)</span><br><span class="line"></span><br><span class="line"> 分支合并和rebase</span><br><span class="line"></span><br><span class="line">git merge &lt;branch&gt; # 将branch分支合并到当前分支</span><br><span class="line"></span><br><span class="line">git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交</span><br><span class="line"></span><br><span class="line">git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"> Git补丁管理(方便在多台机器上开发同步时用)</span><br><span class="line"></span><br><span class="line">git diff &gt; ../sync.patch # 生成补丁</span><br><span class="line"></span><br><span class="line">git apply ../sync.patch # 打补丁</span><br><span class="line"></span><br><span class="line">git apply --check ../sync.patch #测试补丁能否成功</span><br><span class="line"></span><br><span class="line"> Git暂存管理</span><br><span class="line"></span><br><span class="line">git stash save “ ” # 暂存</span><br><span class="line"></span><br><span class="line">git stash list # 列所有stash</span><br><span class="line"></span><br><span class="line">git stash apply stash@&#123;$num&#125; # 恢复暂存的内容</span><br><span class="line"></span><br><span class="line">git stash drop stash@&#123;$num&#125; # 删除暂存区</span><br><span class="line"></span><br><span class="line">Git远程分支管理</span><br><span class="line"></span><br><span class="line">git pull # 抓取远程仓库所有分支更新并合并到本地</span><br><span class="line"></span><br><span class="line">git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并</span><br><span class="line"></span><br><span class="line">git fetch origin # 抓取远程仓库更新</span><br><span class="line"></span><br><span class="line">git merge origin/master # 将远程主分支合并到本地当前分支</span><br><span class="line"></span><br><span class="line">git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支</span><br><span class="line"></span><br><span class="line">git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上</span><br><span class="line"></span><br><span class="line">git push # push所有分支</span><br><span class="line"></span><br><span class="line">git push origin master # 将本地主分支推到远程主分支</span><br><span class="line"></span><br><span class="line">git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)</span><br><span class="line"></span><br><span class="line">git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名</span><br><span class="line"></span><br><span class="line">git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支</span><br><span class="line"></span><br><span class="line">git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支</span><br><span class="line"></span><br><span class="line">Git远程仓库管理</span><br><span class="line"></span><br><span class="line">GitHub</span><br><span class="line"></span><br><span class="line">git remote -v # 查看远程服务器地址和仓库名称</span><br><span class="line"></span><br><span class="line">git remote show origin # 查看远程服务器仓库状态</span><br><span class="line"></span><br><span class="line">git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址</span><br><span class="line"></span><br><span class="line">git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm &lt;repository&gt; # 删除远程仓库</span><br><span class="line"></span><br><span class="line">创建远程仓库</span><br><span class="line"></span><br><span class="line">git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库</span><br><span class="line"></span><br><span class="line">scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上</span><br><span class="line"></span><br><span class="line">mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库</span><br><span class="line"></span><br><span class="line">git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址</span><br><span class="line"></span><br><span class="line">git push -u origin master # 客户端首次提交</span><br><span class="line"></span><br><span class="line">git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track</span><br><span class="line"></span><br><span class="line">git remote set-head origin master # 设置远程仓库的HEAD指向master分支</span><br><span class="line"></span><br><span class="line">也可以命令设置跟踪远程库和本地库</span><br><span class="line"></span><br><span class="line">git branch --set-upstream master origin/master</span><br><span class="line"></span><br><span class="line">git branch --set-upstream develop origin/develop</span><br><span class="line"></span><br><span class="line">--------显示command的help</span><br><span class="line"></span><br><span class="line">```git help &lt;command&gt; #</span><br></pre></td></tr></table></figure></p><p>异常处理：<br>1.如果出现remote origin already exists.需要删除远程库后在执行git remote add origin<br> 具体执行：git remote rm origin<br> git remote add origin <a href="mailto:git@git.oschina.net" target="_blank" rel="noopener">git@git.oschina.net</a>:jichengliu/SilkMarke</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之工厂模式</title>
      <link href="/2017/11/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/11/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1><span id="设计模式之工厂模式">设计模式之工厂模式</span></h1><h2><span id="前言">前言</span></h2><p>最近在看设计模式相关的一些知识，看了一些感觉还是要做一些记录的，一方面用来记录当前情况下个人对设计模式的理解程度，使得这块知识更加深刻，另一方面也是方便把自己的一些拙见拿出来希望能够共同进步，得到众人的指正。</p><h2><span id="引入">引入</span></h2><p>工厂模式应该说最常见的模式，看一些介绍模式的书里工厂模式基本都是第一个被提到的，它应用场景比较多，也容易被理解。它是名如其模式，先来分析下它的名字，“工厂”用来生产各种产品，我们可以直接通过工厂来获得需要的各种产品，而不需要来考虑其具体的实现，所谓的“工厂”就类似于“商店”，提供我们需要所需产品。那么“工厂”的产品是怎么样获得的呢，“工厂”会根据我们具体的需求来利用具体的“材料”来“生产”具体的产品，到这里来看图说话。</p><p><img src="20171106-143320.png" alt="factory" title="factory"></p><blockquote></blockquote><p>上图就是对上面文字的一个概括，这里先又了这个概念就OK了，下面深入到代码层面来说明。</p><h2><span id="代码实现">代码实现</span></h2><p>这里用<a href="#introduced">引入</a>中最原始的提到的工厂、产品和消费者举例。<br>例子在android studio中android项目中开发。</p><h3><span id="工厂-产品和消费者">工厂、产品和消费者</span></h3><p><img src="QQ20171106-175109@2x.png" alt="factory" title="factory"></p><p>创建一个工厂类(Factory),提供一个获得产品的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得产品对象实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P    extends BaseProduct&gt;   p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> p</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;P extends BaseProduct&gt; <span class="function">P <span class="title">getProduct</span><span class="params">(Class&lt;P&gt; clazz)</span> </span>&#123;</span><br><span class="line">        P p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p = (P) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个接口(IProduct)，商品类将实现produce()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseProduct <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别创建商品类(BaseProduct、ProductOne、ProductTwo、ProductThree和ProductFour)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseProduct</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBaseComponents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//制作基础组件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductOne</span> <span class="keyword">extends</span> <span class="title">BaseProduct</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseProduct <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        makeBaseComponents();</span><br><span class="line">        Log.d(<span class="string">"ProductOne"</span>, <span class="string">"make ProductOne"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductTwo</span> <span class="keyword">extends</span> <span class="title">BaseProduct</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseProduct <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        makeBaseComponents();</span><br><span class="line">        Log.d(<span class="string">"ProductTwo"</span>, <span class="string">"make ProductTwo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductThree</span> <span class="keyword">extends</span> <span class="title">BaseProduct</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseProduct <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        makeBaseComponents();</span><br><span class="line">        Log.d(<span class="string">"ProductThree"</span>, <span class="string">"make ProductThree"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFour</span> <span class="keyword">extends</span> <span class="title">BaseProduct</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseProduct <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        makeBaseComponents();</span><br><span class="line">        Log.d(<span class="string">"ProductFour"</span>, <span class="string">"make ProductFour"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MainActivity类中获得需要的商品类实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetProduct</span><span class="params">(<span class="keyword">int</span> productType)</span> </span>&#123;</span><br><span class="line">        Class&lt;? extends BaseProduct&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (productType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                clazz = ProductOne.class;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                clazz = ProductTwo.class;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                clazz = ProductThree.class;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                clazz = ProductFour.class;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BaseProduct product = Factory.getProduct(clazz);</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, product.produce(), Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetProductThree</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        onGetProduct(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetProductTwo</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        onGetProduct(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetProductOne</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        onGetProduct(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetProductFour</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        onGetProduct(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终我们实现在activity中获得了产品的实例对象</p><p><a href="https://github.com/litchicoder/factorypatternpro" target="_blank" rel="noopener">github</a></p><h2><span id="为什么要用工厂模式">为什么要用工厂模式</span></h2><p>在开发过程中常常会独立做一些模块供其他的开发者来用，这种情况下，其实对于其他的开发者来说要求在使用功能时尽量的简单、调用方便，他们不需要去了解里面的具体实现，只要简单调用就可以拿到对应的实例，这个时候对于工厂模式时一个可行的方案，当然在实际开发中可以会和其他的模式混用来达到效果，这个还要具问具析。对于我们可以在什么场景下利用工厂模式，这里列出一些它的利弊，以便在考虑使用时参考：</p><blockquote><p>利:</p><ol><li>多类型扩展好，如果新增了一种商品只要实现它的具体类和方法，即可根据类来获取其实例</li><li>具体实现是封闭的、不对外的</li><li>调用方便，可通过一个类型或者类名就可以获得具体实例</li></ol></blockquote><blockquote><p>弊<br>产品类创建方式单一，因为是通过类命来创建实例，这样创建不会像常见的直接new灵活<br>不适合单一产品时使用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown常用语法</title>
      <link href="/2017/11/06/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2017/11/06/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo command line</title>
      <link href="/2017/11/03/hexo-command-line/"/>
      <url>/2017/11/03/hexo-command-line/</url>
      
        <content type="html"><![CDATA[<h1><span id="create-a-new-post">Create a new post</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h1><span id="run-server">Run server</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h1><span id="generate-static-files">Generate static files</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h1><span id="deploy-to-remote-sites">Deploy to remote sites</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux环境下jdk安装配置</title>
      <link href="/2017/11/03/linux%E7%8E%AF%E5%A2%83%E4%B8%8Bjdk%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/11/03/linux%E7%8E%AF%E5%A2%83%E4%B8%8Bjdk%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<ul><li><p>jdk下载</p><pre><code>wget -O jdk-8u131-linux-x64.tar.gz jdk-8u131-linux-x64.tar.gzAuthParam=1499664230_984ba136862e0fd6281ac5bc2bee90e2</code></pre></li><li><p>解压文件</p><pre><code>tar xf jdk-8u131-linux-x64.tar.gz</code></pre></li><li><p>创建要存放的目录并复制解压后的jdk文件到目录下</p></li></ul><a id="more"></a><ul><li><p>修改配置文件，指向存放jdk的目录</p><pre><code>cd etc(进入etc目录)vi profile（打开profile文件并修改环境变量source profile（使文件生效)</code></pre></li></ul><p><img src="2847241-08589a6078bf5336.png" alt="linux环境下jdk安装配置" title="linux环境下jdk安装配置"></p><ul><li><p>测试</p><pre><code>java -version</code></pre></li></ul><p>能够打印java 版本号信息就表示安装或升级成功</p><p><img src="2847241-dd005818079d56ba.png" alt="linux环境下jdk安装配置" title="linux环境下jdk安装配置"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux环境下Jenkins搭建</title>
      <link href="/2017/11/03/linux%E7%8E%AF%E5%A2%83%E4%B8%8BJenkins%E6%90%AD%E5%BB%BA/"/>
      <url>/2017/11/03/linux%E7%8E%AF%E5%A2%83%E4%B8%8BJenkins%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3><span id="安装java环境">安装java环境</span></h3><p>具体查看Linux java环境安装</p><h3><span id="安装tomcat">安装tomcat</span></h3><p>从tomcat官网上下载最新的安装压缩包，注意区分选择不同操作环境下的压缩包.（Linux一般是 tar.gz，Windows一般用zip压缩包），选择对应的压缩包能保证系统可以直接解压，避免不支持时还需安转压缩工具。</p><ol><li><p>下载压缩包</p><pre><code>wget http://apache.fayea.com/tomcat/tomcat-8/v8.5.16/bin/apache-tomcat-8.5.16.tar.gz</code></pre></li><li><p>解压压缩包</p><pre><code>tar xf apache-tomcat-8.5.16.tar.gz</code></pre></li><li><p>进入解压后的文件夹并将所有的复制到自己要安装的目录下</p><pre><code>cd apache-tomcat-8.5.16cp -rf ./*  /usr/local/tomcat/</code></pre></li></ol><a id="more"></a><h3><span id="安装sdk">安装SDK</span></h3><p>根据镜像下载sdk包即可，注意最新的sdk可能没有platform tools文件夹，可下在低版本的将platform tolls文件夹移动到最新的sdk文件夹下即可。</p><p>有一些插件也可以在没有sdk时自动在Jenkins搭建好后构建时自动下载sdk，如Android Emulator Plugin在配置好后它自己会根据配置参数自动去下载对应的sdk版本，这里后面会说到。</p><h3><span id="安装jenkins">安装Jenkins</span></h3><p>从Jenkins官网下载并复制jenkins.war到tomcat目录下webapps下。</p><pre><code>wget http://mirrors.jenkins.io/war/latest/jenkins.warcp ./jenkins.war /usr/local/tomcat/webapps</code></pre><p>启动Tomcat在浏览器中打开http://网址:8080/jenkins/就可以打开Jenkins网页，接下来就可以创建项目，Jenkins玩起来了。</p><h3><span id="注">注：</span></h3><ol><li><p>如果要使用其他端口来使用Jenkins可以运行命令：</p><pre><code>java -jar jenkins.war --httpPort=端口号java -jar jenkins.war --httpPort=8899 --daemon --logfile=日志路径/jenkins/jenkins.log(在后台运行)</code></pre></li><li><p>在打开Jenkins网页前要保证对应的端口号可访问，aliyun要配置安全组，开放对应端口。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Jenkins tomcat Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>note</title>
      <link href="/2017/11/03/note/"/>
      <url>/2017/11/03/note/</url>
      
        <content type="html"><![CDATA[<p>hexo官方教程地址<a href="http:https://hexo.io/zh-cn/" target="_blank" rel="noopener">http:https://hexo.io/zh-cn/</a></p><p>markdown 教程<a href="http:http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-8/" target="_blank" rel="noopener">http:http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-8/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins参数化构建android项目</title>
      <link href="/2017/11/03/Jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BAandroid%E9%A1%B9%E7%9B%AE/"/>
      <url>/2017/11/03/Jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BAandroid%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3><span id="达到的目标">达到的目标：</span></h3><ol><li>根据版本类型(release、beta or debug)、版本号、渠道、服务器请求地址等参数进行构建；</li><li>构建完成后显示相关构建信息；</li><li>展示apk下载二维码、下载地址供直接安装和下载apk</li></ol><h3><span id="需要的插件">需要的插件：</span></h3><ol><li>Dynamic Extended Choice Parameter plugin参数化选择需要</li><li>Description Setter Plugin构建的信息显示需要</li><li>GIt Plugingit 插件</li></ol><a id="more"></a><h3><span id="配置项目参数">配置项目参数：</span></h3><ul><li>设置构建类型参数：</li></ul><p>在general模块中复选‘参数化构建过程’，‘添加参数‘中选择’Choice Parameter‘;</p><p><img src="/images/2847241-7702d781810fa0aa.png" alt="‘添加参数‘中选择’Choice Parameter‘" title="添加参数‘中选择’Choice Parameter"></p><p>Name添加参数名，按照Jenkins已有的默认参数集来定义都以大写字母和下划线组成，例：ENVIRONMENT_BUILD，Choices输入item的选项，第一项会变成默认项。<br><img src="/images/2847241-b06b00a4496b0abb.png" alt="&#39;设置参数’Choice Parameter&#39;‘" title="设置参数’Choice Parameter"></p><p>设置列表型参数渠道、版本号、服务器请求地址等：</p><p>列表型参数和构建类型一样，设置name、Choices和Description。<br><img src="/images/2847241-209a8bc3095e2fd6.png" alt="&#39;设置参数’Choice Parameter&#39;‘" title="设置参数’Choice Parameter"></p><ul><li>配置git参数：</li></ul><p>这里首先要保证我们的代码在每个版本都有独立的版本分支，通过不同的版本名来拉取对应的代码，来实现分版本构建。<br><img src="/images/2847241-93622e27d0f82c4b.png" alt="&#39;git参数设置’Choice Parameter&#39;‘" title="git参数设置"></p><ul><li>配置构建命令参数：</li></ul><p>Tasks输入框输入构建命令行  clean assemble${PRODUCT_FLAVOR_BUILD}${ENVIRONMENT_BUILD}，${参数}表示参数应用，‘PRODUCT_FLAVOR_BUILD’是自定义的参数用来表示构建渠道，‘ENVIRONMENT_BUILD’表示构建类型。<br><img src="/images/2847241-10b29af455218b6e.png" alt="&#39;配置构建命令参数‘" title="配置构建命令参数"></p><ul><li>配置构建后描述参数：</li></ul><p>在‘构建’模块‘增加构建步骤’列表中选择‘set build description’，在Description输入框输入html代码，例如下，其中的‘${参数}’表示自定义的一些参数，用‘${参数}’来取对应的值。<br><img src="/images/2847241-b271fd19719d9abf.png" alt="&#39;配置构建后描述参数‘" title="配置构建后描述参数"></p><p>请求环境：${JENKINS_SERVER_HOST}<br>构建类型：${ENVIRONMENT_BUILD}<br>构建渠道：${PRODUCT_FLAVOR_BUILD}<br>构建版本：${APP_BUILD_VERSION}<br>点击查看二维码<br>点击下载apk</p><p>注：如果在构建完后显示还是按照文本显示的，修改一下系统管理／安全配置中‘Markup Formatter‘选择为Safe HTML，来支持html。</p><p>配置效果：<br><img src="/images/2847241-d826648aaeaada30.png" alt="&#39;实现效果‘" title="实现效果"><br><img src="/images/2847241-ccc5d7404bf2a218.png" alt="&#39;实现效果‘" title="实现效果"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Jenkins Android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
