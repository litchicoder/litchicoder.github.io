<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>litchi</title>
  
  <subtitle>litchi blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2021-02-02T14:11:40.185Z</updated>
  <id>/</id>
  
  <author>
    <name>litchi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OkHttp3</title>
    <link href="/2021/02/01/OkHttp3/"/>
    <id>/2021/02/01/OkHttp3/</id>
    <published>2021-02-01T04:07:22.000Z</published>
    <updated>2021-02-02T14:11:40.185Z</updated>
    
    <content type="html"><![CDATA[<p><img src="peitu.jpg" alt=""></p><p>本文主要以源码形式解读OkHttp内部实现,源码基于okhttp:3.10.0。  </p><h2><span id="同步请求">同步请求</span></h2><h3><span id="异步请求的例子">异步请求的例子</span></h3><p>先看一个异步请求的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(1) builder模式配置参数构建request对象</span></span><br><span class="line"> Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(<span class="string">"http://baidu.com?key=values"</span>)</span><br><span class="line">                .get()</span><br><span class="line">                .build();</span><br><span class="line">            <span class="comment">//(2)builder构建OkHttpClient对象</span></span><br><span class="line">        <span class="keyword">new</span> OkHttpClient.Builder().build()</span><br><span class="line">                .newCall(request)<span class="comment">//(3)request入参返回RealCall</span></span><br><span class="line">                .enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;<span class="comment">//(4)请求回调</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"thread:"</span>+Thread.currentThread());</span><br><span class="line">                        <span class="keyword">if</span> (response.isSuccessful()) &#123;</span><br><span class="line">                            ResponseBody responseBody = response.body();</span><br><span class="line">                            data.setText(responseBody.string());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><p>上面是一个OkHttp异步请求的代码，先构建一个Request对象设置请求地址、请求方式、header以及非GET请求还可设置body，然后创建OkHttpClient对象调用newCall设置request对象得到RealCall，RealCall调用enqueue发起异步请求设置请求回调完成了一个简单的异步请求，OkHttpClient在实际开发中需要单例，原因会在后面的内容中有答案。</p><h3><span id="1接下来先看下request内部">（1）接下来先看下Request内部：</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An HTTP request. Instances of this class are immutable if their &#123;<span class="doctag">@link</span> #body&#125; is null or itself</span></span><br><span class="line"><span class="comment"> * immutable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> HttpUrl url;</span><br><span class="line">  <span class="keyword">final</span> String method;</span><br><span class="line">  <span class="keyword">final</span> Headers headers;</span><br><span class="line">  <span class="keyword">final</span> <span class="meta">@Nullable</span> RequestBody body;</span><br><span class="line">  <span class="keyword">final</span> Object tag;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> CacheControl cacheControl; <span class="comment">// Lazily initialized.</span></span><br><span class="line"></span><br><span class="line">  Request(Builder builder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.url = builder.url;</span><br><span class="line">    <span class="keyword">this</span>.method = builder.method;</span><br><span class="line">    <span class="keyword">this</span>.headers = builder.headers.build();</span><br><span class="line">    <span class="keyword">this</span>.body = builder.body;</span><br><span class="line">    <span class="keyword">this</span>.tag = builder.tag != <span class="keyword">null</span> ? builder.tag : <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attaches &#123;<span class="doctag">@code</span> tag&#125; to the request. It can be used later to cancel the request. If the tag</span></span><br><span class="line"><span class="comment">     * is unspecified or null, the request is canceled by using the request itself as the tag.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">tag</span><span class="params">(Object tag)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.tag = tag;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"url == null"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Request(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Request包含请求的参数url请求地址、method请求方法、header请求头数据、请求body以及tag标签。</p><h3><span id="2接下来看用于外部调用的okhttpclient类okhttpclient对象的创建也是通过builder模式所以只关注它的构造方法">（2）接下来看用于外部调用的OkHttpClient类,OkHttpClient对象的创建也是通过builder模式，所以只关注它的构造方法：</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient(Builder builder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dispatcher = builder.dispatcher;<span class="comment">//（1）分发器</span></span><br><span class="line">    <span class="keyword">this</span>.proxy = builder.proxy;<span class="comment">//（2）代理类</span></span><br><span class="line">    <span class="keyword">this</span>.protocols = builder.protocols;<span class="comment">//（3）协议类</span></span><br><span class="line">    <span class="keyword">this</span>.connectionSpecs = builder.connectionSpecs;<span class="comment">//（4）连接规模 确定TLS版本和密码套件</span></span><br><span class="line">    <span class="keyword">this</span>.interceptors = Util.immutableList(builder.interceptors);<span class="comment">//（5）自定义应用拦截器</span></span><br><span class="line">    <span class="keyword">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors);<span class="comment">//（6）自定义网络拦截器</span></span><br><span class="line">    <span class="keyword">this</span>.eventListenerFactory = builder.eventListenerFactory;<span class="comment">//（7）事件监听工厂</span></span><br><span class="line">    <span class="keyword">this</span>.proxySelector = builder.proxySelector;<span class="comment">//（8）代理选择器</span></span><br><span class="line">    <span class="keyword">this</span>.cookieJar = builder.cookieJar;</span><br><span class="line">    <span class="keyword">this</span>.cache = builder.cache;<span class="comment">//（9）缓冲类</span></span><br><span class="line">    <span class="keyword">this</span>.internalCache = builder.internalCache;<span class="comment">//（10）</span></span><br><span class="line">    <span class="keyword">this</span>.socketFactory = builder.socketFactory;<span class="comment">//（11）socket工厂</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">boolean</span> isTLS = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (ConnectionSpec spec : connectionSpecs) &#123;</span><br><span class="line">      isTLS = isTLS || spec.isTls();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (builder.sslSocketFactory != <span class="keyword">null</span> || !isTLS) &#123;</span><br><span class="line">      <span class="keyword">this</span>.sslSocketFactory = builder.sslSocketFactory;</span><br><span class="line">      <span class="keyword">this</span>.certificateChainCleaner = builder.certificateChainCleaner;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      X509TrustManager trustManager = systemDefaultTrustManager();</span><br><span class="line">      <span class="keyword">this</span>.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);</span><br><span class="line">      <span class="keyword">this</span>.certificateChainCleaner = CertificateChainCleaner.get(trustManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.hostnameVerifier = builder.hostnameVerifier;</span><br><span class="line">    <span class="keyword">this</span>.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(</span><br><span class="line">        certificateChainCleaner);</span><br><span class="line">    <span class="keyword">this</span>.proxyAuthenticator = builder.proxyAuthenticator;</span><br><span class="line">    <span class="keyword">this</span>.authenticator = builder.authenticator;</span><br><span class="line">    <span class="keyword">this</span>.connectionPool = builder.connectionPool;<span class="comment">//（12）连接池</span></span><br><span class="line">    <span class="keyword">this</span>.dns = builder.dns;</span><br><span class="line">    <span class="keyword">this</span>.followSslRedirects = builder.followSslRedirects;</span><br><span class="line">    <span class="keyword">this</span>.followRedirects = builder.followRedirects;</span><br><span class="line">    <span class="keyword">this</span>.retryOnConnectionFailure = builder.retryOnConnectionFailure;</span><br><span class="line">    <span class="keyword">this</span>.connectTimeout = builder.connectTimeout;</span><br><span class="line">    <span class="keyword">this</span>.readTimeout = builder.readTimeout;</span><br><span class="line">    <span class="keyword">this</span>.writeTimeout = builder.writeTimeout;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>（12）OkHttp创建了自己的连接池所以在使用过程中要用单例。  </p><h3><span id="3接着调用了okhttpclientnewcallreq">（3）接着调用了OkHttpClient.newCall(req):</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Prepares the &#123;<span class="doctag">@code</span> request&#125; to be executed at some point in the future.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>newCall方法内部调用RealCall.newRealCall方法并返回Call对象：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);<span class="comment">//(1)</span></span><br><span class="line">    call.eventListener = client.eventListenerFactory().create(call);<span class="comment">//(2)</span></span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>(1)创建RealCall对象；RealCall对象持有OkHttpClient和Request，构造方法中还创建了重试/重定向拦截器RetryAndFollowInterceptor；<br>(2)从OkHttpClient得到evenListener对象，</p><h3><span id="4调用异步请求realcallenqueue方法">（4）调用异步请求RealCall.enqueue方法:</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);（<span class="number">1</span>）</span><br><span class="line">     executed = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   captureCallStackTrace();（<span class="number">2</span>）</span><br><span class="line">   eventListener.callStart(<span class="keyword">this</span>);（<span class="number">3</span>）</span><br><span class="line">   client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));<span class="comment">//（4）</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>（1）如果call已经被执行，抛出异常；<br>（2） 捕获RealCall类的栈轨迹；<br>（3）触发监听方法callStart(),表示请求开始；<br>（4）执行dispatcher分发器enqueue方法，创建了AsyncCall类，AsyncCall传入responseCallback。</p><p>下面查看dispatcher的enqueue方法：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;<span class="comment">//（1）</span></span><br><span class="line">     runningAsyncCalls.add(call);<span class="comment">//（2）</span></span><br><span class="line">     executorService().execute(call);<span class="comment">//（3）</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     readyAsyncCalls.add(call);<span class="comment">//（4）</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>（1）把call添加到正在运行的队列的判断依据：如果正在执行的异步请求数小于最大请求数（默认64），并且同一个主机执行的异步请求小于单个主机运行的最大请求数（默认5）否则添加到准备队列；<br> （2）根据（1）把call添加到正在运行的队列；<br> （3）将call交线程池执行；<br> （4）不满足（1）把call添加到准备队列。<br>AsyncCall是Runnable实现类，execute方法完成请求和返回的执行。<br>AsyncCall. execute():    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       Response response = getResponseWithInterceptorChain();<span class="comment">//（1）</span></span><br><span class="line">       <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;<span class="comment">//（2）</span></span><br><span class="line">         signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">         responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">         responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);<span class="comment">//（3）</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">         <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">         Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         eventListener.callFailed(RealCall.<span class="keyword">this</span>, e);<span class="comment">//（4）</span></span><br><span class="line">         responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);<span class="comment">//（5）</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       client.dispatcher().finished(<span class="keyword">this</span>);<span class="comment">//（6）</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> （1）getResponseWithInterceptorChain方法得到response对象，getResponseWithInterceptorChain是核心实现，后边专门展开说明；<br> （2）请求如果取消返回，调用responseCallback.onFailure通知处理请求失败；<br> （3）否则正常请求返回，调用responseCallback.onResponse返回response对象，调用方就可以拿到请求的数据返回，做具体业务处理；<br> （4）（5）回调执行eventListener.callFailed和responseCallback.onFailure；<br> （6）dispatcher执行finfished方法，finish内部会调用promoteCalls方法从readyAsyncCalls队列中取出call 添加到runningAsyncCalls中，executorService().execute(call)加入线程池中执行call。添加到runningAsyncCalls中的条件是小于运行runningAsyncCalls最大call数并且同一主机call数小于maxRequestsPerHost（即同一主机最大请求数）。</p><p>接下来分析核心方法getResponseWithInterceptorChain():  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());<span class="comment">//(1)</span></span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);<span class="comment">//(2)</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));<span class="comment">//(3)</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));<span class="comment">//(4)</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));<span class="comment">//(5)</span></span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());<span class="comment">//(6)</span></span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));<span class="comment">//(7)</span></span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);<span class="comment">//(8)</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>（1）构建全部拦截器list，先添加自定义应用层拦截器；<br>（2）添加重试/重定向拦截器；<br>（3）添加桥接拦截器；<br>（4）添加缓冲拦截器；<br>（5）添加连接拦截器；<br>（6）如果不是websocket，添加网络层拦截器；<br>（7）添加请求服务拦截器；<br>（8）传入拦截器list，请求，call对象，事件监听，连接超时时间以及读写超时时间生成Interceptor.Chain链对象，执行chain.proceed(originalRequest)。  </p><p>chain.proceed(originalRequest)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class="line"><span class="function"><span class="params">      RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">          + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">          + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + <span class="number">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);<span class="comment">//(1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class="line">    <span class="keyword">if</span> (httpCodec != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">          + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the intercepted response isn't null.</span></span><br><span class="line">    <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">          <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>(1)创建下一个RealInterceptorChain，传入interceptor.intercept方法，intercept中会执行nextchain.proceed方法，然后再继续创建下一个RealInterceptorChain，intercept再执行下一个nextchain.proceed方法，这样循环调用所有拦截器，到最后一个拦截器CallServerInterceptor停止遍历，返回response，遍历循环流程如下图：  </p><p><img src="" alt=""></p><p>接下来阅读自带的拦截器代码：</p><p>RetryAndFollowUpInterceptor：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request request = chain.request();</span><br><span class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">  Call call = realChain.call();</span><br><span class="line">  EventListener eventListener = realChain.eventListener();</span><br><span class="line"></span><br><span class="line">  StreamAllocation streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">      createAddress(request.url()), call, eventListener, callStackTrace);<span class="comment">//（1）</span></span><br><span class="line">  <span class="keyword">this</span>.streamAllocation = streamAllocation;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">  Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">      streamAllocation.release();<span class="comment">//（2）</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response;</span><br><span class="line">    <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);<span class="comment">//（3）</span></span><br><span class="line">      releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">      <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">      <span class="keyword">if</span> (!recover(e.getLastConnectException(), streamAllocation, <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getLastConnectException();<span class="comment">//（4）</span></span><br><span class="line">      &#125;</span><br><span class="line">      releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">      <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">      <span class="keyword">if</span> (!recover(e, streamAllocation, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">      releaseConnection = <span class="keyword">false</span>;<span class="comment">//（5）</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// We're throwing an unchecked exception. Release any resources.</span></span><br><span class="line">      <span class="keyword">if</span> (releaseConnection) &#123;<span class="comment">//（6）</span></span><br><span class="line">        streamAllocation.streamFailed(<span class="keyword">null</span>);</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">    <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;<span class="comment">//（7）</span></span><br><span class="line">      response = response.newBuilder()</span><br><span class="line">          .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                  .body(<span class="keyword">null</span>)</span><br><span class="line">                  .build())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request followUp = followUpRequest(response, streamAllocation.route());<span class="comment">//（8）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;<span class="comment">//（9）</span></span><br><span class="line">      <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closeQuietly(response.body());<span class="comment">//（10）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;<span class="comment">//（11）</span></span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (followUp.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;<span class="comment">//（12）</span></span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException(<span class="string">"Cannot retry streamed HTTP body"</span>, response.code());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;<span class="comment">//（13）</span></span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">          createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">      <span class="keyword">this</span>.streamAllocation = streamAllocation;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;<span class="comment">//（14）</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</span><br><span class="line">          + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request = followUp;<span class="comment">//（15）</span></span><br><span class="line">    priorResponse = response;<span class="comment">//（16）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）StreamAllocation用来协调连接（Connections）、流（Screams）和请求队列（Calls）<br>（2）如果请求取消，调用screamAllocation.release()。release方法会关闭socket，并回调 eventListener.connectionReleased。<br>（3）执行realChain.proceed方法，proceed内部会创建下一个chain，再传入下一个拦截器，拦截器intercept继续执行负责的工作，并调用chain.proceed()。<br>（4）如果realChain.proceed方法抛出RouteException，那么调用recover方法，recover方法返回false则不会重试连接，抛出IOException异常，异常会在Call.execute方法中捕获执行eventListener.callFailed和onFailure方法，返回false的条件如下：  </p><blockquote><p>1.应用层如果禁止重试 ；<br>2.定义了不可重复发送的请求body ；<br>3.捕获的异常严重等级属于致命 ；<br>4.没有更多的路由可重意重试；  </p></blockquote><p>如果上述的四种场景，请求会被发起重试。</p><p>（5）<br>（6）<br>（7）<br>（8）<br>（9）<br>（10）<br>（11）<br>（12）<br>（13）<br>（14）<br>（15）<br>（16）</p>]]></content>
    
    <summary type="html">
    
      源码
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Android组件化</title>
    <link href="/2021/01/30/Android%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    <id>/2021/01/30/Android组件化/</id>
    <published>2021-01-30T11:32:57.000Z</published>
    <updated>2021-02-01T05:50:03.754Z</updated>
    
    <content type="html"><![CDATA[<p><img src="peitu.jpg" alt=""></p><p>Android应用达到一定规模后业务会越来越多，所有业务模块在同一module下耦合性会越来越强，这种强耦合带来开发维护成本增加，开发调试效率也会变低，项目组件化就势在必行。  </p><a id="more"></a><h2><span id="组件化带来的优点">组件化带来的优点：</span></h2><p>1.项目模块清晰，组件向内高聚合，对外低耦合；<br>2.项目成员可以专注于具体组件内业务逻辑，降低开发成本；<br>3.可以独立调试，提升开发调试效率；<br>4.可以产出全局功能组件，服务于整个团队，快速响应新项目，达到功能重用。  </p><h2><span id="要实现组件化需要解决问题">要实现组件化需要解决问题：</span></h2><p>1.组件间页面如何跳转？<br>2.组件间如何实现功能调用？<br>3.如何独立组件或随意组合组件进行调试？<br>4.如何在各个组件间获取Application实例？<br>5.如何实现组件间代码隔离？</p><h2><span id="解决方式">解决方式</span></h2><p>针对以上五点问题找到以下五个解决方式：<br>1.利用路由框架实现页面也跳转，如ARoute，或者自行定义的路有跳转协议；<br>2.利用依赖注入实现组件间通信，调用方利用接口申明实现调用；<br>3.Android gradle提供两种插件，com.android.application表示App Module，com.android.library表示库Module，通过在gradle.properties中设置参数控制Module的插件类型制定App module，同时配置module的Application和manifest文件，这样就可以独立运行需要调整的module。<br>4.设计module_common组件创建BaseApplication，App壳module工程Application继承至BaseApplication，其他组件依赖module_common这样就拿到了Application实例。<br>5.组件之间不存在相互依赖，不能直接调用，它们都依赖到App壳module，这样就完成了组件间的隔离。  </p><h2><span id="组件化框架结构">组件化框架结构：</span></h2><p><img src="组件化结构.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      组件化实战
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Handler</title>
    <link href="/2021/01/27/Handler/"/>
    <id>/2021/01/27/Handler/</id>
    <published>2021-01-27T13:34:12.000Z</published>
    <updated>2021-01-30T05:53:34.485Z</updated>
    
    <content type="html"><![CDATA[<p><img src="peitu.jpg" alt=""><br>本篇分为三个部分记录Handler消息机制，第一部分逐一对“四件套”源码（基于Android-29）进行解读；第二部分根据源码总结它们之间的关联；第三部分对Handler涉及到的问题进行解答。</p><a id="more"></a><h1><span id="四件套">四件套</span></h1><h3><span id="message-消息">Message-消息</span></h3><p>Message的作用是消息载体本身，Message类内部主要是关键参数和创建方法。官方推荐使用Mesage.obtain()或者Handler.obtainMessage()来创建Message对象，利用缓冲中Message，避免了重复创建对象。这两个方法的内法调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment">     * avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="keyword">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a new &#123;<span class="doctag">@link</span> android.os.Message Message&#125; from the global message pool. More efficient than</span></span><br><span class="line"><span class="comment">    * creating and allocating new instances. The retrieved message has its handler set to this instance (Message.target == this).</span></span><br><span class="line"><span class="comment">    *  If you don't want that facility, just call Message.obtain() instead.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@NonNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//Handler.obtainMessage()内部又调用了Message.obtain(handler)</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but sets the value for the &lt;em&gt;target&lt;/em&gt; member on the Message returned.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> h  Handler to assign to the returned Message object's &lt;em&gt;target&lt;/em&gt; member.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> A Message object from the global pool.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h)</span> </span>&#123;</span><br><span class="line">       Message m = obtain();</span><br><span class="line">       m.target = h;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> m;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Handler.obtainMessage()其实是调用到了Message中的obtain()区别只是入参handler重新给message的target赋值，所以只需要关注Message.obtain()，sPool以链表形式存储了缓冲的Message对象，缓冲Message的链表不为空时就从尾部取出一个Message，为空直接创建。至于这里sPool中的Message是在什么时机缓冲起来,它其实是在looper的loop方法处理Message后调用msg.recycleUnchecked()加入到sPool缓冲池。</p><p>接下来说明Message中几个关键变量。<br>what是Message的唯一标示，来区分发送的Message，what值在不同handler是不需要考虑code冲突。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * User-defined message code so that the recipient can identify</span></span><br><span class="line"><span class="comment">     * what this message is about. Each &#123;<span class="doctag">@link</span> Handler&#125; has its own name-space</span></span><br><span class="line"><span class="comment">     * for message codes, so you do not need to worry about yours conflicting</span></span><br><span class="line"><span class="comment">     * with other handlers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> what;</span><br></pre></td></tr></table></figure><p>arg1和arg2用来传递数据是int类型的数据，obj是Object类型，可以传递所有继承Object的数据类型，如果Message用在跨进程通信时obj需要进行序列化;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * arg1 and arg2 are lower-cost alternatives to using</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #setData(Bundle) setData()&#125; if you only need to store a</span></span><br><span class="line"><span class="comment">     * few integer values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * arg1 and arg2 are lower-cost alternatives to using</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #setData(Bundle) setData()&#125; if you only need to store a</span></span><br><span class="line"><span class="comment">     * few integer values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An arbitrary object to send to the recipient.  When using</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Messenger&#125; to send the message across processes this can only</span></span><br><span class="line"><span class="comment">     * be non-null if it contains a Parcelable of a framework class (not one</span></span><br><span class="line"><span class="comment">     * implemented by the application).   For other data transfer use</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #setData&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that Parcelable objects here are not supported prior to</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@link</span> android.os.Build.VERSION_CODES#FROYO&#125; release.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object obj;</span><br></pre></td></tr></table></figure><p>when字段表示发送消息的时间字段，基准时间是SystemClock.uptimeMillis()，如果设置了发送延时时间when的值就是基准时间加延时时间;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The targeted delivery time of this message. The time-base is</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> SystemClock#uptimeMillis&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@hide</span> Only for use within the tests.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> when;</span><br></pre></td></tr></table></figure><p>data类型同样用来传递数据，data是Bundle类型，可以像Activity间传递消息一样设置key-values键值对交换数据;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bundle data;</span><br></pre></td></tr></table></figure><p>target是handler的引用, target的主要作用是在Looper的loop方法中用来分发Message;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable callback;</span><br></pre></td></tr></table></figure><p>Message还可以设置callback参数，在消息被Looper处理时调用Message的Runnable.run(),用在Message需要一一对应不同的Runnable。</p><h3><span id="messagequeue-消息队列维护message链表">MessageQueue-消息队列维护Message链表</span></h3><p>MessageQueue是以链表形式存储Message对象，enqueueMessage()插入对象并返回操作结果。next()主要作用是从Queue读取Message并从链表中移除，postSyncBarrier()用于在Queue中添加同步屏障。</p><p>MessageQueue.enqueueMessage()  ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">//(1)</span></span><br><span class="line">                IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">                <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">                <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">            <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>(1)Looper调用quit()后停止Message插入。<br>接下来的执行流程主要是链表的插入操作还有是否需要唤醒Looper轮询，判断依据是mBlocked（阻塞）和p.isAsynchronous()两个因素。  </p><p>MessageQueue.next():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">        <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">        <span class="comment">// which is not supported.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">        <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);<span class="comment">//(2)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;<span class="comment">//(3)</span></span><br><span class="line">                    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Got a message.</span></span><br><span class="line">                        mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        <span class="keyword">return</span> msg;<span class="comment">//(4)</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// No more messages.</span></span><br><span class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">                <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">                <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">                <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                    mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(5)</span></span><br><span class="line">            <span class="comment">// Run the idle handlers.</span></span><br><span class="line">            <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">                mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    keep = idler.queueIdle();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">            pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">            <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">            nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>(1)Looper调用quit()后停止执行。<br>(2)nativePollOnce()用于“等待”消息，知道下一条Message可用为止。<br>(3)这里是一种同步屏障机制，target==null作为同步屏障开启的标志循环找到一个异步消息，下面的操作中优先执行异步消息。同步屏障具体深入会在后面部分说明。<br>(4)链表中删除目标Message并返回。<br>(5)MessageQueue中没有Message时执行Idlehandler（闲时机制），Idlehandler.queueIdle()返回true，Idlehandler回调会在mIdleHandlers中保持存在，false回调执行完成后从mIdleHandlers中移除。  </p><p>MessageQueue.postSyncBarrier():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">        <span class="comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">            <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">            Message prev = <span class="keyword">null</span>;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法内部就是创建一个target为null的Message，在next方法中利用target等于null作为依据来判断是否设置同步屏障。同样对应removeSyncBarrier就是利用Message的token字段找到设置的同步屏障Message移除。</p><h3><span id="looper-消息循环器">Looper-消息循环器</span></h3><p>Looper主要职责是创建MessageQueue和处理Message。prepare方法创建looper对象添加到sThreadLocal中，Looper构造方法中同时创建MessageQueue。loop方法通过调用MessageQueue.next方法取出Message，调用msg.target的handleMessage方法交给对应handler处理Message。</p><p>prepare()和构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Initialize the current thread as a looper.</span></span><br><span class="line"><span class="comment">     * This gives you a chance to create handlers that then reference</span></span><br><span class="line"><span class="comment">     * this looper, before actually starting the loop. Be sure to call</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #quit()&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;（<span class="number">1</span>）</span><br><span class="line">       mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">       mThread = Thread.currentThread();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>(1)quitAllowed 为true表示允许停止,这里构造方法是私有的，public修饰的无参构造调用这里时传入true，所以我们在日常使用中，在工作线程创建的looper都是允许停止的，只有UI线程的looper是不允许停止。也就是我们不能通过Looper.quit()来停止主线程的looper，可以这样理解，如果主线的looper停止也就相当于应用程序停止工作。</p><p>loop():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">        <span class="comment">// adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start'</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> thresholdOverride =</span><br><span class="line">                SystemProperties.getInt(<span class="string">"log.looper."</span></span><br><span class="line">                        + Process.myUid() + <span class="string">"."</span></span><br><span class="line">                        + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">".slow"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;<span class="comment">//（1）</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">            <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                        msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Make sure the observer won't change while processing a transaction.</span></span><br><span class="line">            <span class="keyword">final</span> Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">            <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">            <span class="keyword">long</span> slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">            <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">                slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDelivery = (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDispatch = (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dispatchStart = needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dispatchEnd;</span><br><span class="line">            Object token = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                token = observer.messageDispatchStarting();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);<span class="comment">//（2)</span></span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    observer.messageDispatched(token, msg);</span><br><span class="line">                &#125;</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slowDeliveryDetected) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Drained"</span>);</span><br><span class="line">                        slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">"delivery"</span>,</span><br><span class="line">                            msg)) &#123;</span><br><span class="line">                        <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                        slowDeliveryDetected = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">                showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">"dispatch"</span>, msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();<span class="comment">//(3)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>(1)无限循环中queue调用next读取Message对象；<br>(2)调用hanlder.dispachMessage方法将Message交给handler处理；<br>(3)回收Message缓冲池未满时重置数据将Message添加到缓冲池。</p><h3><span id="hndler-消息处理器">Hndler-消息处理器</span></h3><p>Hndler负责发送Message和处理回调的各种Message，enqueueMessage方法发送消息，将消息添加到queue中，handleMessage方法处理回调回来Message，Handler中的方法在开发中经常会直接使用。removeMessages方法移除当前handler下的Message，内部调用MessageQueue.removeMessages,同样的方法还有removeCallbacks()和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    public boolean sendMessageAtTime(<span class="doctag">@NonNull</span> Message msg, long uptimeMillis) &#123;</span></span><br><span class="line"><span class="comment">        MessageQueue queue = mQueue;</span></span><br><span class="line"><span class="comment">        if (queue == null) &#123;</span></span><br><span class="line"><span class="comment">            RuntimeException e = new RuntimeException(</span></span><br><span class="line"><span class="comment">                    this + " sendMessageAtTime() called with no mQueue");</span></span><br><span class="line"><span class="comment">            Log.w("Looper", e.getMessage(), e);</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return enqueueMessage(queue, msg, uptimeMillis);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    private boolean enqueueMessage(<span class="doctag">@NonNull</span> MessageQueue queue, <span class="doctag">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="comment">            long uptimeMillis) &#123;</span></span><br><span class="line"><span class="comment">        msg.target = this;</span></span><br><span class="line"><span class="comment">        msg.workSourceUid = ThreadLocalWorkSource.getUid();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        if (mAsynchronous) &#123;</span></span><br><span class="line"><span class="comment">            msg.setAsynchronous(true);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return queue.enqueueMessage(msg, uptimeMillis);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Remove any pending posts of callbacks and sent messages whose</span></span><br><span class="line"><span class="comment">    * &lt;var&gt;obj&lt;/var&gt; is &lt;var&gt;token&lt;/var&gt;.  If &lt;var&gt;token&lt;/var&gt; is null,</span></span><br><span class="line"><span class="comment">    * all callbacks and messages will be removed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeCallbacksAndMessages</span><span class="params">(@Nullable Object token)</span> </span>&#123;</span><br><span class="line">       mQueue.removeCallbacksAndMessages(<span class="keyword">this</span>, token);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//MessageQueue.removeCallbacksAndMessages</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeCallbacksAndMessages</span><span class="params">(Handler h, Object object)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           Message p = mMessages;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Remove all messages at front.</span></span><br><span class="line">           <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.target == h</span><br><span class="line">                   &amp;&amp; (object == <span class="keyword">null</span> || p.obj == object)) &#123;</span><br><span class="line">               Message n = p.next;</span><br><span class="line">               mMessages = n;</span><br><span class="line">               p.recycleUnchecked();</span><br><span class="line">               p = n;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Remove all messages after front.</span></span><br><span class="line">           <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">               Message n = p.next;</span><br><span class="line">               <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (n.target == h &amp;&amp; (object == <span class="keyword">null</span> || n.obj == object)) &#123;</span><br><span class="line">                       Message nn = n.next;</span><br><span class="line">                       n.recycleUnchecked();</span><br><span class="line">                       p.next = nn;</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               p = n;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>hanlder中的发送Message和移除Message都是调用MessageQueue对链表做操作。</p><h1><span id="关联">关联</span></h1><p>上面对源码的解读，大致对各自的职责有了了解，这里对它们之间的联系做说明。  </p><blockquote><p>MessageQueue是以Message作为内容的链表结构，可以将Message插入到MessageQueue中，也可以将Message从MessageQueue中删除。<br>Looper负责循环读取MessageQueue中的Message，将Message调用给handler完成Message消息传递。<br>Handler负责将创建好的Message发送给MessageQueue，MessageQueue将其插入到链表中，同时Handler最终接收Looper从MessageQueue中读取的Message执行它的处理方法handleMessage。</p></blockquote><p><img src="handler.jpg" alt=""></p><h1><span id="为什么">为什么？</span></h1><ul><li>Handler消息机制的作用？<br>用于跨线程通信，Android中因为UI线程不能执行耗时操作，所以需要将耗时任务在子线程执行，子线程又不能更新UI，此时就需要handler通知UI线程执行UI操作。同样子线程与子线程也可以通过Handler通信。</li><li>什么是闲时机制？<br>IdleHandler是一个回调接口，它存储在一个数组中，当MessageQueue中的Message任务暂时停止处理（没有新任务或者下一任务延迟在后），这个时候就会调用这个接口的queueIdle()，方法返回false则会从list中移除，返回true在下次MessageQueue暂停处理时继续调用这个接口的queueIdle方法（代码在MessageQueue.next()）。</li><li>什么是同步屏障？<br>同步屏障就是把同步消息先屏蔽优先处理异步消息，调用MessageQueue.postSyncBarrier方法可以将一个target为空的Message插入到MessageQueue中，当Looper调用MessageQueue.next方法读取Message时首先会通过target为空来判断是否设置同步屏障，若存在，会先遍历消息链表跳过同步消息找到异步消息优先将异步消息返回给Looper执行调用。这是一种优先机制，把异步消息的优先级高于同步消息，ViewRootImpl.scheduleTraversals方法就使用了同步屏障，保证UI绘制优先执行(performTraversals())。  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">           mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">           mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">           mChoreographer.postCallback(</span><br><span class="line">                   Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">               scheduleConsumeBatchedInput();</span><br><span class="line">           &#125;</span><br><span class="line">           notifyRendererOfFramePending();</span><br><span class="line">           pokeDrawLockIfNeeded();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>mTraversalRunnable是一个Runnable对象，run方法中会调用performTraversals()执行UI绘制。  </p><ul><li>Looper.loop()为什么不会阻塞主线程？<br>loop方法会调用MessageQueue中next方法，next()调用本地方法nativePollOnce，没有新消息时会阻塞到nativePollOnce方法，nativePollOnce方法内部是基于Linux epoll机制实现阻塞，此时主线程会进入休眠状态，不会消耗cpu资源（pip管道当有数据写入时再唤醒主线程工作）。<br>引起ANR的原因是由于执行事件耗时太长，不能及时完成，而loop方法本身只是不停的循环读取消息，当有消息时loop是不会阻塞的，只有loop发送的事件耗时太长才会导致ANR。Activity的onCreate onResume 等生命周期回调方法操作时间太长才会导致卡死主线程掉帧甚至发生ANR（Activity一般超过5s就会发生ANR）。  </li><li>Thread、Hanlder、Looper和MessageQueue的数量级关系？<br>一个Thread可以有多个Handler，只有有一个Looper和MessageQueue,多个Handler创建的Message都添加到同一个MessageQueue中，Looper从MessageQueue中拿到Message通过Hadnler对象target分发到对应Handler处理回调。<br>Thread(1)==&gt;Looper(1)==&gt;MessageQueue(1)==&gt;Handler(N)</li></ul><p><img src="handler_looper_messagequeue_relation.jpg" alt=""></p><ul><li>引起内存泄漏的原因以及解决方案？<br>原因：由于java的特性，内部类会持有外部类的引用，所以Handler会持有Activity，Message中target对象又是Handler的引用，所以Message就持有了Activity，Activity调用销毁后如果当前HandlerMessage还在MessageQueue中，导致Activity不能被及时回收。<br>解决方案：<br>将Handler定义为静态内部类，持有Activity的弱引用并在Activity销毁时调用removeCallBacksAndMessages(null)移除所有消息。  </li><li>Handler发送一个延时消息是怎么更新MessageQueue？<br>如果此时MessageQueue中只有这个延时消息，消息不会被马上发送，而是计算唤醒时间让Looper阻塞，到唤醒时间时再唤醒Looper执行消息发送。如果MessageQueue中还有Message，延时消息被插入到时间排序的对应位置，MessageQueue中对头的when值最小，越往队尾值越大。</li></ul>]]></content>
    
    <summary type="html">
    
      源码解读
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>java局部内部类访问局部变量时为什么需要final来修饰？</title>
    <link href="/2021/01/12/java%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E8%AE%BF%E9%97%AE%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81final%E6%9D%A5%E4%BF%AE%E9%A5%B0%EF%BC%9F/"/>
    <id>/2021/01/12/java局部内部类访问局部变量时为什么需要final来修饰？/</id>
    <published>2021-01-12T10:10:41.000Z</published>
    <updated>2021-01-12T13:00:52.233Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> String str = <span class="string">"23"</span>;</span><br><span class="line">       Thread t=  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               System.out.println(<span class="string">"str:"</span>+str);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       t.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>test()是一个类的方法，Runnable是它的匿名内部类，局部变量str用了final修饰符，如果没有final修饰符将会报错，为什么呢？</p><p>test()方法对应虚拟机栈中的一个栈帧，当该栈帧出栈后其局部变量也就销毁，然这时存在内部类的方法需要访问str，就出现了生命周期不一致的情况，所以需要使用final将str变为常量来保证一致性。</p>]]></content>
    
    <summary type="html">
    
      JAVA基础
    
    </summary>
    
      <category term="JAVA基础" scheme="/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>2020结</title>
    <link href="/2020/12/23/2020%E7%BB%93/"/>
    <id>/2020/12/23/2020结/</id>
    <published>2020-12-23T09:55:44.000Z</published>
    <updated>2021-01-12T11:19:48.508Z</updated>
    
    <content type="html"><![CDATA[<p>2020年对于社会这个大环境来说是艰难的一年，对于我个人来说更是变动的一年，离开了从实习到如今四年的老东家，开始了一年的漂泊，到了年底还没有稳定下来，不过一年过来庆幸自己没有妥协，一直还在不断调整和思考。</p><p>2020就这样写下了记号，工作上这一年是没有成果的，物质和精神都没有，当然这些也不是年初计划太过于关注的点。2020如果说有一点点收获的话那是在生活状态和心理变化上，之前一直唯利，如今停下这个脚步也该看看走的稳不稳，走的累不累，当然也要感谢那几年的累积，才能让现在看的更明了一些，如果比作爬山，我觉得过去的四年我是前两年用力很猛，后两年有些疲软，这一年停下了脚步歇歇脚，有点冷热不均的意思，接下来该怎么走呢？平衡，生活与工作、休息与忙碌、亲情和还没来的爱情，2021年我要尝试去平衡这些，当前生命健康是第一。</p><p>过去决定现在，现在影响将来，2021我的生活会是不同以往的，预感会有很大的变化，且拭目以待。</p><p>2021伊始，感谢将出现在我生命里的可爱的人们。3q！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020年对于社会这个大环境来说是艰难的一年，对于我个人来说更是变动的一年，离开了从实习到如今四年的老东家，开始了一年的漂泊，到了年底还没有稳定下来，不过一年过来庆幸自己没有妥协，一直还在不断调整和思考。&lt;/p&gt;
&lt;p&gt;2020就这样写下了记号，工作上这一年是没有成果的，物
      
    
    </summary>
    
      <category term="年终总结" scheme="/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>View绘制</title>
    <link href="/2020/06/02/View%E7%BB%98%E5%88%B6/"/>
    <id>/2020/06/02/View绘制/</id>
    <published>2020-06-02T04:55:22.000Z</published>
    <updated>2020-12-29T13:29:10.206Z</updated>
    
    <content type="html"><![CDATA[<ul><li>View的绘制流程  </li></ul><p>View的绘制是从ViewRootImpl类的performTraversals方法开始经过measure、layout、draw三个过程将View绘制出来的，measure方法用来测量ViewGroup/View的宽高，layout用来确定View的最终宽高和在容器内的位置，draw绘制View到屏幕上。</p><p><img src="view_process.jpg" alt=""></p><p>performTraversals方法会依次调用perfomrMeasure，performLayout和performDraw，这三个方法依次调用底层View的绘制流程，也就是调用onMeasure、onLayout和onDraw，三个方法通过递归方式完成整个布局的绘制。  </p><ul><li>MeasureSpec<br>MeasureSpec可以理解为“测量规则”或“测量标准”。MeasureSpec用一个32位的int值来表示，高2位代表SpecMode（测量模式），低30位代表SpecSize（规格大小）。代码定义这样的：  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Measure specification mode: The parent has not imposed any constraint</span></span><br><span class="line"><span class="comment"> * on the child. It can be whatever size it wants.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Measure specification mode: The parent has determined an exact size</span></span><br><span class="line"><span class="comment"> * for the child. The child is going to be given those bounds regardless</span></span><br><span class="line"><span class="comment"> * of how big it wants to be.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Measure specification mode: The child can be as large as it wants up</span></span><br><span class="line"><span class="comment"> * to the specified size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(@IntRange(from = <span class="number">0</span>, to = (<span class="number">1</span> &lt;&lt; MeasureSpec.MODE_SHIFT)</span> - 1) <span class="keyword">int</span> size,</span></span><br><span class="line"><span class="function">                                  @MeasureSpecMode <span class="keyword">int</span> mode) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">        <span class="keyword">return</span> size + mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MeasureSpecMode</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//noinspection ResourceType</span></span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里可以看到MeasureSpec将SpecMode和SpecSize打包成一个int值，这样可以避免过多的内存分配，getMode和getSize方法利用MODE_MASK与操作来得到需要的mode和size值。<br>SpecMode有三种模式：  </p><ol><li>UNSPECIFIED：[ʌnˈspesɪfaɪd]未说明的，没有明确的。父容器对于View没有任何限制，想要多大就给多大。  </li><li>EXACTLY：[ɪɡˈzæktli] 明确的。它对应LayoutParams中的match_parent或指定大小值的两种场景。<em>父容器给出了一个确定的范围，如果view设置了具体值这个具体没有超出给定的范围那么就是这个具体值，如果超出了那view的大小就是父容器给定的限制值或者直接就指定限制值也就是match_parent的场景</em>  </li><li>AT_MOST:<em>view想要多大就是多大</em>，至到达到指定的值。对应LayoutParams中的wrap_content。 </li></ol><p>这三个值的设置是站在父容器的角度衡量view的，UNSPECIFIED是父容器没有对view做限制，EXACTLY是父容器给出了一个明确限制值（最大边界）来约束view，AT_MOST则是按照view的想要的来展示，但也有指定值来限定。</p><p><em>对于一个普通的View，它的MeasureSpec是由父容器的MeasureSpec和自身设置的LayoutParam参数来决定的，比如View设置了固定的宽或者高那么它在宽或者高方向上的SpecMode就是EXCATLY，无论它的父容器设置什么测量模式</em></p><p><em>View的绘制流程和activity的生命周期是不同步的，所以在onresume中直接获得view宽高是错误的，可以痛殴VIewTreeObser监听绘制过程或者通过View.post方法投递一个消息队列到尾部，等待looper调用该runnable时view已经初始化</em></p><p>postscript：getMeasureWidth和getWidth的区别</p>]]></content>
    
    <summary type="html">
    
      Android基础
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>View事件传递</title>
    <link href="/2020/06/01/View%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92/"/>
    <id>/2020/06/01/View事件传递/</id>
    <published>2020-06-01T03:52:08.000Z</published>
    <updated>2020-06-01T05:44:28.286Z</updated>
    
    <content type="html"><![CDATA[<ul><li>MotionEvent<br>MotionEvent是View的动作事件参数，包含集中常见的时间类型：  </li></ul><ol><li>ACTION_DOWN：手指刚接触到屏幕时；  </li><li>ACTION_MOVE：手指在屏幕上移动；  </li><li>ACTION_UP：手指从屏幕上离开的瞬间；<br>MotionEvent的两组位置方式：<br>getX()/getY()：表示动作相对于View左上角位置的x、y坐标；<br>getRawX()/getRawY()：表示动作相对于屏幕左上角位置的x、y坐标；  </li></ol><ul><li>事件分发<br><code>public boolean dispatchTouchEvent(MotionEvent event)</code><br>用于事件的分发，如果时间传递到了当前的View，那么该方法一定会被调用，boolean类型的返回值受View的onTouchEvent(MotionEvent event)和其子View的dispatchTouchEvent(MotionEvnet event)的影响，返回true表示消耗当前时间。<br><code>public boolean onInterceptTouchEvent(MotionEvent event)</code><br>用来判断是否拦截当前事件，返回结果表示是否拦截当前事件。<br><code>public boolean onTouchEvent(MotionEvent event)</code><br>在dispatchTouchEvent方法中被调用，用来处理touch事件，返回结果表示是否消耗当前事件。  </li></ul><p><img src="view_event_work.jpg" alt=""><br><img src="view_event_process.jpg" alt=""></p><p>说明：  </p><ol><li>一个事件序列表示手指从接触屏幕（ACTION_DOWN）经历一些列动作事件到手指刚离开屏幕（ACTION_UP）。  </li><li>某个View拦截事件，那么接下来的一个事件序列都有它来处理（时间能到到达的情况下），并且它的onIntercept不会再被调用。  </li><li>如果View再处理事件过程中，不再消耗ACTION_DOWN事件（onTouch返回false），那么事件序列的其他事件将会被其父元素进行消耗。  </li><li>ViewGroup默认不拦截事件。  </li><li>VIew没有onInterveptTouchEvent方法，View默认的onTouchEvent都会消耗事件（默认返回true）。  </li><li>事件传递是由外向内的，即事件总是先传递给父元素，然后通过父元素分发给子View，通过requestDisallowInterceptTouchEvnet方法来干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</li></ol>]]></content>
    
    <summary type="html">
    
      Android基础
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Android系统架构</title>
    <link href="/2020/05/31/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    <id>/2020/05/31/Android系统架构/</id>
    <published>2020-05-31T12:13:09.000Z</published>
    <updated>2020-05-31T13:29:00.323Z</updated>
    
    <content type="html"><![CDATA[<p>Android采用分层架构，从上到下分别为<em>应用程序层（apps、System apps）、应用程序框架层（Java API Framework）、系统运行库和运行环境层（Libraries+Android Runtime）和Linux核心层（HAL+Linux Kernel）</em>。</p><p><img src="android_framework.png" alt=""></p><ul><li><p>System apps<br>可以理解为内置的系统应用，可以像调用Java APIFramework一样区调用系统应用，例如我们调用日历区添加一个日常提醒。</p></li><li><p>Java ApI Framewor<br>android中常用的组件</p></li><li><p>Native c/c++ Libraries<br>本地库比Java API Framework更加偏低层，这里包含OpenGl、多媒体框架等内容。 </p></li><li><p>Android Runtime<br>Android运行时环境，也就是Android虚拟机。Android5.0之前是使用Dalvik虚拟机，<em>Dalvik虚拟机是基于JIT（Just in TIme）及时编译的引擎。Android5.0之后采用ART虚拟机，ART虚拟机是基于AOT（Ahead Of Time）作为编译引擎</em></p></li><li><p>Hardware Abstrction Layer<br>硬件抽象层主要是媒体、蓝牙、传感器的库模块。</p></li><li><p>Linux Kernel<br>Android平台的最底层，直接与硬件交互，负责硬件驱动、进程管理、内存管理、网络管理等功能。</p></li></ul><p><em>什么是JIT和AOT？</em><br>在Android中Java代码会被转换成DEX字节码文件，DEX字节码文件是Android虚拟机可以识别的，Android虚拟机把字节码在转化为机器能识别的机器码。<br>Dalvik虚拟机给予JIT编译，JIT也叫及时编译器，JIT工作原理是在应用运行时，首先将一部分DEX字节码转化为机器码，在程序执行的过程中再陆续将更多代码编译并缓冲，这样做的好处是内存占用少，但CPU再应用运行期间相对消耗大。<br>AOT叫做提前编译器，它是在应用的安装期间就将DEX字节码转化为了机器码，并将其存储在设备上。这样做的好处是在应用运行时占用CPu资源少一些，因为已经转化成了机器码，相对内存占用上多一些。</p>]]></content>
    
    <summary type="html">
    
      Android基础
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>图片加载如何避免OOM</title>
    <link href="/2020/05/30/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DOOM/"/>
    <id>/2020/05/30/图片加载如何避免OOM/</id>
    <published>2020-05-30T14:47:26.000Z</published>
    <updated>2020-05-30T15:19:51.691Z</updated>
    
    <content type="html"><![CDATA[<p>内存中Bitmap大小的计算公式：<br>长占用的像素 <em> 宽占用的像素 </em> 每个像素占用的内存<br>避免OOM也就是要减小图片在内存中的大小，有两种方式等比缩小长宽和减少每个像素占用的内存。</p><ul><li><p>等比缩小长宽：<br>Bitmap的创建是通过BitmapFactory的工厂方法decodeFile()、decodeStream()、decodeByteArray()、decodeResource()。这些方法在创建Bitmap使都一个参数Options，Options中的属性inSampleSize用来对图片进行长宽的设置，inSampleSize的值是2的幂次方，通过设置合适的值来对图片进行缩放操作。  </p></li><li><p>减少像素内存：<br>Options中的属性inPreferredConfig，通过调整这个值的属性来改变每个像素所占的内存，默认值是ARGB_8888,修改为RGB_565或ARGB_4444可以减少一半的内存。  </p></li></ul><table><thead><tr><th>值</th><th>含义  </th></tr></thead><tbody><tr><td>ARGB_8888</td><td>A(Alpha)、R(Red)、G(Green)、B(Blue)各占8位的精度，加起来32位的精度（即4个字节），也就是一个像素占4个字节的长度</td></tr><tr><td>ARGB_4444</td><td>A(Alpha)、R(Red)、G(Green)、B(Blue)各占4位的精度，加起来16位的精度（即2个字节），也就是一个像素占2个字节的长度</td></tr><tr><td>RGB_565</td><td>R(Red)占5位精度、G(Green)占6位精度、B(Blue)占5位精度，一共16位精度，也就是2个字节，不携带透明度信息</td></tr><tr><td>ALPHA_8</td><td>每个像素占位（即一个字节），只办函透明度值，不携带颜色信息</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      Android基础
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>IPC机制</title>
    <link href="/2020/05/29/IPC%E6%9C%BA%E5%88%B6/"/>
    <id>/2020/05/29/IPC机制/</id>
    <published>2020-05-29T12:33:15.000Z</published>
    <updated>2020-05-30T14:25:20.618Z</updated>
    
    <content type="html"><![CDATA[<ul><li>进程与线程<br><em>进程一般指一个执行的单元，也可以称作正在运行的程序实例</em>。<em>线程是CPU进行运算调度的最小单元</em>，它的系统资源是有限的，它是包含在进程之中。所以进程与线程是包含与被包含的关系。  </li><li><p>什么是IPC？<br>IPC全称Inter-Process Communication，即进程间通信。一般应用采用多进程有是为了使应用能够获取更多的内存空间。由于一个进程对应分配一个虚拟机，进程与虚拟机的一一对应，造成我们对同一个类的对象在不同进程中就产生了对个副本，例如有processOne和processTwo两个进程，它们都有一个类A.class，那么在两个进程中的A.class是互不干扰的。总结起来对进程会造成一下几个问题：<br><em>1. 静态成员和单例模式失效；</em><br><em>2. 线程同步机制生效；</em><br><em>3. SharedPreferences可靠性降低（进程并发写可能异常）</em><br><em>4. Application多次创建（可以理解成Application的创建和进程的创建是一致的）</em>  </p></li><li><p>Binder机制<br>Binder是android进程间通信的方式，Binder时基于C/S架构，主要有四部分组成：<br><em>1. Client（客户端进程）</em><br><em>2. Server（服务端进程）</em><br><em>3. ServiceManager（提供注册、查询和返回代理服务对象的功能）</em><br><em>4. Binder驱动（主要进程间的连接，进程间数据交互等基础底层操作）</em>      </p><p><em>服务器通过Binder驱动在ServiceManager中注册服务</em><br><em>客户端通过Binder驱动查询Servicemanager中注册的服务</em><br><em>SreviceManager通过Binder驱动返回服务器代理对象</em><br><em>客户端拿到服务器的代理对象后即可进行进程间的通信</em>  </p></li><li><p>IPC方式比较  </p></li></ul><table><thead><tr><th></th><th>优</th><th>缺</th><th>适用场景  </th></tr></thead><tbody><tr><td>Bundle</td><td>使用简单</td><td>传输Bundle支持的数据类型</td><td>四大组件间的数据传递 </td></tr><tr><td>文件共享</td><td>使用简单</td><td>不适合高并发，无法进行即时通信</td><td>用于实时性不高的场景  </td></tr><tr><td> AIDL</td><td>功能强大 支持一对多并发下的通信，支持实时</td><td>使用较复杂，需要做好线程同步问题</td><td>一对多通信且有RPC需求 </td></tr><tr><td> Messenger</td><td>功能一般，支持一对多串行通信，支持实时通信</td><td>不支持RPC、不能很好处理高并发、数据通过Message进行传输，只能传输Bundle支持的数据类型</td><td>低并发的一对多即时通信 </td></tr><tr><td>ContentProvider</td><td>在数据源访问上功能强大，支持一对多的并发数据共享，可通过call操作扩展其他操作</td><td>提供数据源的CRUD操作</td><td>进程一对多的数据共享  </td></tr><tr><td>     Socket</td><td>功能强大，支持网络传输数据流、支持一对多的实时通信</td><td>实现较繁琐</td><td>网络数据共享</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      Android基础
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化</title>
    <link href="/2020/05/27/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>/2020/05/27/Android性能优化/</id>
    <published>2020-05-27T05:01:02.000Z</published>
    <updated>2020-05-30T14:48:46.004Z</updated>
    
    <content type="html"><![CDATA[<p>Android的性能优化主要从四方面入手，内存优化、布局优化、网络优化和安装包优化。  </p><ul><li><p>常用检查工具<br><em>LeakCanary</em>是一个三方检测内存泄漏的工具库 ，集成后会自动检测应用运行期间的内存泄漏，并直观的输出。<br>Android自带的<em>Android Profiler</em> ，可以检测CPU、MEMERY、NETWORK三方的性能。<br><em>BlockCanary</em>是一个三方用来检测UI卡顿的工具库，像LeakCanary一样集成后当发生UI卡顿现象时会输出卡顿的信息，通过输出的信息可以很方便的来定位导致卡顿的原因。</p></li><li><p>内存优化<br>内存优化的方式时避免内存泄漏（节流）、增加内存（开源）。<br>常见的内存泄露：</p></li></ul><ol><li>单例导致的泄漏。在创建单例时传入了具体页面的Context，由于单例的静态属性，导致单例一致持有该Context引用，一直到应用程序结束。正确的做法是创建单例时应用传入应用级别的Context，也就是Application的Context，这样就保证了单例生命周期与传入Context的统一。  </li><li>静态变量导致的内存泄漏。JVM中可以知道静态变量是在方法区的，它的生命周期是从类加载到应用程序结束，如果静态变量中持有了具体页面的Context就会导致页面finish后Context不会被GC，这样就导致了内存泄露。  </li><li>非静态内部类导致的内存泄露。非静态内部类创建呢的Handle或Thread在执行延时操作时一直持有当前的Activity引用，这时候在Activity finish后就会导致内存泄漏。解决方式是使用静态内部类并用弱引用调用Activity；另外还可以在onDestroy中调用handler.removeCallbacksAndMessages取消所有事件消息。  </li><li>使用资源没有及时关闭。常见操作有：数据流操作完没有关闭、bitmap没及时Recycle等</li><li>三方的没及时接绑。EventBus（unregister）和Rxjava中（dispose）。  </li><li>动画执行导致的。在Activity finish时动画执行还在进行。解决就是在onDestroy时cacel动画。  </li><li>WebView导致的泄漏。 WebView即使调用了destroy也会导致内存泄漏。解决方式时使用弱引用WeekReference或者将WebView所在的Activity置于另外一个进程中。</li></ol><p>增加内存方案一般会在Application下添加largeHeap=”true”，活着新开进程来时应用的内存总空间增大。</p><ul><li>布局优化  16ms</li></ul><ol><li>使用RelativeLayout减少View层级</li><li>利用<include>抽离常用的布局</include></li><li>使用<viewstub>加载不常用的布局</viewstub></li><li>使用<merge>减少布局嵌套</merge></li><li>减少多余的背景绘制</li><li>canvas.clipRect()裁剪可见区域，其他区域就不会被多余绘制。</li></ol><ul><li>网络优化  </li></ul><ol><li>合理合并网络请求</li><li>网络缓存</li><li>大数据分页请求</li><li>网络数据传输压缩（Gzip）</li><li>图片压缩、缩略图</li></ol><ul><li>安装包优化<br>apk的构成：</li></ul><ol><li>assets文件夹：配置文件、资源文件 文件夹内的资源时通过AssetManager类内方法获取。  </li><li>res：资源文件，文件名会自动生成对应ID映射到.R文件中。  </li><li>META-INF：保存呢应用的签名信息，保证APK的完整性。  </li><li>AndroidManifest.xml：描述应用的配置信息。  </li><li>classes.dex：Dalvik虚拟机可执行的字节码文件，SDK下dx工具将JAVA字节码转化为Dalvik字节码。  </li><li>resources.arsc：资源文件和资源ID间的映射关系。  </li></ol><p>根据spk的构成做一下几方面的优化：  </p><ol><li>混淆：使用proGuard代码混淆工具，它包含了代码的压缩、优化、混淆等功能。  </li><li>资源优化：利用lint工具删除冗余代码，资源文件的最小化等。  </li><li>重复功能库：去除一些功能重复库的引用。  </li><li>插件化：功能模块放在服务器上，按需下载。<br>5.so库优化：保留v7版本，删除armeabi和v8版本的SO库，v7库可以按足市场上绝大多树手机的要求。</li></ol>]]></content>
    
    <summary type="html">
    
      Android基础
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Android动画分类</title>
    <link href="/2020/05/26/Android%E5%8A%A8%E7%94%BB%E5%88%86%E7%B1%BB/"/>
    <id>/2020/05/26/Android动画分类/</id>
    <published>2020-05-26T05:26:27.000Z</published>
    <updated>2020-05-26T07:04:55.073Z</updated>
    
    <content type="html"><![CDATA[<ul><li>帧动画<br>通过在xml中的一组图片的播放来实现。</li><li>补间动画<br>分为旋转、移动、缩放、透明度四类动画，以及他们的组合来实现动画效果。  </li><li><p>属性动画<br>属性动画目前使用场景最多，分类两种ViewPropertyAnimator和ObjectAnimator。前者是通用的动画，例如旋转、透明度、位移和缩放,简单通过View.animator()就可得到ViewPropertyAnimator。后者通过ObjectAnimator.of属性()来返回一个ObjectAnimator，ObjectAnimator需要重绘View所以要调用invalidate()来刷新绘制，最后通过start()方法启动动画。  </p></li><li><p>补间动画和属性动画的区别？</p></li></ul><p>补间动画只是在父VIew层利用Matrix不多绘制View，达到移动的效果，其实View并没有发生变化，还在动画之前的位置。<br>属性动画是真正改变了View的属性值，真正的改变View的具体属性值的。</p>]]></content>
    
    <summary type="html">
    
      Android基础
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>TCP和UDP</title>
    <link href="/2020/05/25/TCP%E5%92%8CUDP/"/>
    <id>/2020/05/25/TCP和UDP/</id>
    <published>2020-05-25T09:18:41.000Z</published>
    <updated>2020-05-25T14:35:50.210Z</updated>
    
    <content type="html"><![CDATA[<ul><li>TCP（（Transmission Control Protocol，传输控制协议））</li></ul><p>TCP协议是面向连接、可靠的字节流传输服务。TCP协议在C/S间数据交换前，需要先在上方建立一个TCP连接，之后才开始传输数据，并提供超时、重发、丢弃重复数据、数据校验和流量控制等功能。<br>特点：<em>面向连接、可靠通信、面向字节流</em><br>应用层协议：HTTP、HTTPS、SSH、FTP、SMTP</p><ul><li>UDP（User Data Protocol，用户数据报协议）</li></ul><p>UDP是一个面向数据报的传输层协议，不具有可靠性，只是把数据发出去，不保证数据是否能到达S端。因为UDP在传输数据前不需要建立一个连接，所以它的传输效率很快，不能保证数据的可靠。<br>特点：<em>无连接、不可靠、面向数据报</em><br>应用层协议：DHCP、DNS</p><ul><li>TCP协议建立连接的三次握手</li></ul><p><img src="tcp_create_connection.jpg" alt=""></p><p><em>第一次握手</em>（请求建立连接）C端发送建立连接请求，携带序列号seq=x 标示SYN=1，此时C端处于SYN_SEND状态；<br><em>第二次握手</em>（确认请求）S端收到后，发出确认信息，确认信息ACK=x+1，同时携带自己的序列号SYN=1，seq=y；<br><em>第三次握手</em>（建立连接）C端收到S端的确认请求后，向S端发送确认ACK=y+1，S端收到请求后两端都处于Established状态，表示当前的一次TCP连接成功。</p><ul><li>TCP断开连接的四次挥手</li></ul><p><img src="tcp_finish_connection.jpg" alt=""></p><p><em>第一次挥手</em>（请求释放）C端发送释放连接的请求信号FIN=1，seq=u，此时C端处于FIN WAIT状态,不再发送数据给S端；<br><em>第二次挥手</em>（确认请求）S端收到释放请求后，发送确认收到请求释放，ACK=1,ack=u+1,此时S度啊处于CLOSE EAIT状态，不再接收C端数据，但是需要发送给C端的数据可继续发送；<br><em>第三次挥手</em>（确认释放）当S端不再有数据需要发送给C端时，发送却是释放连接，携带FIN=1，seq=w，ACK=1，ack=u+1，此时S端处于LAST ACK状态，等待C端的最终确认；<br><em>第四次挥手</em>（最终释放确认）当C端收到了确认释放后，随即发送最终释放确认，ACK=1，ack=w+1，seq=u+1；此时C端在等待2MSL后关闭连接，S端收到请求后同样关闭。</p><ul><li><p>为什么需要三次握手？<br>如果是两次握手，服务端确认请求后，不知道客户端是否能收到了消息，服务端的消息得不到确认。(服务端消息等不到确认)<br>如果客户端发送的请求网络延迟了，超时后有客户端重新发起请求，倘若在重发请求正常进行完毕后，再收到之前网络拥塞的请求，再和服务端建立连接，这个时候就可能服务端一直等待，导致服务端连接资源浪费。  </p></li><li><p>为什么第三次握手是seq=x+1，而不是x+2？<br>从握手的规律可以看出来seq在确认请求中会变做确认表示即ack，ack会在seq值的基础上加1，<em>同时TCP规定，SYN不携带数据，但会消耗掉一个序列号，SYN=1时会消耗seq的一个值（即加1），第三次握手ACK=1、SYN不等于1，而ACK=1不消耗seq所以seq=x+1而不是x+2，挥手中FIN也和SYN一样</em></p></li><li><p>TCP建立连接后客户端出现故障会怎样？<br>服务端有个计数器，一般两小时，两小时如果没有收到任何数据，会发送探测报文段，发了几个报文段如果还是没反应，服务端就会关闭连接。</p></li></ul>]]></content>
    
    <summary type="html">
    
      计算机网络
    
    </summary>
    
      <category term="计算机网络" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP、HTTPS和HTTP2.0</title>
    <link href="/2020/05/23/HTTP%E3%80%81HTTPS%E5%92%8CHTTP2-0/"/>
    <id>/2020/05/23/HTTP、HTTPS和HTTP2-0/</id>
    <published>2020-05-23T10:14:51.000Z</published>
    <updated>2020-05-25T09:18:10.142Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="什么是http">* 什么是HTTP</span></h3><p>HTTP（HyperText Transfer Protocol）中文全名超文本传输协议，HTTP是用于客户端与服务器间请求响应的协议。HTTP是应用层的协议，和其他该层协议一样，它是服务于某一类具体应用的协议。</p><h3><span id="什么是httpshyper-text-transfer-protocol-over-securesocket-layer">* 什么是HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer）</span></h3><p>HTTPS是在HTTP的基础上加上了SSL/TLS层<br>TLS（Transport Layer Security，传输层安全协议）、SSL(Secure Sockets Layer 安全套接层)</p><p>SSL由NetScape公司设计，共有三个版本1、2、3。SSL 3.0得到大规模使用，而TLS是SSL标准化后的升级版</p><p>SSL/TLS握手阶段工作流程：  </p><p><img src="https.jpg" alt=""></p><ol><li><p>客户端向服务端发出加密通信请求(ClientHello)</p><blockquote><p>携带支持的协议，例如TLS 1.0版<br>客户端生成的随机数random1，后面用于生成“对话密钥”<br>支持的加密方法，比如RSA公钥加密<br>支持的压缩的方法  </p></blockquote></li><li><p>服务端收到请求，做出响应(ServerHello)</p><blockquote><p>确认加密通信协议，例如TLS 1.0版。如果协议与服务端支持的不一致，则关闭加密通信。<br>服务端生成一个随机数random2，后面用于生成“对话密钥”<br>确认加密方法，例如RSA公钥加密<br>携带服务端证书给客户端  </p></blockquote></li><li><p>客服端做证书验证和公钥对随机数加密发送给服务端(ClientResponse)</p><blockquote><p>验证证书的安全性<br>验证通过后，客户端生成随机数pre-master secret，然后使用证书中的公钥进行加密，发送给服务端  </p></blockquote></li><li><p>服务端私钥解密获得随机数(ServerResponse)</p><blockquote><p>服务端收到公钥加密的内容，在服务端使用私钥解密后得到pre-master secret，然后根据random1、random2和pre-master secret通过一定的算法得出对称加密的秘钥，作为后面交互过程中的对称密钥。同时客户端也使用random1、random2和pre-master secret，同样的算法生成对称密钥。  </p></blockquote></li><li>后续操作使用上一步生成的对称密钥对传输的内容加密和解密。</li></ol><p>如何保证公钥不被篡改？</p><blockquote><p>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p></blockquote><p>什么是对称加密？</p><blockquote><p>加密和解密用的都是相同的密钥，优点是速度快，缺点是安全性低，常见的对称加密DES、AES等</p></blockquote><p>什么是非对称加密？</p><blockquote><p>非对称加密由一对密钥对，分为公钥和私钥。一般私钥自己持有，公钥可以公开给对方，优点是安全性比对称密钥高，缺点是数据传输效率比对称密钥低。采用公钥加密的数据只能由对应的私钥来解密。常见的非对称加密算法RSA。</p></blockquote><p><em>HTTPS在传输过程中采用了对称加密和非对称加密结合使用，使用非对称加密传递密钥，然后使用对称密钥进行数据传输的加密和解密。二者的结合既保证了传输的安全性，也保证了数据传输的效率</em></p><h3><span id="http-20">* HTTP 2.0</span></h3><ol><li>（二进制格式）HTTP 2.0采用二进制格式传输，而HTTP1.x使用纯文本的形式传输数据</li><li>（Header压缩）HTTP 2.0对已经发送的Header使用键值对建立索引表（两端维护的索引表），相同的Header使用索引表示，即Header压缩。</li><li>（服务器推送）服务端可以进行主动推送  </li><li>（多路复用）一个TCP连接被划分为多个流，客户端借助流和服务端建立全双工通信，且流具有优先级。</li></ol>]]></content>
    
    <summary type="html">
    
      计算机网络
    
    </summary>
    
      <category term="计算机网络" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="/2020/05/22/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>/2020/05/22/HTTP状态码/</id>
    <published>2020-05-22T11:47:10.000Z</published>
    <updated>2020-05-22T12:47:04.911Z</updated>
    
    <content type="html"><![CDATA[<p>状态码分类：</p><table><thead><tr><th>码</th><th>类别</th><th>原因  </th></tr></thead><tbody><tr><td>1xx</td><td>Information（信息性状态码）</td><td>接受的请求正在处理 </td></tr><tr><td>2xx</td><td>Success（成功状态码）</td><td>请求正常处理完成 </td></tr><tr><td>3xx</td><td>Redirection</td><td>需要进行附加操作来完成请求 </td></tr><tr><td>4xx</td><td>Client Error（客户端错误）</td><td>客户端请求出错，服务端无法处理 </td></tr><tr><td>5xx</td><td>Server Error（服务端出错）</td><td>服务端处理请求出错</td></tr></tbody></table><ul><li>200 OK</li></ul><p>客户端发送给服务器的请求<em>正常处理并返回</em>。</p><ul><li>204 No Content</li></ul><p>客户端发送给服务端的请求被服务端成功处理，但是在返回的相应报文中没有实体内容（也就是没有资源返回）。 </p><ul><li>206 Patail Content</li></ul><p>客户端进行了<em>范围请求（响应报文中Content-Range制定了范围的实体）</em>，并且服务器成功执行了这部分的GET请求。</p><ul><li>301 Moved Permanly</li></ul><p><em>请求被永久性重定向</em>，表示请求的资源已经被分配到了新的URI，在今后的请求中使用那个新的URI。可以通过这个响应代码来防止由于URI变更而导致老URI失效。</p><ul><li>302 Found</li></ul><p><em>请求临时性重定向</em>，表示请求希望使用新的URI</p><ul><li>303 See Other</li></ul><p>当前的请求的响应在另外一个URI上被找到，并且客户端应当采用GET请求访问那个资源。</p><ul><li>304 Not Modified</li></ul><p>客户端发送了一个带条件（if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一）的GET请求且已被允许，而资源内容并未被修改过，则服务端返回该错误码。</p><ul><li>307 Temporary Redirect</li></ul><p>临时性重定向，与3030类似，但是这里会准照浏览器标准执行。</p><ul><li>400 Bad Request</li></ul><p><em>当前请求存在语法错误</em></p><ul><li>401 Unauthorized</li></ul><p>未经许可，请求身份验证。</p><ul><li>403 Forbidden</li></ul><p>服务器拒绝访问（访问权限出现问题）</p><ul><li>404 Not Found</li></ul><p><em>服务器找不到请求的资源。</em></p><ul><li>500 Inter Server Error</li></ul><p>服务器在执行请求是发生了错误。</p><ul><li>503 Server Unavailable</li></ul><p>服务不可用，服务器由于超载或停机维护，无法处理请求。</p>]]></content>
    
    <summary type="html">
    
      计算机网络
    
    </summary>
    
      <category term="计算机网络" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>OSI网络模型</title>
    <link href="/2020/05/22/OSI%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <id>/2020/05/22/OSI网络模型/</id>
    <published>2020-05-22T09:11:03.000Z</published>
    <updated>2020-05-22T11:35:02.983Z</updated>
    
    <content type="html"><![CDATA[<p><img src="osi.jpg" alt=""></p><p>OSI（Open System Interconnection）全称开放系统互联，它把网络通信的工作分为7层，包括应用层、表现层、会话层、传输层、网络层、数据链路层和物理层。传输层、网络层、数据链路层和物理层叫做低四层，这四层和数据的移动相关。应用层、表现层和会话层叫做高三层，包含了应用程序级别的数据，每一层负责具体的一项工作将数据想向下一层传送。</p><ul><li>应用层</li></ul><p>应用层就是为了满足应用进程间的通信和交互任务。该层的协议有HTTP、HTTPS、FTP、POP3、SMTP等</p><ul><li>表现层</li></ul><p>表现层提供数据的编码和转换功能。数据的压缩和解压缩，加密和解密等工作都是在表现层完成。</p><ul><li>会话层</li></ul><p>会话层提供访问验证和会话管理在内的建立和维护应用间通信的机制，例如服务器验证用户登陆便由会话层完成。</p><ul><li>传输层</li></ul><p>传输层主要负责建立端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务。<em>端口号即是这里的端，TCP和UDP就是这层的协议</em></p><ul><li>网络层</li></ul><p>网络层的任务是选择合适的网间路由和交换结点，确保数据及时传送。</p><ul><li>数据链路层</li></ul><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测（也就是帧编码和误差纠错的功能）。数据链路层协议又分为两个子层：逻辑链路控制（LLC）和媒体访问控制（MAC）。</p><ul><li>物理层</li></ul><p>信号的最终传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>]]></content>
    
    <summary type="html">
    
      计算机网络
    
    </summary>
    
      <category term="计算机网络" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList和LinkedList</title>
    <link href="/2020/05/21/ArrayList%E5%92%8CLinkedList/"/>
    <id>/2020/05/21/ArrayList和LinkedList/</id>
    <published>2020-05-21T06:16:27.000Z</published>
    <updated>2020-05-21T12:08:07.746Z</updated>
    
    <content type="html"><![CDATA[<ul><li>源码分析</li></ul><ol><li>ArrayList  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">     * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure><p>ArrayList内部实现元素是放在elementData的数组中的，并且默认数组是空的，当增加元素时才扩展到DEFAULT_CAPACITY，这里DEFAULT_CAPACITY的值时10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">     *         is negative</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ArrayList的构造函数有三个，一个无参的设置空数组，有参的一个传入容量初始化数组，另外一个通过Collection对象对数组初始化赋值。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment">     * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment">     * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum size of array to allocate.</span></span><br><span class="line"><span class="comment">     * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment">     * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment">     * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">     * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>add方法中主要的调用是ensureCapacityInternal方法，ensureCapacityInternal方法主要做了一个扩容的处理，这里容器的最小值被赋予了DEFAULT_CAPACITY，也就是10，扩容的处理在grow方法中完成，这里看到新容量的大小等于老容量加上老容量的一半，也就是新容量在老容量的基础上再增加它的一半。后面对数组进行重新创建和赋值。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">     * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment">     * indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the element that was removed from the list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment">     * if it is present.  If the list does not contain the element, it is</span></span><br><span class="line"><span class="comment">     * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span></span><br><span class="line"><span class="comment">     * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment">     * changed as a result of the call).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>remove方法比较简单入参是索引的通过索引找到数组中的元素，通过本地方法System.arraycopy将index+1的元素赋值到索引从index到size-1，这里就相当于对index后面的元素进行了向前移位的操作。<br>如果入参是元素o就通过遍历找到它的索引然后再根据它的索引进行remove。  </p><p><em>这里modCount变量是一个叫做fail-fast的机制，就是当我们对ArrayList元素进行一些操作时，若果又有其他线程对其内容进行修改时，可以第一时间通过modCount的值来判定，当再操作中modCount值不一值就抛出ConcurrentModificationException，也表明ArrayList是线程不安全的</em></p><p>这里get方法就不再赘余，因为ArrayList这里时数组，可以通过下标方便的查找，ArrayList实现RandomAccess接口，作为一种标示说明它的访问时随机的</p><ol start="2"><li>LinkedList  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Pointer to first node.</span></span><br><span class="line"><span class="comment">    * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">    *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Pointer to last node.</span></span><br><span class="line"><span class="comment">    * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">    *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedList的内部实现使用双向链表来存储元素的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends all of the elements in the specified collection to the end of</span></span><br><span class="line"><span class="comment"> * this list, in the order that they are returned by the specified</span></span><br><span class="line"><span class="comment"> * collection's iterator.  The behavior of this operation is undefined if</span></span><br><span class="line"><span class="comment"> * the specified collection is modified while the operation is in</span></span><br><span class="line"><span class="comment"> * progress.  (Note that this will occur if the specified collection is</span></span><br><span class="line"><span class="comment"> * this list, and it's nonempty.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts all of the elements in the specified collection into this</span></span><br><span class="line"><span class="comment"> * list, starting at the specified position.  Shifts the element</span></span><br><span class="line"><span class="comment"> * currently at that position (if any) and any subsequent elements to</span></span><br><span class="line"><span class="comment"> * the right (increases their indices).  The new elements will appear</span></span><br><span class="line"><span class="comment"> * in the list in the order that they are returned by the</span></span><br><span class="line"><span class="comment"> * specified collection's iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which to insert the first element</span></span><br><span class="line"><span class="comment"> *              from the specified collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数有两个，有参的Collection元素集构造函数中调用addAll方法，addAll方法中通过遍历增加链表元素。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Links e as last element.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">       last = newNode;</span><br><span class="line">       <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">           first = newNode;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           l.next = newNode;</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>add方法中主要调用linkLast方法，新建新增的Node元素，Node元素prev变量之前当前的last，next为null，然后找last.next指向newNode。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.  Shifts any</span></span><br><span class="line"><span class="comment"> * subsequent elements to the left (subtracts one from their indices).</span></span><br><span class="line"><span class="comment"> * Returns the element that was removed from the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unlinks non-null node x.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>remove主要通过两个方法实现，node方法通过index找到对应的Node元素，然后通过unlink方法链表重新链接，将x元素从链表中移除并置为null，以便GC回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法直接通过node方法遍历等到Node元素，然后Node.item拿到元素值。</p><ol start="3"><li>两者对比  </li></ol><h5><span id="1-arraylist内部是通过动态数组结构实现空间利用相对有损耗linkedlist内部是通过双向链表实现空间利用上不存在浪费因为元素的多少和链表长度是一致的">1    .ArrayList内部是通过动态数组结构实现，空间利用相对有损耗；LinkedList内部是通过双向链表实现，空间利用上不存在浪费，因为元素的多少和链表长度是一致的。</span></h5><h5><span id="2-arraylist因为是数组实现所以删除-插入操作相对较慢通过systemarraycopy本地方法完成存在元素移动但是它的查找操作可随机访问实现radomaccess接口linkedlist链表在删除-插入效率高不存在元素移动只需要改变目标元素的前驱和后继就可以实现">2. ArrayList因为是数组实现，所以删除、插入操作相对较慢（通过System.arraycopy本地方法完成，存在元素移动），但是它的查找操作可随机访问（实现RadomAccess接口）；LinkedList链表在删除、插入效率高，不存在元素移动，只需要改变目标元素的前驱和后继就可以实现。</span></h5>]]></content>
    
    <summary type="html">
    
      JAVA基础
    
    </summary>
    
      <category term="JAVA基础" scheme="/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础" scheme="/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java引用类型</title>
    <link href="/2020/05/19/java%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>/2020/05/19/java引用类型/</id>
    <published>2020-05-19T10:02:08.000Z</published>
    <updated>2020-05-19T10:44:58.306Z</updated>
    
    <content type="html"><![CDATA[<p>java引用类型分为四类：强引用、软引用、弱引用和虚引用。<br>强引用：就是我们最常用的直接new对象创建的引用，垃圾回收器将永远不会回收被引用的对象。内存不足的情况JVM会直接抛出OOM。<br>软引用（SoftReference）：软引用在内存不足的情况下会被垃圾回收器回收。软引用常被用在存储一些内存敏感的缓冲，例如网页缓冲、图片缓冲等。<br>弱引用（WeekReference）：弱引用的强度比软引用更弱一下，无论内存是否足够，只要当GC开始，被扫描到的弱引用的对象就会被回收。<br>虚引用（PhantomReference）：虚引用是最弱的一种引用关系。它随时可能被回收，并且对象是无法通过虚引用获取的。虚引用主要用来跟踪对象被GC回收的活动，当被虚引用修饰的对象在被回收时，JVM会把虚引用加入到与之关联的引用队列（ReferrenceQueue）中。</p>]]></content>
    
    <summary type="html">
    
      JAVA基础
    
    </summary>
    
      <category term="JAVA基础" scheme="/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础" scheme="/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="/2020/05/19/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>/2020/05/19/单例模式/</id>
    <published>2020-05-19T04:37:45.000Z</published>
    <updated>2020-05-19T05:35:15.924Z</updated>
    
    <content type="html"><![CDATA[<ul><li>懒汉式</li></ul><p>懒汉式是在调用时创建实例，用时间来换空间。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleTon instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(LazySingleTon.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重判断保证了原子性和可见性（synchronized），同时利用volatile来保证有序性，避免指令的重排。  </p><ul><li>饿汉式  </li></ul><p>饿汉式在类加载的时候就已经创建好对象，在使用时直接就可以拿到实例，标准的空间换时间。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon instance = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态内部类实现  </li></ul><p>当外部类加载时不会导致内部类的立即加载，只有当getInstance方法被调用时才会去加载内部类，实现了加载。因为类的加载只会加载一次，所以它时线程安全的。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticInnerSingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticInnerSingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTonHolde</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerSingleTon instance = <span class="keyword">new</span> StaticInnerSingleTon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerSingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleTonHolde.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举实现  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ESingleTon &#123;</span><br><span class="line">     single;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperate</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"singletonOperate"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      设计模式
    
    </summary>
    
      <category term="设计模式" scheme="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>final、finally和finalize</title>
    <link href="/2020/05/19/final%E3%80%81finally%E5%92%8Cfinalize/"/>
    <id>/2020/05/19/final、finally和finalize/</id>
    <published>2020-05-19T03:59:33.000Z</published>
    <updated>2020-05-19T04:07:24.104Z</updated>
    
    <content type="html"><![CDATA[<ul><li>final可以修饰类、方法和变量。修饰类代表这个类不可被继承。修饰方法表示该方法不可被重写。修饰变量表示该变量在赋值后不可改变。  </li><li>finally保证重点代码一定会被执行的一种机制。通常使用组合try-catch-finally。  </li><li>finalize是Object类的一个方法，当垃圾回收器将要回收对象所占内存之前被调用，这个方法来用保证来对象被回收前完成特定的资源回收。</li></ul>]]></content>
    
    <summary type="html">
    
      JAVA基础
    
    </summary>
    
      <category term="JAVA基础" scheme="/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础" scheme="/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
