<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>litchi</title>
  
  <subtitle>litchi blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-04-26T13:43:44.011Z</updated>
  <id>/</id>
  
  <author>
    <name>litchi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>类加载子系统</title>
    <link href="/2020/04/26/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>/2020/04/26/类加载子系统/</id>
    <published>2020-04-26T11:16:43.000Z</published>
    <updated>2020-04-26T13:43:44.011Z</updated>
    
    <content type="html"><![CDATA[<p><img src="classloader.jpg" alt=""></p><h3><span id="类加载过程包括加载load-链接linking和初始化init">类加载过程包括加载（load）、链接（linking）和初始化（init）</span></h3><ul><li>加载<br><strong><em>将字节码文件从数据源中加载到JVM内存中，生成JVM的认可的数据结构（也就是Class对象）</em></strong>，数据源可以是来自物理硬盘或者网络的jar文件、war文件、class文件等一些JVM可识别的文件格式结构（文件格式异常回报ClassFormatError）。  </li><li>链接<br>链接是类加载的核心部分，分三个步骤：验证、准备和解析<br>1.验证（Verify）：保证字节流信息符合JVM规范，避免恶意数据危害JVM的安全运行（异常抛出VerifyError）。<br>2.准备（Prepare）：为类变量分配内存和为变量设置初始值。<br>3.解析（Resolve）：将符号应用转换为直接应用，符号应用就是一组符号来描述所应用的目标，直接应用就是直接指向目标的指针或句柄。  </li><li>初始化<br>初始化主要是将静态变量赋值和执行静态代码块的一系列操作。</li></ul><h3><span id="双亲委派机制">双亲委派机制</span></h3><p><img src="parents_delegate.jpg" alt=""></p><p>双亲委派机制是在类加载过程中加载部分里的机制，加载器大致有启动类加载器Bootstrap ClassLoader（加载核心的类）、扩展类加载器Extension ClassLoader（ext path下的类）和应用类加载器Application ClassLoader（自定义）。<br>在执行类加载请求时，子加载器会先委托父类加载器执行；如果父类加载器还存在父类加载器就继续委托，一次递归找到其顶部启动类加载器；如果启动类加载器可以完成任务则将结果返回，倘若启动类加载器不能完成任务这时一次再让子类加载器尝试加载，这个过程叫双亲委派机制。</p><h3><span id="双亲委派机制优点">双亲委派机制优点</span></h3><p>1.避免类重复加载<br>2.保护程序安全，防止核心API被篡改（java.lang.String）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;classloader.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span id=&quot;类加载过程包括加载load-链接linking和初始化init&quot;&gt;类加载过程包括加载（load）、链接（linking）和初始化（init）&lt;/span&gt;&lt;/h3&gt;&lt;u
      
    
    </summary>
    
    
      <category term="JVM" scheme="/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>查找算法</title>
    <link href="/2020/04/21/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>/2020/04/21/查找算法/</id>
    <published>2020-04-21T07:00:09.000Z</published>
    <updated>2020-04-21T07:05:50.788Z</updated>
    
    <content type="html"><![CDATA[<ul><li>插值查找</li><li>黄金分割法</li><li>线性索引查找</li><li>二叉排序树</li><li>平衡二叉树</li><li>B树</li><li>散列表（哈希表）查找<br>*</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;插值查找&lt;/li&gt;
&lt;li&gt;黄金分割法&lt;/li&gt;
&lt;li&gt;线性索引查找&lt;/li&gt;
&lt;li&gt;二叉排序树&lt;/li&gt;
&lt;li&gt;平衡二叉树&lt;/li&gt;
&lt;li&gt;B树&lt;/li&gt;
&lt;li&gt;散列表（哈希表）查找&lt;br&gt;*&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="/2020/04/17/%E5%9B%BE/"/>
    <id>/2020/04/17/图/</id>
    <published>2020-04-17T07:10:34.000Z</published>
    <updated>2020-04-21T06:54:37.309Z</updated>
    
    <content type="html"><![CDATA[<ul><li>图的特点：<br>1.通常用V(Vertex)表示一组定点的集合；<br>2.通常用E(Edge)表示一组边的集合。</li><li>顶点：<br>图中的一个结点</li><li>图的边：<br>顶点和顶点间的连线，有向图中的边叫做弧</li><li>相邻顶点：<br>由一条边连接在一起的顶点</li><li>顶点的度：<br>相邻顶点的数量叫做顶点的度</li><li>连通图：<br>在无向图中，若任意两个顶点Vi与Vj都有路径相通，则称该无向图为连通图</li><li>强连通图：<br>在有向图中，若任意两个顶点Vi与Vj都有路径相通，则称该有向图为强连通图</li><li>连通网：<br>在连通图中，若图的边具有一定的意义，每一条边都有一个对应数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网</li><li>生成树：<br>一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则会形成环</li><li><p>图的深度优先遍历：<br>假设初始状态是图中所有顶点都未被访问，从图中某个顶点v出发，先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到；若此时还有剩余顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p></li><li><p>图的广度优先遍历：<br>假设从图中某个顶点v出发，在访问了顶点v之后依次访问顶点v的各个未曾访问过的邻接顶点，然后分别从这些邻接顶点再出发依次访问它们的邻接顶点，并使“先被访问的顶点的邻接顶点”先于“后被访问的顶点的邻接顶点”被访问，直到图中所有已被访问的顶点的邻接点都被访问到；若此时图中还有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p></li><li><p>最小生成树：<br>在连通网的所有生成树中，所有边的代价总和最小的生成树，称为最小生成树</p></li></ul><p>1.普里姆算法(Prim算法)：</p><p>描述：<br>1.定义一个加权连通图，其中顶点集合V、Vnew，Vnew是V的子集，边的集合E、Enew，Enew是E的子集；<br>2.初始化集合Vnew{x},x(起始点)是集合V中任意一结点，Enew{}；<br>3.从边的集合E中选取权值最小的边&lt;u, v&gt;(其中u是顶点集合Vnew的元素，v属于顶点集合V，而不在新顶点集合Vnew中。若权值相同时，任意取值)；<br>4.将v加入新顶点集合Vnew，将边&lt;u, v&gt;加入新边集合Enew中；<br>5.重复操作3和4步骤 ，知道Vnew=V时，输出集合Vnew和Enew，Vnew和Enew即是来描述该加权连通图的最小生成树。<br>代码实现： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"> static class GraphMatrix &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 边的数量</span><br><span class="line">         */</span><br><span class="line">        private int edgeNum;</span><br><span class="line">        /**</span><br><span class="line">         * 顶点集合</span><br><span class="line">         */</span><br><span class="line">        private char[] vertex;</span><br><span class="line">        /**</span><br><span class="line">         * 邻接矩阵</span><br><span class="line">         */</span><br><span class="line">        private int[][] matrix;</span><br><span class="line"></span><br><span class="line">        public GraphMatrix(char[] vertex, int[][] matrix) &#123;</span><br><span class="line">            this.vertex = vertex;</span><br><span class="line">            this.matrix = matrix;</span><br><span class="line">            getEdgeNum();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void getEdgeNum() &#123;</span><br><span class="line">            int length = vertex.length;</span><br><span class="line">            for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">                for (int j = i + 1; j &lt; length; j++) &#123;</span><br><span class="line">                    //矩阵值等于Integer.MAX_VALUE表示不相邻，等于0是自己到自己</span><br><span class="line">                    if (matrix[i][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                        edgeNum++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * print matrix</span><br><span class="line">         */</span><br><span class="line">        private void printMatrix() &#123;</span><br><span class="line">            System.out.println(&quot;矩阵:&quot;);</span><br><span class="line">            for (int[] m : matrix) &#123;</span><br><span class="line">                for (int c : m) &#123;</span><br><span class="line">                    System.out.print(c + &quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 获取字符在结点里的位置</span><br><span class="line">         *</span><br><span class="line">         * @param c 字符</span><br><span class="line">         * @return 返回-1没该字符，其他位置</span><br><span class="line">         */</span><br><span class="line">        private int getVertexPosition(char c) &#123;</span><br><span class="line">            for (int i = 0; i &lt; vertex.length; i++) &#123;</span><br><span class="line">                if (c == vertex[i]) &#123;</span><br><span class="line">                    return i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 输入开始顶点位置</span><br><span class="line">         *</span><br><span class="line">         * @param x 开始顶点位置</span><br><span class="line">         */</span><br><span class="line">        public void prime(int x) &#123;</span><br><span class="line">            int num = vertex.length;</span><br><span class="line">            //邻边权重</span><br><span class="line">            int[] weights = new int[num];</span><br><span class="line">            //prime最小生成树结果</span><br><span class="line">            char[] result = new char[num];</span><br><span class="line">            //result当前索引</span><br><span class="line">            int index = 0;</span><br><span class="line"></span><br><span class="line">            //复制第一个顶点值</span><br><span class="line">            result[index] = vertex[x];</span><br><span class="line">            index++;</span><br><span class="line"></span><br><span class="line">            //init weight 找到顶点相邻边的权重赋值weights[i]</span><br><span class="line">            for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">                weights[i] = matrix[x][i];</span><br><span class="line">            &#125;</span><br><span class="line">            weights[x] = 0;</span><br><span class="line"></span><br><span class="line">            //循环遍历娶到最短权重值添加到result中</span><br><span class="line">            for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">                if (x == i) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                int minWeight = Integer.MAX_VALUE;</span><br><span class="line">                int minWeightIndex = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                for (int j = 0; j &lt; num; j++) &#123;</span><br><span class="line">                    if (weights[j] != 0 &amp;&amp; weights[j] &lt; minWeight) &#123;</span><br><span class="line">                        minWeight = weights[j];</span><br><span class="line">                        minWeightIndex = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //保存最短权重顶点</span><br><span class="line">                result[index] = vertex[minWeightIndex];</span><br><span class="line">                index++;</span><br><span class="line">                weights[minWeightIndex] = 0;</span><br><span class="line"></span><br><span class="line">                for (int j = 0; j &lt; num; j++) &#123;</span><br><span class="line">                    if (weights[j] != 0 &amp;&amp; matrix[minWeightIndex][j] &lt; weights[j]) &#123;</span><br><span class="line">                        weights[j] = matrix[minWeightIndex][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //计算最小生成树的权重</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int i = 1; i &lt; index; i++) &#123;</span><br><span class="line">                int min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">                int n = getVertexPosition(result[i]);</span><br><span class="line">                //求当前节点到上面其他节点的最小值</span><br><span class="line">                for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                    int m = getVertexPosition(result[j]);</span><br><span class="line">                    if (matrix[m][n] &lt; min) &#123;</span><br><span class="line">                        min = matrix[m][n];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                sum += min;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //打印最小生成树</span><br><span class="line">            System.out.printf(&quot;PRIME(%c):&quot;, vertex[x]);</span><br><span class="line">            for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">                System.out.printf(&quot;%c &quot;, result[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.printf(&quot;权重：%d&quot;, sum);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">2.克鲁斯卡尔算法(Kruskal算法)：</span><br><span class="line"></span><br><span class="line">描述：  </span><br><span class="line">首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。  </span><br><span class="line">代码实现：</span><br></pre></td></tr></table></figure><p> /**</p><pre><code> * 克鲁斯卡尔算法 */public void Kruskal() {    //结果数组的当前索引    int index = 0;    //输出的结果数组    Edge[] results = new Edge[edgeNum];    //保存某个顶点在该最小生成树的终点    int[] vends = new int[edgeNum];    //获取图中所有的边    Edge[] edges = getEdges();    //将边按权重从小到大排序    sortEdges(edges);    for (int i = 0; i &lt; edgeNum; i++) {        int p1 = getVertexPosition(edges[i].start);        int p2 = getVertexPosition(edges[i].end);        int m = getEdgesEnd(vends, p1);        int n = getEdgesEnd(vends, p2);        if (m != n) {//表示没有形成闭环            vends[m] = n;            results[index++] = edges[i];        }    }    //统计并打印最小生成树的信息    int length = 0;    for (int i = 0; i &lt; index; i++) {        length += results[i].weight;    }    System.out.println(&quot;Kruskal：&quot;);    for (int i = 0; i &lt; index; i++) {        System.out.printf(&quot;(%c,%c) &quot;, results[i].start, results[i].end);    }    System.out.println();    System.out.println(&quot;Kruskal的权重：&quot; + length);}//连通图的边结构private static class Edge {    char start;//边的起点    char end;//边的终点    int weight;//边的权重    public Edge(char start, char end, int weight) {        this.start = start;        this.end = end;        this.weight = weight;    }}/** * 获取图中的边 */private Edge[] getEdges() {    int index = 0;    Edge[] edges = new Edge[edgeNum];    for (int i = 0; i &lt; vertex.length; i++) {        for (int j = i + 1; j &lt; vertex.length; j++) {            if (matrix[i][j] != Integer.MAX_VALUE) {                edges[index++] = new Edge(vertex[i], vertex[j], matrix[i][j]);            }        }    }    return edges;}/** * 根据权重从小到大排序 * * @param edges edges */private void sortEdges(Edge[] edges) {    Edge tmp;    for (int i = 0; i &lt; edges.length; i++) {        for (int j = (i + 1); j &lt; edges.length; j++) {            if (edges[i].weight &gt; edges[j].weight) {//若大于则交换位置                tmp = edges[i];                edges[i] = edges[j];                edges[j] = tmp;            }        }    }}/** * 取终点 */private int getEdgesEnd(int[] vends, int i) {    //若C-&gt;D,D-&gt;F则取F的值    while (vends[i] != 0) {        i = vends[i];    }    return i;}</code></pre><p><code>`</code></p><ul><li>最短路径：</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;图的特点：&lt;br&gt;1.通常用V(Vertex)表示一组定点的集合；&lt;br&gt;2.通常用E(Edge)表示一组边的集合。&lt;/li&gt;
&lt;li&gt;顶点：&lt;br&gt;图中的一个结点&lt;/li&gt;
&lt;li&gt;图的边：&lt;br&gt;顶点和顶点间的连线，有向图中的边叫做弧&lt;/li&gt;
&lt;li&gt;相邻
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="/2020/04/14/%E6%A0%91/"/>
    <id>/2020/04/14/树/</id>
    <published>2020-04-14T14:12:59.000Z</published>
    <updated>2020-04-16T12:51:44.691Z</updated>
    
    <content type="html"><![CDATA[<p>树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。</p><p><img src="tree.jpg" alt=""></p><ul><li>特点：</li></ul><p>1.在非空树中，根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点；<br>2.子树的个数没有限制，但它们互不相交；</p><ul><li>度：</li></ul><p>结点的度：结点拥有的子树个数叫做结点的度，结点A的度是3，C的度是2，H的度是1。<br>树的度：树中最大的结点度。图中树的度是3</p><ul><li>结点的关系</li></ul><p>1.结点子树的根结点称为该结点的 <strong>孩子结点</strong>，该结点叫做孩子结点的<strong>双亲结点</strong>。图中E是B的孩子结点，B是E的双亲结点；<br>2.同一双亲的结点叫做<strong>兄弟结点</strong>，图中的F、G是E的兄弟结点；<br>3.同一层的结点叫做<strong>堂兄结点</strong>，通中的H、I、J、K、L是E的堂兄结点；<br>4.从根到该结点经过的左右分支结点叫做该结点的祖先结点，图中M的祖先结点有A、B、E。<br>5.该结点的子树任意一个结点都称为该结点的子孙结点，E的子孙结点有M和N。</p><ul><li>结点的层次</li></ul><p>从根开始定义，根为第一层，根的孩子为第二层，根的孩子的孩子为第三层…。<br>树的深度：树中结点的最大层次数称为树的深度或高度，图中深度为4</p><h4><span id="二叉树">二叉树</span></h4><p>二叉树(Binary Tree)是n(n&gt;=0)个结点的有限集合，该集合或者为空集(空二叉树)，或者由一个跟结点和两个互补相交的、分别称为根的结点在左子树和右子树组成。每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。</p><p><img src="binary_tree.jpg" alt=""></p><ul><li>二叉树的特点</li></ul><p>1.每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点；<br>2.左子树和右子树是有顺序的，次序不能任意颠倒；<br>3.即使树中某结点只有一棵子树，也要区分它是左子树还是右子树；</p><ul><li>二叉树的性质</li></ul><p>1.在二叉树中第i层上最多有2的i-1次方个结点(i&gt;=1)；<br>2.二叉树中如果深度为k,那么最多有2k-1个节点(k&gt;=1）；</p><ul><li>斜树</li></ul><p>所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p><p><img src="xie_binary_tree.jpg" alt=""></p><ul><li>满二叉树<br>在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。<br>满二叉树的特点有：<br>1.叶子只能出现在最下一层。出现在其它层就不可能达成平衡。<br>2.非叶子结点的度一定是2。<br>3.在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li></ul><p><img src="man_binary_tree.jpg" alt=""></p><ul><li>完全二叉树<br>若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。<br>完全二叉树的特点：<br>1.叶子结点只出现在最下层和次下层；<br>2.最下层叶子结点集中在树的左部；<br>3.如果结点度为1，则该结点只有左孩子，即没有右子树；<br>4.相同结点数的二叉树，完全二叉树的深度最小；<br>5.满二叉树一定是完全二叉树，但反过来不一定成立。</li></ul><p><img src="wanquan_binary_tree.jpg" alt=""></p><ul><li>二叉树存储结构</li></ul><p>1.*** 顺序存储结构<br>二叉树的顺序存储结构就是使用一维数组存储二叉树中的结点，并且结点的存储位置，就是数组的下标索引。</p><p><img src="order_storage.jpg" alt=""></p><p>如果索引下为空表示该位置下没有存储结点。</p><p>2.*** 链式存储结构 </p><p>结构定义  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class BinaryNode&lt;E&gt; &#123;</span><br><span class="line">    //数据</span><br><span class="line">    E data;</span><br><span class="line">    //左子树</span><br><span class="line">    BinaryNode leftChild;</span><br><span class="line">    //右子树</span><br><span class="line">    BinaryNode rightChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二叉树的遍历</li></ul><p>1.前序遍历(DLR)<br>首先访问根，再先序遍历左（右）子树，最后先序遍历右（左）子树<br>图中结果：ABDECFG</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 前序遍历</span><br><span class="line">     *</span><br><span class="line">     * @param root 根</span><br><span class="line">     */</span><br><span class="line">    public void DLR(BinaryNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //TODO do something</span><br><span class="line"></span><br><span class="line">        if (root.leftChild != null) &#123;</span><br><span class="line">            DLR(root.leftChild);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.rightChild != null) &#123;</span><br><span class="line">            DLR(root.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2.中序遍历(LDR)<br>首先中序遍历左（右）子树，再访问根，最后中序遍历右（左）子树。<br>图中结果：DBEAFCG</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 中序遍历</span><br><span class="line">     *</span><br><span class="line">     * @param root 根</span><br><span class="line">     */</span><br><span class="line">    public void LDR(BinaryNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.leftChild != null) &#123;</span><br><span class="line">            LDR(root.leftChild);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //TODO do something</span><br><span class="line"></span><br><span class="line">        if (root.rightChild != null) &#123;</span><br><span class="line">            LDR(root.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3.后序遍历(LRD)<br>首先后序遍历左（右）子树，再后序遍历右（左）子树，最后访问根<br>图中结果：DEBFGA</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 后序遍历</span><br><span class="line">     *</span><br><span class="line">     * @param root 根</span><br><span class="line">     */</span><br><span class="line">    public void LRD(BinaryNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.leftChild != null) &#123;</span><br><span class="line">            LRD(root.leftChild);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.rightChild != null) &#123;</span><br><span class="line">            LRD(root.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //TODO do something</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4.层序遍历<br>按照层次访问，通常用队列来做。访问根，访问子女，再访问子女的子女</p><ul><li>线索二叉树</li></ul><p>二叉树线索化的过程中，会把树中的空指针利用起来作为寻找当前节点前驱和后继的线索，这样就出现了一个问题，即线索和数中原有指向孩子节点的指针无法区分。上边的这种节点设计就是为了区分这两类指针。其中，ltag和rtag为标识域，它们的具体意义如下:<br>1.如果ltag==0，表示lchild为指针，指向结点的左子树；<br>2.如果ltag==1，表示lchild为线索，指向结点的直接前驱;<br>3.如果rtag==0，表示rchild为指针，指向结点的右子树；<br>4.如果rtag==1，表示rchild为线索，指向结点的直接后继。</p><ul><li>哈夫曼树</li></ul><p>当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。</p><p><img src="huffman_tree.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;tree.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特点：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.在非空树中，根结点是唯一的，不可能存在多个根结点，数据结构中的树
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配算法</title>
    <link href="/2020/04/14/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    <id>/2020/04/14/字符串匹配算法/</id>
    <published>2020-04-14T06:49:35.000Z</published>
    <updated>2020-04-14T14:10:29.663Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="bf算法">BF算法</span></h3><p>首先原串与字串左端对齐，，如果第一个字符不匹配，字串向后移动逐一移动，当发现死一个第一个字符匹配后，当前位置下比较剩余字串的字符与原串是否匹配，直到全部匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对齐:</span><br><span class="line">litchicoder</span><br><span class="line">coder</span><br><span class="line"></span><br><span class="line">逐一移动 找到匹配字符:</span><br><span class="line">litchicoder</span><br><span class="line">      coder</span><br></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class BF &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int r = queryByBF(&quot;HelloWord&quot;, &quot;Word&quot;);</span><br><span class="line">        System.out.print(r == 0 ? &quot;字符串匹配失败&quot; : &quot;子字符串在原串的位置：&quot; + r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param s 原字符串</span><br><span class="line">     * @param t 需要匹配的子字符串位置</span><br><span class="line">     */</span><br><span class="line">    public static int queryByBF(String s, String t) &#123;</span><br><span class="line">        char[] a = s.toCharArray();</span><br><span class="line">        char[] b = t.toCharArray();</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        while (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123;</span><br><span class="line">            //比较字符</span><br><span class="line">            if (a[i] == b[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //i后退重新匹配</span><br><span class="line">                i++;</span><br><span class="line">                j = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j &gt;= t.length()) &#123;</span><br><span class="line">            return i - t.length();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //匹配失败</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="kmp算法">KMP算法</span></h3><p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;bf算法&quot;&gt;BF算法&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;首先原串与字串左端对齐，，如果第一个字符不匹配，字串向后移动逐一移动，当发现死一个第一个字符匹配后，当前位置下比较剩余字串的字符与原串是否匹配，直到全部匹配。&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>递归和分治</title>
    <link href="/2020/04/14/%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB/"/>
    <id>/2020/04/14/递归和分治/</id>
    <published>2020-04-14T05:19:33.000Z</published>
    <updated>2020-04-14T06:43:14.130Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="递归">递归</span></h3><p>高级语言中，函数自己调用和调用其他函数并没有本质的不同，我们把一个直接调用自己或者通过一系列调用语句间接地调用自己的函数，称作递归函数。（ps：每个递归定义必须至少有一个条件，当满足这个条件时递归不再进行，即函数不再调用自身而是返回值）</p><h4><span id="斐波那契fibonacci数列">斐波那契(Fibonacci)数列</span></h4><p>如果说兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔子都不会死去，能够一直干下去，那么一年以后可以繁殖多少对兔子呢？</p><p><img src="fibonacci.jpg" alt=""></p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int Fib(int i)</span><br><span class="line">&#123;</span><br><span class="line">    if( i &lt; 2 )</span><br><span class="line">        return i == 0 ? 0 : 1;</span><br><span class="line">    return Fib(i-1) + Fib(i-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="分治">分治</span></h3><p>在遥远的周朝，人们受生产力水平所限，无法管理庞大的土地和众多的人民，因此采用了封邦建国的封建制度，把土地一层一层划分下去，以达到分而治之的目的，这也许是最古老的分治法了：</p><p><img src="fenzhi.png" alt=""></p><h4><span id="汉诺塔问题">汉诺塔问题</span></h4><p>汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><p><img src="hanoi.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Hanoi &#123;</span><br><span class="line">    /**</span><br><span class="line">    * </span><br><span class="line">    * @param n 盘子的个数</span><br><span class="line">    * @param a 原来的柱子</span><br><span class="line">    * @param b 中间辅助柱子</span><br><span class="line">    * @param c 最终到达的目标珠子</span><br><span class="line">    */</span><br><span class="line">    public void hanoi(int n, char a, char b, char c) &#123;</span><br><span class="line">        if (n == 1) &#123;</span><br><span class="line">            move(a, c);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          //将n-1个盘子从a利用c移动到b盘子</span><br><span class="line">            hanoi(n - 1, a, c, b);</span><br><span class="line">            //将第n个盘子从a移动到c</span><br><span class="line">            move(a, c);</span><br><span class="line">            //将n-1个盘子从b利用a移动到c</span><br><span class="line">            hanoi(n - 1, b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 移动盘子</span><br><span class="line">    private void move(char origin, char target) &#123;</span><br><span class="line">        System.out.println(&quot;方向:&quot; + origin + &quot;---&gt;&quot; + target);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hanoi hanoi = new Hanoi();</span><br><span class="line">        hanoi.hanoi(3, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="快速排序">快速排序</span></h4><h4><span id="找出第n大的值">找出第n大的值</span></h4><h4><span id="直尺">直尺</span></h4><h4><span id="八皇后问题">八皇后问题</span></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;递归&quot;&gt;递归&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;高级语言中，函数自己调用和调用其他函数并没有本质的不同，我们把一个直接调用自己或者通过一系列调用语句间接地调用自己的函数，称作递归函数。（ps：每个递归定义必须至少有一个条件，当满足这个条件时递归不再进行，即函
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="/2020/04/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>/2020/04/13/栈和队列/</id>
    <published>2020-04-13T03:53:45.000Z</published>
    <updated>2020-04-14T05:00:35.712Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="栈">栈：</span></h3><p>栈(Stack)是一个后进先出(Last in first out LIFO)的线性表，要求只在表尾进行删除和插入操作了，栈的插入叫做进栈（进栈、压栈、入栈）、栈的删除叫出栈。</p><p><img src="stack.jpg" alt=""></p><h3><span id="队列">队列：</span></h3><p>队列(queue)是只允许在一端进行插入操作，而另一端进行删除操作的一种先进先出(First in First out FIFo)的线性表<br>1.循环队列：</p><p><img src="circle_queue.jpg" alt="循环队列"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class CircleQueue&lt;E&gt; &#123;</span><br><span class="line">    private Object q[];</span><br><span class="line">    private int head = 0;</span><br><span class="line">    private int tail = 0;</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public CircleQueue(int size) &#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">        q = new Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CircleQueue() &#123;</span><br><span class="line">        this(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean inQueue(E e) &#123;</span><br><span class="line">        //表示队列已经满了</span><br><span class="line">        if ((tail+1) % size == head) return false;</span><br><span class="line">        q[tail] = e;</span><br><span class="line">        tail = (tail + 1) % size;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E outQueue() &#123;</span><br><span class="line">        if (head == tail) return null;</span><br><span class="line">        E o = (E) q[head];</span><br><span class="line">        head = (head + 1) % size;</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;栈&quot;&gt;栈：&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;栈(Stack)是一个后进先出(Last in first out LIFO)的线性表，要求只在表尾进行删除和插入操作了，栈的插入叫做进栈（进栈、压栈、入栈）、栈的删除叫出栈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线性表</title>
    <link href="/2020/04/08/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>/2020/04/08/线性表/</id>
    <published>2020-04-08T12:49:40.000Z</published>
    <updated>2020-04-12T13:22:34.500Z</updated>
    
    <content type="html"><![CDATA[<h4><span id="线性表理解为将数据结点用一根线连接起来存储在物理空间线性表的数据元素一般具有相同的数据类型-大部分线性表中除了第一个元素没有前驱和最后一个元素没有后继其他元素都有前驱和后继也就是各元素之间是一对一的关系">线性表理解为将数据结点用一根“线”连接起来存储在物理空间，线性表的数据元素一般具有相同的数据类型。大部分线性表中除了第一个元素（没有前驱）和最后一个元素（没有后继）其他元素都有前驱和后继（也就是各元素之间是一对一的关系）。</span></h4><ul><li><h3><span id="顺序存储结构顺序表">顺序存储结构（顺序表）</span></h3></li></ul><p>顺序存储结构就是数据是用一块完整的物理空间来连续存储数据，一般它的大小是固定的。<br>优点：物理空间利用率高，增查效率高。<br>缺点：插入和删除效率低，每次都需要移动目标元素后面的所有数据元素，由于它的length是提前分配固定好不能扩容，会发生存储溢出。</p><ul><li><h3><span id="链式存储结构">链式存储结构</span></h3>链式存储结构中数据元素的存储方式在物理空间中是随机的，数据结点氛围数据域和指针域，数据域存储数据元素，指针域来关联起来数据结点形成链。链式存储结构一般有单链表、双向链表和循环链表。<ol><li>单链表</li></ol></li></ul><p><img src="single_linked_list.jpg" alt=""></p><p>题目：找到单链表倒数第n个节点，保证链表中节点的最少数量为n。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for ListNode.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int val) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /*</span><br><span class="line">     * @param head: The first node of linked list.</span><br><span class="line">     * @param n: An integer</span><br><span class="line">     * @return: Nth to last node of a singly linked list. </span><br><span class="line">     */</span><br><span class="line">    public ListNode nthToLast(ListNode head, int n) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        ArrayList&lt;ListNode&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">        if (head!=null)&#123;</span><br><span class="line">            list.add(head);</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(head.next!=null)&#123;</span><br><span class="line">            list.add(0,head.next);</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode targetNode=list.get(n-1);</span><br><span class="line">        return targetNode;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>双向链表<br>双向链表是每个数据结点都有两个指针，分别指向相邻的前驱结点和后继结点，可以方便的访问某个结点的前驱结点和后继结点，存储上会相对多占用一些空间。<br><img src="duLinkList.jpg" alt=""></p><p>代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>静态链表<br>静态链表就是用数组来实现链式存储结构，所以它的长度是初始化的时候固定分配的定长。</li></ol><p><img src="static_list.jpg" alt=""></p><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">public class StaticList &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void run() &#123;</span><br><span class="line">        StcList list = new StcList&lt;CharSequence&gt;();</span><br><span class="line">        System.out.println(&quot;顺序新增前：&quot;);</span><br><span class="line">        list.printAll();</span><br><span class="line">        System.out.println(&quot;顺序新增后：&quot;);</span><br><span class="line">        list.add(&quot;A&quot;);</span><br><span class="line">        list.add(&quot;B&quot;);</span><br><span class="line">        list.add(&quot;C&quot;);</span><br><span class="line">        list.add(&quot;E&quot;);</span><br><span class="line">        list.insert(&quot;D&quot;, 3);</span><br><span class="line">        list.delete(2);</span><br><span class="line">        list.printAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //存储结构</span><br><span class="line">    public static class StaticListNode&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private E data;</span><br><span class="line">        private int cursor;</span><br><span class="line"></span><br><span class="line">        public StaticListNode(E data, int cursor) &#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">            this.cursor = cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public E getData() &#123;</span><br><span class="line">            return data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setData(E data) &#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getCursor() &#123;</span><br><span class="line">            return cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setCursor(int cursor) &#123;</span><br><span class="line">            this.cursor = cursor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class StcList&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private static final int MAX_SIZE = 10;</span><br><span class="line">        StaticListNode&lt;E&gt;[] nodes = new StaticListNode[MAX_SIZE];</span><br><span class="line"></span><br><span class="line">        public StcList() &#123;</span><br><span class="line">            initList(nodes, nodes.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //初始化备用链表</span><br><span class="line">        private void initList(StaticListNode[] nodes, int maxSize) &#123;</span><br><span class="line">            for (int i = 0; i &lt; maxSize; i++) &#123;</span><br><span class="line">                nodes[i] = new StaticListNode(null, i + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            //将最后一个数据元素的游标指向第一个有值元素</span><br><span class="line">            nodes[maxSize - 1] = new StaticListNode(null, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void printAll() &#123;</span><br><span class="line">            for (int i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">                System.out.print(nodes[i].getCursor());</span><br><span class="line">                System.out.print(&quot;:&quot;);</span><br><span class="line">                System.out.print(nodes[i].getData());</span><br><span class="line">                System.out.print(&quot;:&quot;);</span><br><span class="line">                System.out.print(i);</span><br><span class="line">                System.out.print(&quot;|&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 查找当前备用链表的头的</span><br><span class="line">         */</span><br><span class="line">        private void findHead() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 分配空间 分配空间的元素下标</span><br><span class="line">         *</span><br><span class="line">         * @return 0分配失败</span><br><span class="line">         */</span><br><span class="line">        private int mallocArry() &#123;</span><br><span class="line">            int index = 0;</span><br><span class="line">            if (nodes[0].cursor &gt; 0) &#123;</span><br><span class="line">                index = nodes[0].cursor;</span><br><span class="line">                nodes[0].cursor = nodes[index].cursor;</span><br><span class="line">            &#125;</span><br><span class="line">            return index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //顺序新增元素</span><br><span class="line">        public boolean add(E e) &#123;</span><br><span class="line">            if (e == null) &#123;</span><br><span class="line">                System.out.println(&quot;新增失败&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //不等于零说明链表容量没用完，可以新增</span><br><span class="line">            int currentIndex = nodes[0].getCursor();</span><br><span class="line">            if (currentIndex &gt; 0) &#123;</span><br><span class="line">                //当前空元素下标</span><br><span class="line">                nodes[currentIndex].setData(e);</span><br><span class="line">                nodes[0].setCursor(nodes[currentIndex].getCursor());</span><br><span class="line">//                nodes[currentIndex].setCursor(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;新增失败&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * @param e     要插入的数据</span><br><span class="line">         * @param index 表示要插入的链中的位置</span><br><span class="line">         * @return true插入成功</span><br><span class="line">         */</span><br><span class="line">        //新增元素</span><br><span class="line">        public boolean insert(E e, int index) &#123;</span><br><span class="line">            if (e == null || index &lt; 0 || index &gt; MAX_SIZE - 1) &#123;</span><br><span class="line">                System.out.println(&quot;插入元素失败&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //不等于零说明链表容量没用完，可以新增</span><br><span class="line">            int currentIndex = nodes[0].getCursor();</span><br><span class="line">            if (currentIndex &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">                //查找对应的位置</span><br><span class="line">                int k = 1;</span><br><span class="line">                for (int i = 0; i &lt; index - 1; i++) &#123;</span><br><span class="line">                    k = nodes[k].cursor;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //要插入位置记录的游标</span><br><span class="line">                int insertCursor = nodes[k].getCursor();</span><br><span class="line"></span><br><span class="line">                //申请分配的空间的下标</span><br><span class="line">                int i = mallocArry();</span><br><span class="line"></span><br><span class="line">                //插入位置的游标连接到新插入元素</span><br><span class="line">                nodes[k].setCursor(i);</span><br><span class="line">                //新插入元素的游标连接之前插入位置记录的游标</span><br><span class="line">                nodes[i].cursor = insertCursor;</span><br><span class="line">                nodes[i].data = e;</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;插入元素失败&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean delete(int index) &#123;</span><br><span class="line"></span><br><span class="line">            //不等于零说明链表容量没用完，可以新增</span><br><span class="line">            int currentEmptyIndex = nodes[0].getCursor();</span><br><span class="line">            if (currentEmptyIndex &gt; 0) &#123;</span><br><span class="line">                //查找前一个的位置</span><br><span class="line">                int k = 1;</span><br><span class="line">                for (int i = 1; i &lt; index - 1; i++) &#123;</span><br><span class="line">                    k = nodes[k].cursor;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                int currentIndex = nodes[k].cursor;</span><br><span class="line">                int nextIndex = nodes[currentIndex].cursor;</span><br><span class="line">                nodes[k].cursor = nextIndex;</span><br><span class="line"></span><br><span class="line">                //将删除的结点连接到备用链表</span><br><span class="line">                free(currentIndex);</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;删除元素失败&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void free(int i) &#123;</span><br><span class="line">            nodes[i].cursor=nodes[0].cursor;</span><br><span class="line">            nodes[0].cursor=i;</span><br><span class="line">            nodes[i].data = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>循环链表 有环</li></ol><p>循环链表的特点是最后一个结点的指针指向头结点，使整个链表形成环。</p><p>空链的判断条件：head==head-&gt;next;rear==rear-&gt;next;</p><ul><li><h3><span id="约瑟夫问题">约瑟夫问题</span></h3></li></ul><p>问题描述：<br>N个人围成一个圈，从第一个开始报数，第M个人将被杀掉，最后只剩一个，其他都被杀掉。</p><p><img src="josephus_problem.jpg" alt=""></p><p>循环链表的实现方式就是通过遍历元素，指针移动M位删除该元素，知道剩余一个元素。<br>数学推导方式是发现最终获胜的元素下标是在每一轮“杀人”过程中移动M位从而得到公式：f(N,M)=(f(N−1,M)+M)。</p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, i, winner = 0;</span><br><span class="line">    printf (&quot;N M = &quot;);</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    for (i = 2; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       //i是每阶约瑟夫环的人数</span><br><span class="line">        winner = (winner + m) % i;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">    //编号是从零开始，这里加1变成符合习惯的计数</span><br><span class="line">    printf (&quot;\nThe winner is %d\n&quot;, (winner +1));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3><span id="魔术师发牌问题">魔术师发牌问题</span></h3></li></ul><p>问题描述：<br>魔术师手中有A到K十三张黑桃扑克牌，表演前魔术师已经按照一定的顺序叠放好，表演过程：开始，魔术师数1将最上面的那张翻过来，是黑桃A，将其放在桌面上；第二次，魔术师数1、2，将第一张牌放在所有牌最下面，将第二张牌翻转过来，第二张牌正好是黑桃2；第三次，魔术师数1、2、3，将第一、二张牌按照顺序放在所有牌最下面，将第三张牌翻转过来，第三张牌正好是黑桃3；…知道所有牌都翻转过来，顺序刚好是A、2、3…K，现在要知道魔术师在翻牌前叠放的13张牌的顺序。</p><p> 代码实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><ul><li><h3><span id="拉丁方阵问题">拉丁方阵问题</span></h3></li></ul><p>问题描述：<br>拉丁方阵是一种n×n的方阵，方阵中恰有n种不同的元素，每种元素恰有n个，并且每种元素在一行和一列中 恰好出现一次。</p><p><img src="ladingfangzhen.jpg" alt=""></p><p>特点：<br>每一行除了开始的数递进一位外，其余的数都是按照顺序排列，递进的数排在后面，因此使用循环链表解决。</p><p> 代码实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4&gt;&lt;span id=&quot;线性表理解为将数据结点用一根线连接起来存储在物理空间线性表的数据元素一般具有相同的数据类型-大部分线性表中除了第一个元素没有前驱和最后一个元素没有后继其他元素都有前驱和后继也就是各元素之间是一对一的关系&quot;&gt;线性表理解为将数据结点用一根“线”连接起来存储
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度和空间复杂度</title>
    <link href="/2020/04/07/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>/2020/04/07/时间复杂度和空间复杂度/</id>
    <published>2020-04-07T13:24:37.000Z</published>
    <updated>2020-04-07T15:08:34.445Z</updated>
    
    <content type="html"><![CDATA[<p>时间复杂度：执行算法所需要的时间</p><p>空间复杂度：执行算法所需要的内存空间</p><p>时间复杂度的定义：一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得T(n)/f(n)的极限值（当n趋近于无穷大时）为不等于零的常数，则称f(n)是T(n)的同数量级函数</p><ul><li>通常将O(1)、O(n)、O(logn)、O(n2)等分别叫做常量阶、线性阶、对数阶、平方阶等</li><li>推导大O阶方法：1.用常数1取代运行时间中的所有加法常数；2.修改后的运行次数函数中，值保留最高阶项；3.如果最高阶向存在且不是1，则去除与这个项相乘的常数</li><li>常数阶O(1)：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int sum=0，n=100；</span><br><span class="line">sum=（1+n）*n/2;</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure><ul><li>线性阶O(n):</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">//O(1)的算法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对数阶O(logn):</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int num=1;</span><br><span class="line">while(num&lt;n)&#123;</span><br><span class="line">num=num*2;</span><br><span class="line">//O(1)的算法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>平方阶O(n^2):</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">    for(int j=i;j++)&#123;</span><br><span class="line">    //O(1)的算法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>常用的时间复杂度按照耗费的时间从小到大依次是：</li></ul><p><code>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;时间复杂度：执行算法所需要的时间&lt;/p&gt;
&lt;p&gt;空间复杂度：执行算法所需要的内存空间&lt;/p&gt;
&lt;p&gt;时间复杂度的定义：一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得T(n)/f(n)的极限值（当n趋近于无穷大时
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>面试积累</title>
    <link href="/2020/02/05/%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF/"/>
    <id>/2020/02/05/面试积累/</id>
    <published>2020-02-05T06:20:52.000Z</published>
    <updated>2020-04-24T11:39:54.664Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="要求">要求：</span></h2><ul><li>五险一金（全额，非全额要在基础薪资上调整）</li><li>技术团队规模</li><li>上下班时间 单双休 加班情况</li><li>人员配置 发版频率</li><li>绩效 年终奖</li><li>其他福利 餐补 车补贴 房补贴</li></ul><h2><span id="项目经验">项目经验：</span></h2><p>遇到了什么困难怎么解决的</p><ol><li>直播</li></ol><p>做了两方面的隔离，一是与其他业务模块的解耦 利用中间控制层 直播模块提供出对其他业务场景的依赖需求 其他业务模块提供这些能力给直播；二是把直播内部分为业务表现层和三方依赖层  具体做法是把三方直播依赖沉淀到baseview 把业务层需要的能力通过统一能力管理输出 （主要是直播画面能力控制和自定义消息协议的控制）</p><ol start="2"><li><p>首页</p></li><li><p>动画控件</p></li></ol><p>级联view<br>tab</p><h2><span id="java基础">java基础：</span></h2><ol><li><p>同步锁<br>同步锁的原理：</p></li><li><p>Arraylist和Linklist<br>ArrayList是一个数组实现了RandomAccess接口可以随机访问元素，增删速度相对慢；<br>LinkList是链表，只能顺序访问元素，增删快</p></li><li>线程和进程</li></ol><ol start="4"><li><p>位运算<br>常见十进制D、二进制B、八进制Q和十六进制H（逢几进1）n<br>十进制向n进制转化：十进制转化为n进制时 十进制数一直除以n得余数 到一直不能整除为止，小数点部分是将小数部分乘以n 取整 然后小数部分继续乘以n 取整部分倒叙排序就是小数部分的值<br>二进制转n进制：采用r（二进制和n进制之间的位数差 例如八进制是3合1、十六进制时4合1，如果是32进制就是 5合1）合1的方式，如果位数不够r位，整数部分向左补零，小数部分向右补零，然后按照案权展开相加即可得</p></li><li><p>线程安全</p></li></ol><ol start="6"><li><p>进程保活</p></li><li><p>HashMap原理</p></li></ol><h2><span id="数据结构与算法">数据结构与算法：</span></h2><ol><li>时间复杂度、空间复杂度</li><li></li></ol><h2><span id="网络">网络：</span></h2><ol><li><p>tcp的三次握手和四次挥手：<br>第一次：c端发送连接请求 序列号seq=x SYN创建连接状态<br>第二次：b端收到信息后 发送确认码ack=x+1 SYN=1<br>第三次：c端收到后</p></li><li><p>http2.0</p></li><li>Android下网络优化方案</li><li>QUIC协议</li><li><h2><span id="android基础">Android基础：</span></h2>android sdk</li></ol><h2><span id="三方库">三方库：</span></h2><ol><li><p>eventbus原理<br>利用反射触发事件函数的执行<br>关键的一个键值对来存储数据 key是eventType（传递的时事件类型）<br>线程模式 posting：处理函数看post在线程就在什么线程执行<br>main：处理函数在主线程执行<br>background：处理函数在子线程 post如果在主线程辉创建子线程 如果在子线程就直接在子线程触发处理<br>async：新建子线程触发处理函数的执行</p></li><li><p>butterknife原理</p></li><li>okhttp</li><li>rxjava</li><li>retrofit</li><li>Glide Fresco 三级缓冲<br>7.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;要求&quot;&gt;要求：&lt;/span&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;五险一金（全额，非全额要在基础薪资上调整）&lt;/li&gt;
&lt;li&gt;技术团队规模&lt;/li&gt;
&lt;li&gt;上下班时间 单双休 加班情况&lt;/li&gt;
&lt;li&gt;人员配置 发版频率&lt;/li&gt;
&lt;li&gt;绩效 年终奖&lt;/
      
    
    </summary>
    
    
      <category term="面试" scheme="/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android数据的持久化</title>
    <link href="/2018/06/28/Android%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>/2018/06/28/Android数据的持久化/</id>
    <published>2018-06-28T07:28:40.000Z</published>
    <updated>2018-06-28T07:51:47.298Z</updated>
    
    <content type="html"><![CDATA[<p>常见的存储的方式为SQlite数据存储、xml存储以及自定义数据格式的存储方式<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的存储的方式为SQlite数据存储、xml存储以及自定义数据格式的存储方式&lt;br&gt;
    
    </summary>
    
    
      <category term="Android 存储" scheme="/tags/Android-%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>android 中gradle依赖冲突解决</title>
    <link href="/2017/11/24/android-%E4%B8%ADgradle%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/"/>
    <id>/2017/11/24/android-中gradle依赖冲突解决/</id>
    <published>2017-11-24T07:00:34.000Z</published>
    <updated>2020-04-07T14:52:54.168Z</updated>
    
    <content type="html"><![CDATA[<p>android项目开发中经常会遇到库依赖异常，大多是版本依赖的冲突问题，说明下常见的版本依赖冲突解决方式</p><p>首页看下我们项目的依赖关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew dependencies :app:dependencies</span><br></pre></td></tr></table></figure></p><p><img src="2847241-08589a6078bf5336.png" alt="依赖包结构" title="依赖包结构"></p><blockquote><p>:app表示依赖module<br>mac下运行可能人别不了命令行，运行<figure class="highlight plain"><figcaption><span>+x gradlew ```添加权限</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以看到依赖结构是树状结构，各库下又依赖了android的官方提供的一些库，如果依赖的库不是太多的话，可以使用transitive参数，使得依赖库所需的依赖不直接使用，在依赖库的module中同一级上做依赖关系</span><br><span class="line">``` </span><br><span class="line">implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; </span><br><span class="line">    compile (&apos;com.alibaba.android:vlayout:1.2.2@aar&apos;) &#123;</span><br><span class="line">        transitive = false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>transitive为false表示单独依赖，true为默认树状依赖</p><p>这种解决方式只用于当前的依赖包只是版本导致的，且版本变动不大，起码它的代码package路径一致，如果差异很大可以指定依赖关系中特定包不包含到依赖中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;</span><br><span class="line">    compile (&apos;com.alibaba.android:vlayout:1.2.2@aar&apos;) &#123;</span><br><span class="line">        exclude group: &apos;support-v4&apos;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      android项目开发中经常会遇到库依赖异常，大多是版本依赖的冲突问题，说明下常见的版本依赖冲突解决方式
    
    </summary>
    
    
      <category term="gradle" scheme="/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>git基础知识</title>
    <link href="/2017/11/07/git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>/2017/11/07/git基础知识/</id>
    <published>2017-11-07T02:53:40.000Z</published>
    <updated>2017-11-16T05:57:00.390Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="git基础知识">git基础知识</span></h1><p>——创建新的ssh key</p><figure class="highlight plain"><figcaption><span>ssh-keygen -t rsa -C "793021170@qq.com"```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">------测试 ssh 链接 github</span><br><span class="line"></span><br><span class="line">```$ ssh -T git@git.oschina.net</span><br></pre></td></tr></table></figure><p>——设置用户名、邮箱</p><figure class="highlight plain"><figcaption><span>git config --global user.name "litchi"```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```$ git config --global user.email &quot;793021170@qq.com&quot;</span><br></pre></td></tr></table></figure><p>——提交到远程服务器</p><figure class="highlight plain"><figcaption><span>git remote add origin ssh://git@dev.lemote.com/rt4ls.git```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```$ git push origin master</span><br></pre></td></tr></table></figure><p>——-本地库中缺少md文件时<br><figure class="highlight plain"><figcaption><span>git pull --rebase origin master```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-------由于远程库是空的，我们第一次推送master分支时，</span><br><span class="line">加上了-u参数，Git不但会把本地的master分支内容推送的远</span><br><span class="line">程新的master分支，还会把本地的master分支和远程的master</span><br><span class="line">分支关联起来，在以后的推送或者拉取时就可以简化命令</span><br><span class="line"></span><br><span class="line">```$　git push -u origin master</span><br></pre></td></tr></table></figure></p><p>——-关联远程库<br><figure class="highlight plain"><figcaption><span>git remote add origin git@server-name:path/repo-name.git```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git checkout master //进入master分支</span><br><span class="line"></span><br><span class="line">git checkout -b frommaster //以master为源创建分支frommaster</span><br><span class="line"></span><br><span class="line">git show # 显示某次提交的内容 git show $id</span><br><span class="line"></span><br><span class="line">git co -- &lt;file&gt; # 抛弃工作区修改</span><br><span class="line"></span><br><span class="line">git co . # 抛弃工作区修改</span><br><span class="line"></span><br><span class="line">git add &lt;file&gt; # 将工作文件修改提交到本地暂存区</span><br><span class="line"></span><br><span class="line">git add . # 将所有修改过的工作文件提交暂存区</span><br><span class="line"></span><br><span class="line">git rm &lt;file&gt; # 从版本库中删除文件</span><br><span class="line"></span><br><span class="line">git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件</span><br><span class="line"></span><br><span class="line">git reset &lt;file&gt; # 从暂存区恢复到工作文件</span><br><span class="line"></span><br><span class="line">git reset -- . # 从暂存区恢复到工作文件</span><br><span class="line"></span><br><span class="line">git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改</span><br><span class="line"></span><br><span class="line">git ci &lt;file&gt; git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　git ci -am &quot;some comments&quot;</span><br><span class="line"></span><br><span class="line">git ci --amend # 修改最后一次提交记录</span><br><span class="line"></span><br><span class="line">git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象</span><br><span class="line"></span><br><span class="line">git revert HEAD # 恢复最后一次提交的状态</span><br><span class="line"></span><br><span class="line">查看文件diff</span><br><span class="line"></span><br><span class="line">git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diff</span><br><span class="line"></span><br><span class="line">git diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异</span><br><span class="line"></span><br><span class="line">git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较</span><br><span class="line"></span><br><span class="line">git diff --staged # 比较暂存区和版本库差异</span><br><span class="line"></span><br><span class="line">git diff --cached # 比较暂存区和版本库差异</span><br><span class="line"></span><br><span class="line">git diff --stat # 仅仅比较统计信息</span><br><span class="line"></span><br><span class="line">查看提交记录</span><br><span class="line"></span><br><span class="line">git log git log &lt;file&gt; # 查看该文件每次提交记录</span><br><span class="line"></span><br><span class="line">git log -p &lt;file&gt; # 查看每次详细修改内容的diff</span><br><span class="line"></span><br><span class="line">git log -p -2 # 查看最近两次详细修改内容的diff</span><br><span class="line"></span><br><span class="line">git log --stat #查看提交统计信息</span><br><span class="line"></span><br><span class="line">tig</span><br><span class="line"></span><br><span class="line">Mac上可以使用tig代替diff和log，brew install tig</span><br><span class="line"></span><br><span class="line">Git 本地分支管理</span><br><span class="line"></span><br><span class="line">查看、切换、创建和删除分支</span><br><span class="line"></span><br><span class="line">git br -r # 查看远程分支</span><br><span class="line"></span><br><span class="line">git br &lt;new_branch&gt; # 创建新的分支</span><br><span class="line"></span><br><span class="line">git br -v # 查看各个分支最后提交信息</span><br><span class="line"></span><br><span class="line">git br --merged # 查看已经被合并到当前分支的分支</span><br><span class="line"></span><br><span class="line">git br --no-merged # 查看尚未被合并到当前分支的分支</span><br><span class="line"></span><br><span class="line">git co &lt;branch&gt; # 切换到某个分支</span><br><span class="line"></span><br><span class="line">git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去</span><br><span class="line"></span><br><span class="line">git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branch</span><br><span class="line"></span><br><span class="line">git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除</span><br><span class="line"></span><br><span class="line">git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支</span><br><span class="line"></span><br><span class="line">git br -d &lt;branch&gt; # 删除某个分支</span><br><span class="line"></span><br><span class="line">git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)</span><br><span class="line"></span><br><span class="line"> 分支合并和rebase</span><br><span class="line"></span><br><span class="line">git merge &lt;branch&gt; # 将branch分支合并到当前分支</span><br><span class="line"></span><br><span class="line">git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交</span><br><span class="line"></span><br><span class="line">git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"> Git补丁管理(方便在多台机器上开发同步时用)</span><br><span class="line"></span><br><span class="line">git diff &gt; ../sync.patch # 生成补丁</span><br><span class="line"></span><br><span class="line">git apply ../sync.patch # 打补丁</span><br><span class="line"></span><br><span class="line">git apply --check ../sync.patch #测试补丁能否成功</span><br><span class="line"></span><br><span class="line"> Git暂存管理</span><br><span class="line"></span><br><span class="line">git stash # 暂存</span><br><span class="line"></span><br><span class="line">git stash list # 列所有stash</span><br><span class="line"></span><br><span class="line">git stash apply # 恢复暂存的内容</span><br><span class="line"></span><br><span class="line">git stash drop # 删除暂存区</span><br><span class="line"></span><br><span class="line">Git远程分支管理</span><br><span class="line"></span><br><span class="line">git pull # 抓取远程仓库所有分支更新并合并到本地</span><br><span class="line"></span><br><span class="line">git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并</span><br><span class="line"></span><br><span class="line">git fetch origin # 抓取远程仓库更新</span><br><span class="line"></span><br><span class="line">git merge origin/master # 将远程主分支合并到本地当前分支</span><br><span class="line"></span><br><span class="line">git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支</span><br><span class="line"></span><br><span class="line">git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上</span><br><span class="line"></span><br><span class="line">git push # push所有分支</span><br><span class="line"></span><br><span class="line">git push origin master # 将本地主分支推到远程主分支</span><br><span class="line"></span><br><span class="line">git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)</span><br><span class="line"></span><br><span class="line">git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名</span><br><span class="line"></span><br><span class="line">git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支</span><br><span class="line"></span><br><span class="line">git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支</span><br><span class="line"></span><br><span class="line">Git远程仓库管理</span><br><span class="line"></span><br><span class="line">GitHub</span><br><span class="line"></span><br><span class="line">git remote -v # 查看远程服务器地址和仓库名称</span><br><span class="line"></span><br><span class="line">git remote show origin # 查看远程服务器仓库状态</span><br><span class="line"></span><br><span class="line">git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址</span><br><span class="line"></span><br><span class="line">git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm &lt;repository&gt; # 删除远程仓库</span><br><span class="line"></span><br><span class="line">创建远程仓库</span><br><span class="line"></span><br><span class="line">git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库</span><br><span class="line"></span><br><span class="line">scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上</span><br><span class="line"></span><br><span class="line">mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库</span><br><span class="line"></span><br><span class="line">git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址</span><br><span class="line"></span><br><span class="line">git push -u origin master # 客户端首次提交</span><br><span class="line"></span><br><span class="line">git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track</span><br><span class="line"></span><br><span class="line">git remote set-head origin master # 设置远程仓库的HEAD指向master分支</span><br><span class="line"></span><br><span class="line">也可以命令设置跟踪远程库和本地库</span><br><span class="line"></span><br><span class="line">git branch --set-upstream master origin/master</span><br><span class="line"></span><br><span class="line">git branch --set-upstream develop origin/develop</span><br><span class="line"></span><br><span class="line">--------显示command的help</span><br><span class="line"></span><br><span class="line">```git help &lt;command&gt; #</span><br></pre></td></tr></table></figure></p><p>异常处理：<br>1.如果出现remote origin already exists.需要删除远程库后在执行git remote add origin<br> 具体执行：git remote rm origin<br> git remote add origin <a href="mailto:git@git.oschina.net" target="_blank" rel="noopener">git@git.oschina.net</a>:jichengliu/SilkMarke</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;git基础知识&quot;&gt;git基础知识&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;——创建新的ssh key&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;ssh-keygen -t rsa -C &quot;79302
      
    
    </summary>
    
    
      <category term="git" scheme="/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式</title>
    <link href="/2017/11/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>/2017/11/06/设计模式之工厂模式/</id>
    <published>2017-11-06T03:10:35.000Z</published>
    <updated>2017-11-16T05:50:54.645Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="设计模式之工厂模式">设计模式之工厂模式</span></h1><h2><span id="前言">前言</span></h2><p>最近在看设计模式相关的一些知识，看了一些感觉还是要做一些记录的，一方面用来记录当前情况下个人对设计模式的理解程度，使得这块知识更加深刻，另一方面也是方便把自己的一些拙见拿出来希望能够共同进步，得到众人的指正。</p><h2><span id="引入">引入</span></h2><p>工厂模式应该说最常见的模式，看一些介绍模式的书里工厂模式基本都是第一个被提到的，它应用场景比较多，也容易被理解。它是名如其模式，先来分析下它的名字，“工厂”用来生产各种产品，我们可以直接通过工厂来获得需要的各种产品，而不需要来考虑其具体的实现，所谓的“工厂”就类似于“商店”，提供我们需要所需产品。那么“工厂”的产品是怎么样获得的呢，“工厂”会根据我们具体的需求来利用具体的“材料”来“生产”具体的产品，到这里来看图说话。</p><p><img src="20171106-143320.png" alt="factory" title="factory"></p><blockquote></blockquote><p>上图就是对上面文字的一个概括，这里先又了这个概念就OK了，下面深入到代码层面来说明。</p><h2><span id="代码实现">代码实现</span></h2><p>这里用<a href="#introduced">引入</a>中最原始的提到的工厂、产品和消费者举例。<br>例子在android studio中android项目中开发。</p><h3><span id="工厂-产品和消费者">工厂、产品和消费者</span></h3><p><img src="QQ20171106-175109@2x.png" alt="factory" title="factory"></p><p>创建一个工厂类(Factory),提供一个获得产品的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得产品对象实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P    extends BaseProduct&gt;   p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> p</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;P extends BaseProduct&gt; <span class="function">P <span class="title">getProduct</span><span class="params">(Class&lt;P&gt; clazz)</span> </span>&#123;</span><br><span class="line">        P p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p = (P) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个接口(IProduct)，商品类将实现produce()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseProduct <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别创建商品类(BaseProduct、ProductOne、ProductTwo、ProductThree和ProductFour)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseProduct</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBaseComponents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//制作基础组件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductOne</span> <span class="keyword">extends</span> <span class="title">BaseProduct</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseProduct <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        makeBaseComponents();</span><br><span class="line">        Log.d(<span class="string">"ProductOne"</span>, <span class="string">"make ProductOne"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductTwo</span> <span class="keyword">extends</span> <span class="title">BaseProduct</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseProduct <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        makeBaseComponents();</span><br><span class="line">        Log.d(<span class="string">"ProductTwo"</span>, <span class="string">"make ProductTwo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductThree</span> <span class="keyword">extends</span> <span class="title">BaseProduct</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseProduct <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        makeBaseComponents();</span><br><span class="line">        Log.d(<span class="string">"ProductThree"</span>, <span class="string">"make ProductThree"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFour</span> <span class="keyword">extends</span> <span class="title">BaseProduct</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseProduct <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        makeBaseComponents();</span><br><span class="line">        Log.d(<span class="string">"ProductFour"</span>, <span class="string">"make ProductFour"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MainActivity类中获得需要的商品类实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetProduct</span><span class="params">(<span class="keyword">int</span> productType)</span> </span>&#123;</span><br><span class="line">        Class&lt;? extends BaseProduct&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (productType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                clazz = ProductOne.class;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                clazz = ProductTwo.class;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                clazz = ProductThree.class;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                clazz = ProductFour.class;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BaseProduct product = Factory.getProduct(clazz);</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, product.produce(), Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetProductThree</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        onGetProduct(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetProductTwo</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        onGetProduct(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetProductOne</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        onGetProduct(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetProductFour</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        onGetProduct(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终我们实现在activity中获得了产品的实例对象</p><p><a href="https://github.com/litchicoder/factorypatternpro" target="_blank" rel="noopener">github</a></p><h2><span id="为什么要用工厂模式">为什么要用工厂模式</span></h2><p>在开发过程中常常会独立做一些模块供其他的开发者来用，这种情况下，其实对于其他的开发者来说要求在使用功能时尽量的简单、调用方便，他们不需要去了解里面的具体实现，只要简单调用就可以拿到对应的实例，这个时候对于工厂模式时一个可行的方案，当然在实际开发中可以会和其他的模式混用来达到效果，这个还要具问具析。对于我们可以在什么场景下利用工厂模式，这里列出一些它的利弊，以便在考虑使用时参考：</p><blockquote><p>利:</p><ol><li>多类型扩展好，如果新增了一种商品只要实现它的具体类和方法，即可根据类来获取其实例</li><li>具体实现是封闭的、不对外的</li><li>调用方便，可通过一个类型或者类名就可以获得具体实例</li></ol></blockquote><blockquote><p>弊<br>产品类创建方式单一，因为是通过类命来创建实例，这样创建不会像常见的直接new灵活<br>不适合单一产品时使用</p></blockquote>]]></content>
    
    <summary type="html">
    
      最近在看设计模式相关的一些知识，看了一些感觉还是要做一些记录的，一方面用来记录当前情况下个人对设计模式的理解程度，使得这块知识更加深刻，另一方面也是方便把自己的一些拙见拿出来希望能够共同进步，得到众人的指正
    
    </summary>
    
    
      <category term="设计模式" scheme="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Markdown常用语法</title>
    <link href="/2017/11/06/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <id>/2017/11/06/Markdown常用语法/</id>
    <published>2017-11-06T03:01:55.000Z</published>
    <updated>2017-11-07T04:49:11.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo command line</title>
    <link href="/2017/11/03/hexo-command-line/"/>
    <id>/2017/11/03/hexo-command-line/</id>
    <published>2017-11-03T14:34:03.000Z</published>
    <updated>2020-02-05T06:21:38.195Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="create-a-new-post">Create a new post</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h1><span id="run-server">Run server</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h1><span id="generate-static-files">Generate static files</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h1><span id="deploy-to-remote-sites">Deploy to remote sites</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux环境下jdk安装配置</title>
    <link href="/2017/11/03/linux%E7%8E%AF%E5%A2%83%E4%B8%8Bjdk%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>/2017/11/03/linux环境下jdk安装配置/</id>
    <published>2017-11-03T13:54:47.000Z</published>
    <updated>2017-11-03T14:46:49.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>jdk下载</p><pre><code>wget -O jdk-8u131-linux-x64.tar.gz jdk-8u131-linux-x64.tar.gzAuthParam=1499664230_984ba136862e0fd6281ac5bc2bee90e2</code></pre></li><li><p>解压文件</p><pre><code>tar xf jdk-8u131-linux-x64.tar.gz</code></pre></li><li><p>创建要存放的目录并复制解压后的jdk文件到目录下</p></li></ul><a id="more"></a><ul><li><p>修改配置文件，指向存放jdk的目录</p><pre><code>cd etc(进入etc目录)vi profile（打开profile文件并修改环境变量source profile（使文件生效)</code></pre></li></ul><p><img src="2847241-08589a6078bf5336.png" alt="linux环境下jdk安装配置" title="linux环境下jdk安装配置"></p><ul><li><p>测试</p><pre><code>java -version</code></pre></li></ul><p>能够打印java 版本号信息就表示安装或升级成功</p><p><img src="2847241-dd005818079d56ba.png" alt="linux环境下jdk安装配置" title="linux环境下jdk安装配置"></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;jdk下载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget -O jdk-8u131-linux-x64.tar.gz jdk-8u131-linux-x64.tar.gzAuthParam=1499664230_984ba136862e0fd6281ac5bc2bee90e2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解压文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar xf jdk-8u131-linux-x64.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建要存放的目录并复制解压后的jdk文件到目录下&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java linux" scheme="/tags/java-linux/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下Jenkins搭建</title>
    <link href="/2017/11/03/linux%E7%8E%AF%E5%A2%83%E4%B8%8BJenkins%E6%90%AD%E5%BB%BA/"/>
    <id>/2017/11/03/linux环境下Jenkins搭建/</id>
    <published>2017-11-03T13:46:06.000Z</published>
    <updated>2017-11-03T14:30:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="安装java环境">安装java环境</span></h3><p>具体查看Linux java环境安装</p><h3><span id="安装tomcat">安装tomcat</span></h3><p>从tomcat官网上下载最新的安装压缩包，注意区分选择不同操作环境下的压缩包.（Linux一般是 tar.gz，Windows一般用zip压缩包），选择对应的压缩包能保证系统可以直接解压，避免不支持时还需安转压缩工具。</p><ol><li><p>下载压缩包</p><pre><code>wget http://apache.fayea.com/tomcat/tomcat-8/v8.5.16/bin/apache-tomcat-8.5.16.tar.gz</code></pre></li><li><p>解压压缩包</p><pre><code>tar xf apache-tomcat-8.5.16.tar.gz</code></pre></li><li><p>进入解压后的文件夹并将所有的复制到自己要安装的目录下</p><pre><code>cd apache-tomcat-8.5.16cp -rf ./*  /usr/local/tomcat/</code></pre></li></ol><a id="more"></a><h3><span id="安装sdk">安装SDK</span></h3><p>根据镜像下载sdk包即可，注意最新的sdk可能没有platform tools文件夹，可下在低版本的将platform tolls文件夹移动到最新的sdk文件夹下即可。</p><p>有一些插件也可以在没有sdk时自动在Jenkins搭建好后构建时自动下载sdk，如Android Emulator Plugin在配置好后它自己会根据配置参数自动去下载对应的sdk版本，这里后面会说到。</p><h3><span id="安装jenkins">安装Jenkins</span></h3><p>从Jenkins官网下载并复制jenkins.war到tomcat目录下webapps下。</p><pre><code>wget http://mirrors.jenkins.io/war/latest/jenkins.warcp ./jenkins.war /usr/local/tomcat/webapps</code></pre><p>启动Tomcat在浏览器中打开http://网址:8080/jenkins/就可以打开Jenkins网页，接下来就可以创建项目，Jenkins玩起来了。</p><h3><span id="注">注：</span></h3><ol><li><p>如果要使用其他端口来使用Jenkins可以运行命令：</p><pre><code>java -jar jenkins.war --httpPort=端口号java -jar jenkins.war --httpPort=8899 --daemon --logfile=日志路径/jenkins/jenkins.log(在后台运行)</code></pre></li><li><p>在打开Jenkins网页前要保证对应的端口号可访问，aliyun要配置安全组，开放对应端口。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装java环境&quot;&gt;&lt;a href=&quot;#安装java环境&quot; class=&quot;headerlink&quot; title=&quot;安装java环境&quot;&gt;&lt;/a&gt;安装java环境&lt;/h3&gt;&lt;p&gt;具体查看Linux java环境安装&lt;/p&gt;
&lt;h3 id=&quot;安装tomcat&quot;&gt;&lt;a href=&quot;#安装tomcat&quot; class=&quot;headerlink&quot; title=&quot;安装tomcat&quot;&gt;&lt;/a&gt;安装tomcat&lt;/h3&gt;&lt;p&gt;从tomcat官网上下载最新的安装压缩包，注意区分选择不同操作环境下的压缩包.（Linux一般是 tar.gz，Windows一般用zip压缩包），选择对应的压缩包能保证系统可以直接解压，避免不支持时还需安转压缩工具。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载压缩包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget http://apache.fayea.com/tomcat/tomcat-8/v8.5.16/bin/apache-tomcat-8.5.16.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解压压缩包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar xf apache-tomcat-8.5.16.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进入解压后的文件夹并将所有的复制到自己要安装的目录下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd apache-tomcat-8.5.16
cp -rf ./*  /usr/local/tomcat/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Jenkins tomcat Linux" scheme="/tags/Jenkins-tomcat-Linux/"/>
    
  </entry>
  
  <entry>
    <title>note</title>
    <link href="/2017/11/03/note/"/>
    <id>/2017/11/03/note/</id>
    <published>2017-11-03T08:56:19.000Z</published>
    <updated>2017-12-04T03:24:38.104Z</updated>
    
    <content type="html"><![CDATA[<p>hexo官方教程地址<a href="http:https://hexo.io/zh-cn/" target="_blank" rel="noopener">http:https://hexo.io/zh-cn/</a></p><p>markdown 教程<a href="http:http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-8/" target="_blank" rel="noopener">http:http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-8/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hexo官方教程地址&lt;a href=&quot;http:https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http:https://hexo.io/zh-cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;markdown 教程&lt;a href=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Jenkins参数化构建android项目</title>
    <link href="/2017/11/03/Jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BAandroid%E9%A1%B9%E7%9B%AE/"/>
    <id>/2017/11/03/Jenkins参数化构建android项目/</id>
    <published>2017-11-03T01:59:37.000Z</published>
    <updated>2017-11-03T15:28:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="达到的目标">达到的目标：</span></h3><ol><li>根据版本类型(release、beta or debug)、版本号、渠道、服务器请求地址等参数进行构建；</li><li>构建完成后显示相关构建信息；</li><li>展示apk下载二维码、下载地址供直接安装和下载apk</li></ol><h3><span id="需要的插件">需要的插件：</span></h3><ol><li>Dynamic Extended Choice Parameter plugin参数化选择需要</li><li>Description Setter Plugin构建的信息显示需要</li><li>GIt Plugingit 插件</li></ol><a id="more"></a><h3><span id="配置项目参数">配置项目参数：</span></h3><ul><li>设置构建类型参数：</li></ul><p>在general模块中复选‘参数化构建过程’，‘添加参数‘中选择’Choice Parameter‘;</p><p><img src="/images/2847241-7702d781810fa0aa.png" alt="‘添加参数‘中选择’Choice Parameter‘" title="添加参数‘中选择’Choice Parameter"></p><p>Name添加参数名，按照Jenkins已有的默认参数集来定义都以大写字母和下划线组成，例：ENVIRONMENT_BUILD，Choices输入item的选项，第一项会变成默认项。<br><img src="/images/2847241-b06b00a4496b0abb.png" alt="&#39;设置参数’Choice Parameter&#39;‘" title="设置参数’Choice Parameter"></p><p>设置列表型参数渠道、版本号、服务器请求地址等：</p><p>列表型参数和构建类型一样，设置name、Choices和Description。<br><img src="/images/2847241-209a8bc3095e2fd6.png" alt="&#39;设置参数’Choice Parameter&#39;‘" title="设置参数’Choice Parameter"></p><ul><li>配置git参数：</li></ul><p>这里首先要保证我们的代码在每个版本都有独立的版本分支，通过不同的版本名来拉取对应的代码，来实现分版本构建。<br><img src="/images/2847241-93622e27d0f82c4b.png" alt="&#39;git参数设置’Choice Parameter&#39;‘" title="git参数设置"></p><ul><li>配置构建命令参数：</li></ul><p>Tasks输入框输入构建命令行  clean assemble${PRODUCT_FLAVOR_BUILD}${ENVIRONMENT_BUILD}，${参数}表示参数应用，‘PRODUCT_FLAVOR_BUILD’是自定义的参数用来表示构建渠道，‘ENVIRONMENT_BUILD’表示构建类型。<br><img src="/images/2847241-10b29af455218b6e.png" alt="&#39;配置构建命令参数‘" title="配置构建命令参数"></p><ul><li>配置构建后描述参数：</li></ul><p>在‘构建’模块‘增加构建步骤’列表中选择‘set build description’，在Description输入框输入html代码，例如下，其中的‘${参数}’表示自定义的一些参数，用‘${参数}’来取对应的值。<br><img src="/images/2847241-b271fd19719d9abf.png" alt="&#39;配置构建后描述参数‘" title="配置构建后描述参数"></p><p>请求环境：${JENKINS_SERVER_HOST}<br>构建类型：${ENVIRONMENT_BUILD}<br>构建渠道：${PRODUCT_FLAVOR_BUILD}<br>构建版本：${APP_BUILD_VERSION}<br>点击查看二维码<br>点击下载apk</p><p>注：如果在构建完后显示还是按照文本显示的，修改一下系统管理／安全配置中‘Markup Formatter‘选择为Safe HTML，来支持html。</p><p>配置效果：<br><img src="/images/2847241-d826648aaeaada30.png" alt="&#39;实现效果‘" title="实现效果"><br><img src="/images/2847241-ccc5d7404bf2a218.png" alt="&#39;实现效果‘" title="实现效果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;达到的目标：&quot;&gt;&lt;a href=&quot;#达到的目标：&quot; class=&quot;headerlink&quot; title=&quot;达到的目标：&quot;&gt;&lt;/a&gt;达到的目标：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;根据版本类型(release、beta or debug)、版本号、渠道、服务器请求地址等参数进行构建；&lt;/li&gt;
&lt;li&gt;构建完成后显示相关构建信息；&lt;/li&gt;
&lt;li&gt;展示apk下载二维码、下载地址供直接安装和下载apk&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;需要的插件：&quot;&gt;&lt;a href=&quot;#需要的插件：&quot; class=&quot;headerlink&quot; title=&quot;需要的插件：&quot;&gt;&lt;/a&gt;需要的插件：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Dynamic Extended Choice Parameter plugin参数化选择需要&lt;/li&gt;
&lt;li&gt;Description Setter Plugin构建的信息显示需要&lt;/li&gt;
&lt;li&gt;GIt Plugingit 插件&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Jenkins Android" scheme="/tags/Jenkins-Android/"/>
    
  </entry>
  
</feed>
