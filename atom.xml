<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>litchi</title>
  
  <subtitle>litchi blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-06-17T14:00:55.898Z</updated>
  <id>/</id>
  
  <author>
    <name>litchi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>View绘制</title>
    <link href="/2020/06/02/View%E7%BB%98%E5%88%B6/"/>
    <id>/2020/06/02/View绘制/</id>
    <published>2020-06-02T04:55:22.000Z</published>
    <updated>2020-06-17T14:00:55.898Z</updated>
    
    <content type="html"><![CDATA[<ul><li>View的绘制流程  </li></ul><p>View的绘制是从ViewRootImpl类的performTraversals方法开始经过measure、layout、draw三个过程将View绘制出来的，measure方法用来测量View的宽高，layout用来确定View再敷容器内的位置，draw绘制View。</p><p><img src="view_process.jpg" alt=""></p><p>performTraversals方法会依次调用perfomrMeasure，performLayout和performDraw，这三个方法完成最上层View的绘制流程，然后会调用onMeasure，onMeasure中会调用对所有子元素的measure方法，这样就完成了一次measure过程，接着子元素会重复父容器的的measure过程。  </p><ul><li>MeasureSpec<br>MeasureSpec可以理解为“测量规则”或“测量标准”。MeasureSpec用一个32位的int值来表示，高2位代表SpecMode（测量模式），低30位代表SpecSize（规格大小）。代码定义这样的：  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Measure specification mode: The parent has not imposed any constraint</span></span><br><span class="line"><span class="comment"> * on the child. It can be whatever size it wants.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Measure specification mode: The parent has determined an exact size</span></span><br><span class="line"><span class="comment"> * for the child. The child is going to be given those bounds regardless</span></span><br><span class="line"><span class="comment"> * of how big it wants to be.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Measure specification mode: The child can be as large as it wants up</span></span><br><span class="line"><span class="comment"> * to the specified size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(@IntRange(from = <span class="number">0</span>, to = (<span class="number">1</span> &lt;&lt; MeasureSpec.MODE_SHIFT)</span> - 1) <span class="keyword">int</span> size,</span></span><br><span class="line"><span class="function">                                  @MeasureSpecMode <span class="keyword">int</span> mode) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">        <span class="keyword">return</span> size + mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MeasureSpecMode</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//noinspection ResourceType</span></span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里可以看到MeasureSpec将SpecMode和SpecSize打包成一个int值，这样可以避免过多的内存分配，getMode和getSize方法利用MODE_MASK与操作来得到需要的mode和size值。<br>SpecMode有三种模式：  </p><ol><li>UNSPECIFIED：[ʌnˈspesɪfaɪd]未说明的，没有明确的。父容器对于View没有任何限制，想要多大就给多大。  </li><li>EXACTLY：[ɪɡˈzæktli] 明确的。父容器决定了明确的大小，View的大小就是SpecSize指定的值，它对应LayoutParams中的match_parent或指定大小值的两种场景。  </li><li>AT_MOST:父容器指定一个可用的SpecSize，View不能大于这个值，具体的值由View内部具体实现决定。对应LayoutParams中的wrap_content。 </li></ol><p><em>对于一个普通的View，它的MeasureSpec是由父容器的MeasureSpec和自身设置的LayoutParam参数来决定的，比如View设置了固定的宽或者高那么它在宽或者高方向上的SpecMode就是EXCATLY，无论它的父容器设置什么测量模式</em></p>]]></content>
    
    <summary type="html">
    
      Android基础
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>View事件传递</title>
    <link href="/2020/06/01/View%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92/"/>
    <id>/2020/06/01/View事件传递/</id>
    <published>2020-06-01T03:52:08.000Z</published>
    <updated>2020-06-01T05:44:28.286Z</updated>
    
    <content type="html"><![CDATA[<ul><li>MotionEvent<br>MotionEvent是View的动作事件参数，包含集中常见的时间类型：  </li></ul><ol><li>ACTION_DOWN：手指刚接触到屏幕时；  </li><li>ACTION_MOVE：手指在屏幕上移动；  </li><li>ACTION_UP：手指从屏幕上离开的瞬间；<br>MotionEvent的两组位置方式：<br>getX()/getY()：表示动作相对于View左上角位置的x、y坐标；<br>getRawX()/getRawY()：表示动作相对于屏幕左上角位置的x、y坐标；  </li></ol><ul><li>事件分发<br><code>public boolean dispatchTouchEvent(MotionEvent event)</code><br>用于事件的分发，如果时间传递到了当前的View，那么该方法一定会被调用，boolean类型的返回值受View的onTouchEvent(MotionEvent event)和其子View的dispatchTouchEvent(MotionEvnet event)的影响，返回true表示消耗当前时间。<br><code>public boolean onInterceptTouchEvent(MotionEvent event)</code><br>用来判断是否拦截当前事件，返回结果表示是否拦截当前事件。<br><code>public boolean onTouchEvent(MotionEvent event)</code><br>在dispatchTouchEvent方法中被调用，用来处理touch事件，返回结果表示是否消耗当前事件。  </li></ul><p><img src="view_event_work.jpg" alt=""><br><img src="view_event_process.jpg" alt=""></p><p>说明：  </p><ol><li>一个事件序列表示手指从接触屏幕（ACTION_DOWN）经历一些列动作事件到手指刚离开屏幕（ACTION_UP）。  </li><li>某个View拦截事件，那么接下来的一个事件序列都有它来处理（时间能到到达的情况下），并且它的onIntercept不会再被调用。  </li><li>如果View再处理事件过程中，不再消耗ACTION_DOWN事件（onTouch返回false），那么事件序列的其他事件将会被其父元素进行消耗。  </li><li>ViewGroup默认不拦截事件。  </li><li>VIew没有onInterveptTouchEvent方法，View默认的onTouchEvent都会消耗事件（默认返回true）。  </li><li>事件传递是由外向内的，即事件总是先传递给父元素，然后通过父元素分发给子View，通过requestDisallowInterceptTouchEvnet方法来干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</li></ol>]]></content>
    
    <summary type="html">
    
      Android基础
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Android系统架构</title>
    <link href="/2020/05/31/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    <id>/2020/05/31/Android系统架构/</id>
    <published>2020-05-31T12:13:09.000Z</published>
    <updated>2020-05-31T13:29:00.323Z</updated>
    
    <content type="html"><![CDATA[<p>Android采用分层架构，从上到下分别为<em>应用程序层（apps、System apps）、应用程序框架层（Java API Framework）、系统运行库和运行环境层（Libraries+Android Runtime）和Linux核心层（HAL+Linux Kernel）</em>。</p><p><img src="android_framework.png" alt=""></p><ul><li><p>System apps<br>可以理解为内置的系统应用，可以像调用Java APIFramework一样区调用系统应用，例如我们调用日历区添加一个日常提醒。</p></li><li><p>Java ApI Framewor<br>android中常用的组件</p></li><li><p>Native c/c++ Libraries<br>本地库比Java API Framework更加偏低层，这里包含OpenGl、多媒体框架等内容。 </p></li><li><p>Android Runtime<br>Android运行时环境，也就是Android虚拟机。Android5.0之前是使用Dalvik虚拟机，<em>Dalvik虚拟机是基于JIT（Just in TIme）及时编译的引擎。Android5.0之后采用ART虚拟机，ART虚拟机是基于AOT（Ahead Of Time）作为编译引擎</em></p></li><li><p>Hardware Abstrction Layer<br>硬件抽象层主要是媒体、蓝牙、传感器的库模块。</p></li><li><p>Linux Kernel<br>Android平台的最底层，直接与硬件交互，负责硬件驱动、进程管理、内存管理、网络管理等功能。</p></li></ul><p><em>什么是JIT和AOT？</em><br>在Android中Java代码会被转换成DEX字节码文件，DEX字节码文件是Android虚拟机可以识别的，Android虚拟机把字节码在转化为机器能识别的机器码。<br>Dalvik虚拟机给予JIT编译，JIT也叫及时编译器，JIT工作原理是在应用运行时，首先将一部分DEX字节码转化为机器码，在程序执行的过程中再陆续将更多代码编译并缓冲，这样做的好处是内存占用少，但CPU再应用运行期间相对消耗大。<br>AOT叫做提前编译器，它是在应用的安装期间就将DEX字节码转化为了机器码，并将其存储在设备上。这样做的好处是在应用运行时占用CPu资源少一些，因为已经转化成了机器码，相对内存占用上多一些。</p>]]></content>
    
    <summary type="html">
    
      Android基础
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>图片加载如何避免OOM</title>
    <link href="/2020/05/30/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DOOM/"/>
    <id>/2020/05/30/图片加载如何避免OOM/</id>
    <published>2020-05-30T14:47:26.000Z</published>
    <updated>2020-05-30T15:19:51.691Z</updated>
    
    <content type="html"><![CDATA[<p>内存中Bitmap大小的计算公式：<br>长占用的像素 <em> 宽占用的像素 </em> 每个像素占用的内存<br>避免OOM也就是要减小图片在内存中的大小，有两种方式等比缩小长宽和减少每个像素占用的内存。</p><ul><li><p>等比缩小长宽：<br>Bitmap的创建是通过BitmapFactory的工厂方法decodeFile()、decodeStream()、decodeByteArray()、decodeResource()。这些方法在创建Bitmap使都一个参数Options，Options中的属性inSampleSize用来对图片进行长宽的设置，inSampleSize的值是2的幂次方，通过设置合适的值来对图片进行缩放操作。  </p></li><li><p>减少像素内存：<br>Options中的属性inPreferredConfig，通过调整这个值的属性来改变每个像素所占的内存，默认值是ARGB_8888,修改为RGB_565或ARGB_4444可以减少一半的内存。  </p></li></ul><table><thead><tr><th>值</th><th>含义  </th></tr></thead><tbody><tr><td>ARGB_8888</td><td>A(Alpha)、R(Red)、G(Green)、B(Blue)各占8位的精度，加起来32位的精度（即4个字节），也就是一个像素占4个字节的长度</td></tr><tr><td>ARGB_4444</td><td>A(Alpha)、R(Red)、G(Green)、B(Blue)各占4位的精度，加起来16位的精度（即2个字节），也就是一个像素占2个字节的长度</td></tr><tr><td>RGB_565</td><td>R(Red)占5位精度、G(Green)占6位精度、B(Blue)占5位精度，一共16位精度，也就是2个字节，不携带透明度信息</td></tr><tr><td>ALPHA_8</td><td>每个像素占位（即一个字节），只办函透明度值，不携带颜色信息</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      Android基础
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>IPC机制</title>
    <link href="/2020/05/29/IPC%E6%9C%BA%E5%88%B6/"/>
    <id>/2020/05/29/IPC机制/</id>
    <published>2020-05-29T12:33:15.000Z</published>
    <updated>2020-05-30T14:25:20.618Z</updated>
    
    <content type="html"><![CDATA[<ul><li>进程与线程<br><em>进程一般指一个执行的单元，也可以称作正在运行的程序实例</em>。<em>线程是CPU进行运算调度的最小单元</em>，它的系统资源是有限的，它是包含在进程之中。所以进程与线程是包含与被包含的关系。  </li><li><p>什么是IPC？<br>IPC全称Inter-Process Communication，即进程间通信。一般应用采用多进程有是为了使应用能够获取更多的内存空间。由于一个进程对应分配一个虚拟机，进程与虚拟机的一一对应，造成我们对同一个类的对象在不同进程中就产生了对个副本，例如有processOne和processTwo两个进程，它们都有一个类A.class，那么在两个进程中的A.class是互不干扰的。总结起来对进程会造成一下几个问题：<br><em>1. 静态成员和单例模式失效；</em><br><em>2. 线程同步机制生效；</em><br><em>3. SharedPreferences可靠性降低（进程并发写可能异常）</em><br><em>4. Application多次创建（可以理解成Application的创建和进程的创建是一致的）</em>  </p></li><li><p>Binder机制<br>Binder是android进程间通信的方式，Binder时基于C/S架构，主要有四部分组成：<br><em>1. Client（客户端进程）</em><br><em>2. Server（服务端进程）</em><br><em>3. ServiceManager（提供注册、查询和返回代理服务对象的功能）</em><br><em>4. Binder驱动（主要进程间的连接，进程间数据交互等基础底层操作）</em>      </p><p><em>服务器通过Binder驱动在ServiceManager中注册服务</em><br><em>客户端通过Binder驱动查询Servicemanager中注册的服务</em><br><em>SreviceManager通过Binder驱动返回服务器代理对象</em><br><em>客户端拿到服务器的代理对象后即可进行进程间的通信</em>  </p></li><li><p>IPC方式比较  </p></li></ul><table><thead><tr><th></th><th>优</th><th>缺</th><th>适用场景  </th></tr></thead><tbody><tr><td>Bundle</td><td>使用简单</td><td>传输Bundle支持的数据类型</td><td>四大组件间的数据传递 </td></tr><tr><td>文件共享</td><td>使用简单</td><td>不适合高并发，无法进行即时通信</td><td>用于实时性不高的场景  </td></tr><tr><td> AIDL</td><td>功能强大 支持一对多并发下的通信，支持实时</td><td>使用较复杂，需要做好线程同步问题</td><td>一对多通信且有RPC需求 </td></tr><tr><td> Messenger</td><td>功能一般，支持一对多串行通信，支持实时通信</td><td>不支持RPC、不能很好处理高并发、数据通过Message进行传输，只能传输Bundle支持的数据类型</td><td>低并发的一对多即时通信 </td></tr><tr><td>ContentProvider</td><td>在数据源访问上功能强大，支持一对多的并发数据共享，可通过call操作扩展其他操作</td><td>提供数据源的CRUD操作</td><td>进程一对多的数据共享  </td></tr><tr><td>     Socket</td><td>功能强大，支持网络传输数据流、支持一对多的实时通信</td><td>实现较繁琐</td><td>网络数据共享</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      Android基础
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化</title>
    <link href="/2020/05/27/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>/2020/05/27/Android性能优化/</id>
    <published>2020-05-27T05:01:02.000Z</published>
    <updated>2020-05-30T14:48:46.004Z</updated>
    
    <content type="html"><![CDATA[<p>Android的性能优化主要从四方面入手，内存优化、布局优化、网络优化和安装包优化。  </p><ul><li><p>常用检查工具<br><em>LeakCanary</em>是一个三方检测内存泄漏的工具库 ，集成后会自动检测应用运行期间的内存泄漏，并直观的输出。<br>Android自带的<em>Android Profiler</em> ，可以检测CPU、MEMERY、NETWORK三方的性能。<br><em>BlockCanary</em>是一个三方用来检测UI卡顿的工具库，像LeakCanary一样集成后当发生UI卡顿现象时会输出卡顿的信息，通过输出的信息可以很方便的来定位导致卡顿的原因。</p></li><li><p>内存优化<br>内存优化的方式时避免内存泄漏（节流）、增加内存（开源）。<br>常见的内存泄露：</p></li></ul><ol><li>单例导致的泄漏。在创建单例时传入了具体页面的Context，由于单例的静态属性，导致单例一致持有该Context引用，一直到应用程序结束。正确的做法是创建单例时应用传入应用级别的Context，也就是Application的Context，这样就保证了单例生命周期与传入Context的统一。  </li><li>静态变量导致的内存泄漏。JVM中可以知道静态变量是在方法区的，它的生命周期是从类加载到应用程序结束，如果静态变量中持有了具体页面的Context就会导致页面finish后Context不会被GC，这样就导致了内存泄露。  </li><li>非静态内部类导致的内存泄露。非静态内部类创建呢的Handle或Thread在执行延时操作时一直持有当前的Activity引用，这时候在Activity finish后就会导致内存泄漏。解决方式是使用静态内部类并用弱引用调用Activity；另外还可以在onDestroy中调用handler.removeCallbacksAndMessages取消所有事件消息。  </li><li>使用资源没有及时关闭。常见操作有：数据流操作完没有关闭、bitmap没及时Recycle等</li><li>三方的没及时接绑。EventBus（unregister）和Rxjava中（dispose）。  </li><li>动画执行导致的。在Activity finish时动画执行还在进行。解决就是在onDestroy时cacel动画。  </li><li>WebView导致的泄漏。 WebView即使调用了destroy也会导致内存泄漏。解决方式时使用弱引用WeekReference或者将WebView所在的Activity置于另外一个进程中。</li></ol><p>增加内存方案一般会在Application下添加largeHeap=”true”，活着新开进程来时应用的内存总空间增大。</p><ul><li>布局优化  16ms</li></ul><ol><li>使用RelativeLayout减少View层级</li><li>利用<include>抽离常用的布局</include></li><li>使用<viewstub>加载不常用的布局</viewstub></li><li>使用<merge>减少布局嵌套</merge></li><li>减少多余的背景绘制</li><li>canvas.clipRect()裁剪可见区域，其他区域就不会被多余绘制。</li></ol><ul><li>网络优化  </li></ul><ol><li>合理合并网络请求</li><li>网络缓存</li><li>大数据分页请求</li><li>网络数据传输压缩（Gzip）</li><li>图片压缩、缩略图</li></ol><ul><li>安装包优化<br>apk的构成：</li></ul><ol><li>assets文件夹：配置文件、资源文件 文件夹内的资源时通过AssetManager类内方法获取。  </li><li>res：资源文件，文件名会自动生成对应ID映射到.R文件中。  </li><li>META-INF：保存呢应用的签名信息，保证APK的完整性。  </li><li>AndroidManifest.xml：描述应用的配置信息。  </li><li>classes.dex：Dalvik虚拟机可执行的字节码文件，SDK下dx工具将JAVA字节码转化为Dalvik字节码。  </li><li>resources.arsc：资源文件和资源ID间的映射关系。  </li></ol><p>根据spk的构成做一下几方面的优化：  </p><ol><li>混淆：使用proGuard代码混淆工具，它包含了代码的压缩、优化、混淆等功能。  </li><li>资源优化：利用lint工具删除冗余代码，资源文件的最小化等。  </li><li>重复功能库：去除一些功能重复库的引用。  </li><li>插件化：功能模块放在服务器上，按需下载。<br>5.so库优化：保留v7版本，删除armeabi和v8版本的SO库，v7库可以按足市场上绝大多树手机的要求。</li></ol>]]></content>
    
    <summary type="html">
    
      Android基础
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Android动画分类</title>
    <link href="/2020/05/26/Android%E5%8A%A8%E7%94%BB%E5%88%86%E7%B1%BB/"/>
    <id>/2020/05/26/Android动画分类/</id>
    <published>2020-05-26T05:26:27.000Z</published>
    <updated>2020-05-26T07:04:55.073Z</updated>
    
    <content type="html"><![CDATA[<ul><li>帧动画<br>通过在xml中的一组图片的播放来实现。</li><li>补间动画<br>分为旋转、移动、缩放、透明度四类动画，以及他们的组合来实现动画效果。  </li><li><p>属性动画<br>属性动画目前使用场景最多，分类两种ViewPropertyAnimator和ObjectAnimator。前者是通用的动画，例如旋转、透明度、位移和缩放,简单通过View.animator()就可得到ViewPropertyAnimator。后者通过ObjectAnimator.of属性()来返回一个ObjectAnimator，ObjectAnimator需要重绘View所以要调用invalidate()来刷新绘制，最后通过start()方法启动动画。  </p></li><li><p>补间动画和属性动画的区别？</p></li></ul><p>补间动画只是在父VIew层利用Matrix不多绘制View，达到移动的效果，其实View并没有发生变化，还在动画之前的位置。<br>属性动画是真正改变了View的属性值，真正的改变View的具体属性值的。</p>]]></content>
    
    <summary type="html">
    
      Android基础
    
    </summary>
    
      <category term="Android基础" scheme="/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>TCP和UDP</title>
    <link href="/2020/05/25/TCP%E5%92%8CUDP/"/>
    <id>/2020/05/25/TCP和UDP/</id>
    <published>2020-05-25T09:18:41.000Z</published>
    <updated>2020-05-25T14:35:50.210Z</updated>
    
    <content type="html"><![CDATA[<ul><li>TCP（（Transmission Control Protocol，传输控制协议））</li></ul><p>TCP协议是面向连接、可靠的字节流传输服务。TCP协议在C/S间数据交换前，需要先在上方建立一个TCP连接，之后才开始传输数据，并提供超时、重发、丢弃重复数据、数据校验和流量控制等功能。<br>特点：<em>面向连接、可靠通信、面向字节流</em><br>应用层协议：HTTP、HTTPS、SSH、FTP、SMTP</p><ul><li>UDP（User Data Protocol，用户数据报协议）</li></ul><p>UDP是一个面向数据报的传输层协议，不具有可靠性，只是把数据发出去，不保证数据是否能到达S端。因为UDP在传输数据前不需要建立一个连接，所以它的传输效率很快，不能保证数据的可靠。<br>特点：<em>无连接、不可靠、面向数据报</em><br>应用层协议：DHCP、DNS</p><ul><li>TCP协议建立连接的三次握手</li></ul><p><img src="tcp_create_connection.jpg" alt=""></p><p><em>第一次握手</em>（请求建立连接）C端发送建立连接请求，携带序列号seq=x 标示SYN=1，此时C端处于SYN_SEND状态；<br><em>第二次握手</em>（确认请求）S端收到后，发出确认信息，确认信息ACK=x+1，同时携带自己的序列号SYN=1，seq=y；<br><em>第三次握手</em>（建立连接）C端收到S端的确认请求后，向S端发送确认ACK=y+1，S端收到请求后两端都处于Established状态，表示当前的一次TCP连接成功。</p><ul><li>TCP断开连接的四次挥手</li></ul><p><img src="tcp_finish_connection.jpg" alt=""></p><p><em>第一次挥手</em>（请求释放）C端发送释放连接的请求信号FIN=1，seq=u，此时C端处于FIN WAIT状态,不再发送数据给S端；<br><em>第二次挥手</em>（确认请求）S端收到释放请求后，发送确认收到请求释放，ACK=1,ack=u+1,此时S度啊处于CLOSE EAIT状态，不再接收C端数据，但是需要发送给C端的数据可继续发送；<br><em>第三次挥手</em>（确认释放）当S端不再有数据需要发送给C端时，发送却是释放连接，携带FIN=1，seq=w，ACK=1，ack=u+1，此时S端处于LAST ACK状态，等待C端的最终确认；<br><em>第四次挥手</em>（最终释放确认）当C端收到了确认释放后，随即发送最终释放确认，ACK=1，ack=w+1，seq=u+1；此时C端在等待2MSL后关闭连接，S端收到请求后同样关闭。</p><ul><li><p>为什么需要三次握手？<br>如果是两次握手，服务端确认请求后，不知道客户端是否能收到了消息，服务端的消息得不到确认。(服务端消息等不到确认)<br>如果客户端发送的请求网络延迟了，超时后有客户端重新发起请求，倘若在重发请求正常进行完毕后，再收到之前网络拥塞的请求，再和服务端建立连接，这个时候就可能服务端一直等待，导致服务端连接资源浪费。  </p></li><li><p>为什么第三次握手是seq=x+1，而不是x+2？<br>从握手的规律可以看出来seq在确认请求中会变做确认表示即ack，ack会在seq值的基础上加1，<em>同时TCP规定，SYN不携带数据，但会消耗掉一个序列号，SYN=1时会消耗seq的一个值（即加1），第三次握手ACK=1、SYN不等于1，而ACK=1不消耗seq所以seq=x+1而不是x+2，挥手中FIN也和SYN一样</em></p></li><li><p>TCP建立连接后客户端出现故障会怎样？<br>服务端有个计数器，一般两小时，两小时如果没有收到任何数据，会发送探测报文段，发了几个报文段如果还是没反应，服务端就会关闭连接。</p></li></ul>]]></content>
    
    <summary type="html">
    
      计算机网络
    
    </summary>
    
      <category term="计算机网络" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP、HTTPS和HTTP2.0</title>
    <link href="/2020/05/23/HTTP%E3%80%81HTTPS%E5%92%8CHTTP2-0/"/>
    <id>/2020/05/23/HTTP、HTTPS和HTTP2-0/</id>
    <published>2020-05-23T10:14:51.000Z</published>
    <updated>2020-05-25T09:18:10.142Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="什么是http">* 什么是HTTP</span></h3><p>HTTP（HyperText Transfer Protocol）中文全名超文本传输协议，HTTP是用于客户端与服务器间请求响应的协议。HTTP是应用层的协议，和其他该层协议一样，它是服务于某一类具体应用的协议。</p><h3><span id="什么是httpshyper-text-transfer-protocol-over-securesocket-layer">* 什么是HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer）</span></h3><p>HTTPS是在HTTP的基础上加上了SSL/TLS层<br>TLS（Transport Layer Security，传输层安全协议）、SSL(Secure Sockets Layer 安全套接层)</p><p>SSL由NetScape公司设计，共有三个版本1、2、3。SSL 3.0得到大规模使用，而TLS是SSL标准化后的升级版</p><p>SSL/TLS握手阶段工作流程：  </p><p><img src="https.jpg" alt=""></p><ol><li><p>客户端向服务端发出加密通信请求(ClientHello)</p><blockquote><p>携带支持的协议，例如TLS 1.0版<br>客户端生成的随机数random1，后面用于生成“对话密钥”<br>支持的加密方法，比如RSA公钥加密<br>支持的压缩的方法  </p></blockquote></li><li><p>服务端收到请求，做出响应(ServerHello)</p><blockquote><p>确认加密通信协议，例如TLS 1.0版。如果协议与服务端支持的不一致，则关闭加密通信。<br>服务端生成一个随机数random2，后面用于生成“对话密钥”<br>确认加密方法，例如RSA公钥加密<br>携带服务端证书给客户端  </p></blockquote></li><li><p>客服端做证书验证和公钥对随机数加密发送给服务端(ClientResponse)</p><blockquote><p>验证证书的安全性<br>验证通过后，客户端生成随机数pre-master secret，然后使用证书中的公钥进行加密，发送给服务端  </p></blockquote></li><li><p>服务端私钥解密获得随机数(ServerResponse)</p><blockquote><p>服务端收到公钥加密的内容，在服务端使用私钥解密后得到pre-master secret，然后根据random1、random2和pre-master secret通过一定的算法得出对称加密的秘钥，作为后面交互过程中的对称密钥。同时客户端也使用random1、random2和pre-master secret，同样的算法生成对称密钥。  </p></blockquote></li><li>后续操作使用上一步生成的对称密钥对传输的内容加密和解密。</li></ol><p>如何保证公钥不被篡改？</p><blockquote><p>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p></blockquote><p>什么是对称加密？</p><blockquote><p>加密和解密用的都是相同的密钥，优点是速度快，缺点是安全性低，常见的对称加密DES、AES等</p></blockquote><p>什么是非对称加密？</p><blockquote><p>非对称加密由一对密钥对，分为公钥和私钥。一般私钥自己持有，公钥可以公开给对方，优点是安全性比对称密钥高，缺点是数据传输效率比对称密钥低。采用公钥加密的数据只能由对应的私钥来解密。常见的非对称加密算法RSA。</p></blockquote><p><em>HTTPS在传输过程中采用了对称加密和非对称加密结合使用，使用非对称加密传递密钥，然后使用对称密钥进行数据传输的加密和解密。二者的结合既保证了传输的安全性，也保证了数据传输的效率</em></p><h3><span id="http-20">* HTTP 2.0</span></h3><ol><li>（二进制格式）HTTP 2.0采用二进制格式传输，而HTTP1.x使用纯文本的形式传输数据</li><li>（Header压缩）HTTP 2.0对已经发送的Header使用键值对建立索引表（两端维护的索引表），相同的Header使用索引表示，即Header压缩。</li><li>（服务器推送）服务端可以进行主动推送  </li><li>（多路复用）一个TCP连接被划分为多个流，客户端借助流和服务端建立全双工通信，且流具有优先级。</li></ol>]]></content>
    
    <summary type="html">
    
      计算机网络
    
    </summary>
    
      <category term="计算机网络" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="/2020/05/22/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>/2020/05/22/HTTP状态码/</id>
    <published>2020-05-22T11:47:10.000Z</published>
    <updated>2020-05-22T12:47:04.911Z</updated>
    
    <content type="html"><![CDATA[<p>状态码分类：</p><table><thead><tr><th>码</th><th>类别</th><th>原因  </th></tr></thead><tbody><tr><td>1xx</td><td>Information（信息性状态码）</td><td>接受的请求正在处理 </td></tr><tr><td>2xx</td><td>Success（成功状态码）</td><td>请求正常处理完成 </td></tr><tr><td>3xx</td><td>Redirection</td><td>需要进行附加操作来完成请求 </td></tr><tr><td>4xx</td><td>Client Error（客户端错误）</td><td>客户端请求出错，服务端无法处理 </td></tr><tr><td>5xx</td><td>Server Error（服务端出错）</td><td>服务端处理请求出错</td></tr></tbody></table><ul><li>200 OK</li></ul><p>客户端发送给服务器的请求<em>正常处理并返回</em>。</p><ul><li>204 No Content</li></ul><p>客户端发送给服务端的请求被服务端成功处理，但是在返回的相应报文中没有实体内容（也就是没有资源返回）。 </p><ul><li>206 Patail Content</li></ul><p>客户端进行了<em>范围请求（响应报文中Content-Range制定了范围的实体）</em>，并且服务器成功执行了这部分的GET请求。</p><ul><li>301 Moved Permanly</li></ul><p><em>请求被永久性重定向</em>，表示请求的资源已经被分配到了新的URI，在今后的请求中使用那个新的URI。可以通过这个响应代码来防止由于URI变更而导致老URI失效。</p><ul><li>302 Found</li></ul><p><em>请求临时性重定向</em>，表示请求希望使用新的URI</p><ul><li>303 See Other</li></ul><p>当前的请求的响应在另外一个URI上被找到，并且客户端应当采用GET请求访问那个资源。</p><ul><li>304 Not Modified</li></ul><p>客户端发送了一个带条件（if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一）的GET请求且已被允许，而资源内容并未被修改过，则服务端返回该错误码。</p><ul><li>307 Temporary Redirect</li></ul><p>临时性重定向，与3030类似，但是这里会准照浏览器标准执行。</p><ul><li>400 Bad Request</li></ul><p><em>当前请求存在语法错误</em></p><ul><li>401 Unauthorized</li></ul><p>未经许可，请求身份验证。</p><ul><li>403 Forbidden</li></ul><p>服务器拒绝访问（访问权限出现问题）</p><ul><li>404 Not Found</li></ul><p><em>服务器找不到请求的资源。</em></p><ul><li>500 Inter Server Error</li></ul><p>服务器在执行请求是发生了错误。</p><ul><li>503 Server Unavailable</li></ul><p>服务不可用，服务器由于超载或停机维护，无法处理请求。</p>]]></content>
    
    <summary type="html">
    
      计算机网络
    
    </summary>
    
      <category term="计算机网络" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>OSI网络模型</title>
    <link href="/2020/05/22/OSI%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <id>/2020/05/22/OSI网络模型/</id>
    <published>2020-05-22T09:11:03.000Z</published>
    <updated>2020-05-22T11:35:02.983Z</updated>
    
    <content type="html"><![CDATA[<p><img src="osi.jpg" alt=""></p><p>OSI（Open System Interconnection）全称开放系统互联，它把网络通信的工作分为7层，包括应用层、表现层、会话层、传输层、网络层、数据链路层和物理层。传输层、网络层、数据链路层和物理层叫做低四层，这四层和数据的移动相关。应用层、表现层和会话层叫做高三层，包含了应用程序级别的数据，每一层负责具体的一项工作将数据想向下一层传送。</p><ul><li>应用层</li></ul><p>应用层就是为了满足应用进程间的通信和交互任务。该层的协议有HTTP、HTTPS、FTP、POP3、SMTP等</p><ul><li>表现层</li></ul><p>表现层提供数据的编码和转换功能。数据的压缩和解压缩，加密和解密等工作都是在表现层完成。</p><ul><li>会话层</li></ul><p>会话层提供访问验证和会话管理在内的建立和维护应用间通信的机制，例如服务器验证用户登陆便由会话层完成。</p><ul><li>传输层</li></ul><p>传输层主要负责建立端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务。<em>端口号即是这里的端，TCP和UDP就是这层的协议</em></p><ul><li>网络层</li></ul><p>网络层的任务是选择合适的网间路由和交换结点，确保数据及时传送。</p><ul><li>数据链路层</li></ul><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测（也就是帧编码和误差纠错的功能）。数据链路层协议又分为两个子层：逻辑链路控制（LLC）和媒体访问控制（MAC）。</p><ul><li>物理层</li></ul><p>信号的最终传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>]]></content>
    
    <summary type="html">
    
      计算机网络
    
    </summary>
    
      <category term="计算机网络" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList和LinkedList</title>
    <link href="/2020/05/21/ArrayList%E5%92%8CLinkedList/"/>
    <id>/2020/05/21/ArrayList和LinkedList/</id>
    <published>2020-05-21T06:16:27.000Z</published>
    <updated>2020-05-21T12:08:07.746Z</updated>
    
    <content type="html"><![CDATA[<ul><li>源码分析</li></ul><ol><li>ArrayList  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">     * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure><p>ArrayList内部实现元素是放在elementData的数组中的，并且默认数组是空的，当增加元素时才扩展到DEFAULT_CAPACITY，这里DEFAULT_CAPACITY的值时10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">     *         is negative</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ArrayList的构造函数有三个，一个无参的设置空数组，有参的一个传入容量初始化数组，另外一个通过Collection对象对数组初始化赋值。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment">     * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment">     * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum size of array to allocate.</span></span><br><span class="line"><span class="comment">     * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment">     * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment">     * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">     * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>add方法中主要的调用是ensureCapacityInternal方法，ensureCapacityInternal方法主要做了一个扩容的处理，这里容器的最小值被赋予了DEFAULT_CAPACITY，也就是10，扩容的处理在grow方法中完成，这里看到新容量的大小等于老容量加上老容量的一半，也就是新容量在老容量的基础上再增加它的一半。后面对数组进行重新创建和赋值。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">     * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment">     * indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the element that was removed from the list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment">     * if it is present.  If the list does not contain the element, it is</span></span><br><span class="line"><span class="comment">     * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span></span><br><span class="line"><span class="comment">     * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment">     * changed as a result of the call).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>remove方法比较简单入参是索引的通过索引找到数组中的元素，通过本地方法System.arraycopy将index+1的元素赋值到索引从index到size-1，这里就相当于对index后面的元素进行了向前移位的操作。<br>如果入参是元素o就通过遍历找到它的索引然后再根据它的索引进行remove。  </p><p><em>这里modCount变量是一个叫做fail-fast的机制，就是当我们对ArrayList元素进行一些操作时，若果又有其他线程对其内容进行修改时，可以第一时间通过modCount的值来判定，当再操作中modCount值不一值就抛出ConcurrentModificationException，也表明ArrayList是线程不安全的</em></p><p>这里get方法就不再赘余，因为ArrayList这里时数组，可以通过下标方便的查找，ArrayList实现RandomAccess接口，作为一种标示说明它的访问时随机的</p><ol start="2"><li>LinkedList  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Pointer to first node.</span></span><br><span class="line"><span class="comment">    * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">    *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Pointer to last node.</span></span><br><span class="line"><span class="comment">    * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">    *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedList的内部实现使用双向链表来存储元素的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends all of the elements in the specified collection to the end of</span></span><br><span class="line"><span class="comment"> * this list, in the order that they are returned by the specified</span></span><br><span class="line"><span class="comment"> * collection's iterator.  The behavior of this operation is undefined if</span></span><br><span class="line"><span class="comment"> * the specified collection is modified while the operation is in</span></span><br><span class="line"><span class="comment"> * progress.  (Note that this will occur if the specified collection is</span></span><br><span class="line"><span class="comment"> * this list, and it's nonempty.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts all of the elements in the specified collection into this</span></span><br><span class="line"><span class="comment"> * list, starting at the specified position.  Shifts the element</span></span><br><span class="line"><span class="comment"> * currently at that position (if any) and any subsequent elements to</span></span><br><span class="line"><span class="comment"> * the right (increases their indices).  The new elements will appear</span></span><br><span class="line"><span class="comment"> * in the list in the order that they are returned by the</span></span><br><span class="line"><span class="comment"> * specified collection's iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which to insert the first element</span></span><br><span class="line"><span class="comment"> *              from the specified collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数有两个，有参的Collection元素集构造函数中调用addAll方法，addAll方法中通过遍历增加链表元素。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Links e as last element.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">       last = newNode;</span><br><span class="line">       <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">           first = newNode;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           l.next = newNode;</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>add方法中主要调用linkLast方法，新建新增的Node元素，Node元素prev变量之前当前的last，next为null，然后找last.next指向newNode。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.  Shifts any</span></span><br><span class="line"><span class="comment"> * subsequent elements to the left (subtracts one from their indices).</span></span><br><span class="line"><span class="comment"> * Returns the element that was removed from the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unlinks non-null node x.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>remove主要通过两个方法实现，node方法通过index找到对应的Node元素，然后通过unlink方法链表重新链接，将x元素从链表中移除并置为null，以便GC回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法直接通过node方法遍历等到Node元素，然后Node.item拿到元素值。</p><ol start="3"><li>两者对比  </li></ol><h5><span id="1-arraylist内部是通过动态数组结构实现空间利用相对有损耗linkedlist内部是通过双向链表实现空间利用上不存在浪费因为元素的多少和链表长度是一致的">1    .ArrayList内部是通过动态数组结构实现，空间利用相对有损耗；LinkedList内部是通过双向链表实现，空间利用上不存在浪费，因为元素的多少和链表长度是一致的。</span></h5><h5><span id="2-arraylist因为是数组实现所以删除-插入操作相对较慢通过systemarraycopy本地方法完成存在元素移动但是它的查找操作可随机访问实现radomaccess接口linkedlist链表在删除-插入效率高不存在元素移动只需要改变目标元素的前驱和后继就可以实现">2. ArrayList因为是数组实现，所以删除、插入操作相对较慢（通过System.arraycopy本地方法完成，存在元素移动），但是它的查找操作可随机访问（实现RadomAccess接口）；LinkedList链表在删除、插入效率高，不存在元素移动，只需要改变目标元素的前驱和后继就可以实现。</span></h5>]]></content>
    
    <summary type="html">
    
      JAVA基础
    
    </summary>
    
      <category term="JAVA基础" scheme="/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础" scheme="/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java引用类型</title>
    <link href="/2020/05/19/java%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>/2020/05/19/java引用类型/</id>
    <published>2020-05-19T10:02:08.000Z</published>
    <updated>2020-05-19T10:44:58.306Z</updated>
    
    <content type="html"><![CDATA[<p>java引用类型分为四类：强引用、软引用、弱引用和虚引用。<br>强引用：就是我们最常用的直接new对象创建的引用，垃圾回收器将永远不会回收被引用的对象。内存不足的情况JVM会直接抛出OOM。<br>软引用（SoftReference）：软引用在内存不足的情况下会被垃圾回收器回收。软引用常被用在存储一些内存敏感的缓冲，例如网页缓冲、图片缓冲等。<br>弱引用（WeekReference）：弱引用的强度比软引用更弱一下，无论内存是否足够，只要当GC开始，被扫描到的弱引用的对象就会被回收。<br>虚引用（PhantomReference）：虚引用是最弱的一种引用关系。它随时可能被回收，并且对象是无法通过虚引用获取的。虚引用主要用来跟踪对象被GC回收的活动，当被虚引用修饰的对象在被回收时，JVM会把虚引用加入到与之关联的引用队列（ReferrenceQueue）中。</p>]]></content>
    
    <summary type="html">
    
      JAVA基础
    
    </summary>
    
      <category term="JAVA基础" scheme="/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础" scheme="/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="/2020/05/19/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>/2020/05/19/单例模式/</id>
    <published>2020-05-19T04:37:45.000Z</published>
    <updated>2020-05-19T05:35:15.924Z</updated>
    
    <content type="html"><![CDATA[<ul><li>懒汉式</li></ul><p>懒汉式是在调用时创建实例，用时间来换空间。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleTon instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(LazySingleTon.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重判断保证了原子性和可见性（synchronized），同时利用volatile来保证有序性，避免指令的重排。  </p><ul><li>饿汉式  </li></ul><p>饿汉式在类加载的时候就已经创建好对象，在使用时直接就可以拿到实例，标准的空间换时间。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon instance = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态内部类实现  </li></ul><p>当外部类加载时不会导致内部类的立即加载，只有当getInstance方法被调用时才会去加载内部类，实现了加载。因为类的加载只会加载一次，所以它时线程安全的。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticInnerSingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticInnerSingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTonHolde</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerSingleTon instance = <span class="keyword">new</span> StaticInnerSingleTon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerSingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleTonHolde.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举实现  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ESingleTon &#123;</span><br><span class="line">     single;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperate</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"singletonOperate"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      设计模式
    
    </summary>
    
      <category term="设计模式" scheme="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>final、finally和finalize</title>
    <link href="/2020/05/19/final%E3%80%81finally%E5%92%8Cfinalize/"/>
    <id>/2020/05/19/final、finally和finalize/</id>
    <published>2020-05-19T03:59:33.000Z</published>
    <updated>2020-05-19T04:07:24.104Z</updated>
    
    <content type="html"><![CDATA[<ul><li>final可以修饰类、方法和变量。修饰类代表这个类不可被继承。修饰方法表示该方法不可被重写。修饰变量表示该变量在赋值后不可改变。  </li><li>finally保证重点代码一定会被执行的一种机制。通常使用组合try-catch-finally。  </li><li>finalize是Object类的一个方法，当垃圾回收器将要回收对象所占内存之前被调用，这个方法来用保证来对象被回收前完成特定的资源回收。</li></ul>]]></content>
    
    <summary type="html">
    
      JAVA基础
    
    </summary>
    
      <category term="JAVA基础" scheme="/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础" scheme="/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>线程间通信方式</title>
    <link href="/2020/05/15/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <id>/2020/05/15/线程间通信方式/</id>
    <published>2020-05-15T07:07:21.000Z</published>
    <updated>2020-05-16T10:44:23.995Z</updated>
    
    <content type="html"><![CDATA[<p>这里将线程间通信的途径分为两类：同享内存和消息传递。  </p><ul><li>同享内存</li></ul><ol><li>volatile关键字的使用</li></ol><p>就是利用volatile关键字的可见性，多个线程对它进行监控在其变量发生变化后执行对应线程的操作。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadCommunication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> STATE_RUN_A = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> STATE_RUN_B = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> STATE_RUN_C = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> state = STATE_RUN_A;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//这里睡眠3s等待BC线程</span></span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> c = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (state == STATE_RUN_A) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"threadA is running!"</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                            state = STATE_RUN_B;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (state == STATE_RUN_B) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"threadB is running!"</span>);</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            counter = counter &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">while</span> (counter &lt; <span class="number">1</span> &lt;&lt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">                        state = STATE_RUN_C;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (state == STATE_RUN_C) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"threadC is running!"</span>);</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            counter = counter &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">while</span> (counter &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"threadC finish counter："</span> + counter);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="thread_communication_volatile.jpg" alt=""></p><ul><li>消息传递</li></ul><ol><li>Object.wait()\notify()</li></ol><p>在线程中调用该线程锁对象是wait方法是，该线程就被放入等待队列，直到被其他线程通知notify。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadCommunication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"threadB is running!"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            counter = counter &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">while</span> (counter &lt; <span class="number">1</span> &lt;&lt; <span class="number">4</span>);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (counter == <span class="number">1</span> &lt;&lt; <span class="number">4</span>) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"threadC is running!"</span>);</span><br><span class="line">                            <span class="keyword">do</span> &#123;</span><br><span class="line">                                counter = counter &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                            &#125; <span class="keyword">while</span> (counter &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                            System.out.println(<span class="string">"threadC finish counter："</span> + counter);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                lock.wait();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadC.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="thread_communication_wait.jpg" alt=""></p><ol start="2"><li>.join() {Thread.join}</li></ol><p>当一个线程调用另外一个线程的join方法时，当前的线程就会阻塞等待被调用join方法的线程执行完毕后才能继续执行，所以join方法用来保证线程执行的顺序。  </p><ol start="3"><li>CountDownLatch类</li></ol><p>CountDownLatch类可以使线程等待其他线程执行完毕后再执行。<br>通过一个计数器来实现，CountDownLatch初始化传入的count代表等待count个线程执行完毕后等待的线程才能恢复执行。一般有几个应用场景：<br>场景一：<br>有多个线程依赖其他多个线程的执行完的结果，这是等待的await，被等待的线程执行完调用coutdown然后计数器减一，直到减为0就恢复多个线程的执行；<br>场景二：<br>实现多个线程同时执行，多个线程都设置await coutdown设置为1 在主线程中调用countdown让多个线程同时执行运行。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadCommunication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"threadA await"</span>);</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"threadA is running!"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="string">"threadB is running!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        counter = counter &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                        System.out.println(<span class="string">"threadC is running! counter="</span> + counter);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">while</span> (counter &lt; <span class="number">1</span> &lt;&lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="thread_communication_counntdownlatch.jpg" alt=""></p><ol start="4"><li>LockSupport类<br>LockSupport是JDK中用来实现线程阻塞和唤醒的工具。使用它可以在任何场合使线程阻塞，可以指定任何线程进行唤醒。<br>LockSupport的设计核心是“许可”，park是等待一个许可，unpark是为某一线程提供一种许可，如果某线程A调用park，那么除非另外一个线程调用unpark(A)给A一个许可，否则线程A将阻塞在park操作上。还有就是unpark可以在park前调用，也就是先提供许可，等到后面调用park时在消耗之前的许可。  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadCommunication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"threadA park"</span>);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(<span class="string">"threadA is running!"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"threadB park"</span>);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(<span class="string">"threadB is running!"</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"threadB unpark threadA"</span>);</span><br><span class="line">                LockSupport.unpark(threadA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"main thread unpark threadB"</span>);</span><br><span class="line">        LockSupport.unpark(threadB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="thread_communication_locksupport.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      JAVA基础
    
    </summary>
    
      <category term="JAVA基础" scheme="/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础" scheme="/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA线程池的使用</title>
    <link href="/2020/05/15/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>/2020/05/15/JAVA线程池的使用/</id>
    <published>2020-05-15T03:57:33.000Z</published>
    <updated>2020-05-16T10:46:37.786Z</updated>
    
    <content type="html"><![CDATA[<ul><li>线程池的作用  </li></ul><ol><li>线程池可以有效控制系统内执行线程的数量；</li><li>根据系统的状况可以手动或自动调整执行线程的数量，让其他线程排队等候；  </li><li>线程池可以有效减少线程创建和销毁的次数，使得线程可以复用，可以执行多任务。  </li></ol><ul><li>JAVA中常用的线程池  </li></ul><ol><li>newSingleThreadExecutor()<br>创建一个单线程的线程池，线程池中只有一个线程在工作（相当于单线程串行执行所有任务）。如果唯一的线程异常结束，将会创建一个新的线程来代替，同时任务按照队列顺序执行。<br>方法解释：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executors.newSingleThreadExecutor()</span></span><br><span class="line"><span class="comment">     * Creates an Executor that uses a single worker thread operating</span></span><br><span class="line"><span class="comment">     * off an unbounded queue.</span></span><br><span class="line"><span class="comment">     * 使用单操作线程创建一个没有限制队列的Executor</span></span><br><span class="line"><span class="comment">     *  (Note however that if this single</span></span><br><span class="line"><span class="comment">     * thread terminates due to a failure during </span></span><br><span class="line"><span class="comment">     * execution prior toshutdown, a new one will </span></span><br><span class="line"><span class="comment">     * take its place if needed to execute</span></span><br><span class="line"><span class="comment">     * subsequent tasks.)</span></span><br><span class="line"><span class="comment">     * 但是请注意，如果该单线程由于在关机之前执行期间失败而终</span></span><br><span class="line"><span class="comment">     * 止，则在执行后续任务时需要使用一个新线程。</span></span><br><span class="line"><span class="comment">     * Tasks are guaranteed to execute</span></span><br><span class="line"><span class="comment">     * sequentially, and no more than one task will </span></span><br><span class="line"><span class="comment">     * be active at any given time. </span></span><br><span class="line"><span class="comment">     * 确保任务按顺序执行，并且在任何给定时间都不会激活一项以上</span></span><br><span class="line"><span class="comment">     * 的任务。</span></span><br><span class="line"><span class="comment">     * Unlike the otherwise equivalent</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> newFixedThreadPool(1)&#125; the returned </span></span><br><span class="line"><span class="comment">     * executor is guaranteed not to be </span></span><br><span class="line"><span class="comment">     * reconfigurable to use additional threads.</span></span><br><span class="line"><span class="comment">     *与其他等效的&#123;<span class="doctag">@code</span> newFixedThreadPool（1）&#125;不同，保</span></span><br><span class="line"><span class="comment">     证返回的执行程序不可重新配置为使用其他线程。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created single-threaded Executor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>newFixedThreadPool(int nThreads)</li></ol><p>创建一个固定线程数量的线程池，每次提交的任务就创建一个线程，直到线程数量达到线程数量限制。其余多的任务进入等待队列，直到有空闲的线程。如果有线程异常结束，那么就会创建一个新的线程来代替它。<br>方法解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executors.newFixedThreadPool(int nThreads)</span></span><br><span class="line"><span class="comment">     * Creates a thread pool that reuses a fixed </span></span><br><span class="line"><span class="comment">     * number of threads operating off a shared </span></span><br><span class="line"><span class="comment">     * unbounded queue.</span></span><br><span class="line"><span class="comment">     * 创建一个线程池，该线程池重用在共享的无边界队列上运行的固</span></span><br><span class="line"><span class="comment">     * 定数量的线程。</span></span><br><span class="line"><span class="comment">     * Atany point, at most&#123;<span class="doctag">@code</span> nThreads&#125; threads </span></span><br><span class="line"><span class="comment">     * will be activeprocessing tasks.</span></span><br><span class="line"><span class="comment">     * 无论何时，最多&#123;<span class="doctag">@code</span> nThreads&#125;个线程都是活动处理任</span></span><br><span class="line"><span class="comment">     * 务。</span></span><br><span class="line"><span class="comment">     * If additional tasks are submitted when all </span></span><br><span class="line"><span class="comment">     * threads are active,they will wait in the queue</span></span><br><span class="line"><span class="comment">     *  until a thread is available.</span></span><br><span class="line"><span class="comment">     *  如果在所有线程都处于活动状态时提交了其他任务，则它们将</span></span><br><span class="line"><span class="comment">     *  在队列中等待，直到某个线程可用为止。</span></span><br><span class="line"><span class="comment">     * If any thread terminates due to a failure </span></span><br><span class="line"><span class="comment">     * during execution prior to shutdown, a new one </span></span><br><span class="line"><span class="comment">     * will take itsplace if needed to execute </span></span><br><span class="line"><span class="comment">     * subsequent tasks.</span></span><br><span class="line"><span class="comment">     * 如果在关闭之前执行过程中由于执行失败导致任何线程终止，则</span></span><br><span class="line"><span class="comment">     * 在执行后续任务时将替换一个新线程。</span></span><br><span class="line"><span class="comment">     * The threads in thepool will exist</span></span><br><span class="line"><span class="comment">     * until it is explicitly &#123;<span class="doctag">@link</span> </span></span><br><span class="line"><span class="comment">     * ExecutorService#shutdown shutdown&#125;.</span></span><br><span class="line"><span class="comment">     *这个线程在池中将一直存在知道明确的shutdown。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nThreads the number of threads in the </span></span><br><span class="line"><span class="comment">     * pool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> </span></span><br><span class="line"><span class="comment">     * nThreads &lt;= 0&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>newCachedThreadPool()</li></ol><p>创意一个可以缓冲的线程池，如果当前线程数超出了执行任务的数量，那么在等待60s无新任务的情况下结束掉。当任务数量增加的情况下，线程池又会自动增加线程数量。线程池对线程的数量没有做限制。<br>方法解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executors.newCachedThreadPool()</span></span><br><span class="line"><span class="comment">     * Creates a thread pool that creates new threads </span></span><br><span class="line"><span class="comment">     * as needed, but</span></span><br><span class="line"><span class="comment">     * will reuse previously constructed threads when </span></span><br><span class="line"><span class="comment">     * they are available.  </span></span><br><span class="line"><span class="comment">     * 创建一个线程池，该线程池根据需要创建新线程，但是将在先前</span></span><br><span class="line"><span class="comment">     * 构造的线程可用时重用它们。</span></span><br><span class="line"><span class="comment">     * These pools will typically improve the </span></span><br><span class="line"><span class="comment">     * performance of programs that execute many </span></span><br><span class="line"><span class="comment">     * short-lived asynchronous tasks.</span></span><br><span class="line"><span class="comment">     * 这些池通常将提高执行许多短期异步任务的程序的性能。</span></span><br><span class="line"><span class="comment">     * Calls to &#123;<span class="doctag">@code</span> execute&#125; will reuse previously </span></span><br><span class="line"><span class="comment">     * constructed threads if available. </span></span><br><span class="line"><span class="comment">     * 调用&#123;<span class="doctag">@code</span> execute&#125;将重用之前构造的可重用的线程</span></span><br><span class="line"><span class="comment">     * If no existing thread is available, a new</span></span><br><span class="line"><span class="comment">     * thread will be created and added to the pool. </span></span><br><span class="line"><span class="comment">     * 如果不存在可重用的线程，那么一个新的线程将会被创建并添加</span></span><br><span class="line"><span class="comment">     * 到池中。</span></span><br><span class="line"><span class="comment">     * Threads that have not been used for sixty </span></span><br><span class="line"><span class="comment">     * seconds are terminated and removed from the</span></span><br><span class="line"><span class="comment">     * cache. </span></span><br><span class="line"><span class="comment">     * 六十秒内未使用的线程将终止并从缓存中删除。</span></span><br><span class="line"><span class="comment">     *  Thus, a pool that remains idle for </span></span><br><span class="line"><span class="comment">     * long enough will not consume any resources. </span></span><br><span class="line"><span class="comment">     * 因此，一个保持足够长的池也不会消耗任何资源。</span></span><br><span class="line"><span class="comment">     * Note that pools with similar properties but </span></span><br><span class="line"><span class="comment">     * different details (for example, timeout </span></span><br><span class="line"><span class="comment">     * parameters) may be created using &#123;<span class="doctag">@link</span> </span></span><br><span class="line"><span class="comment">     * ThreadPoolExecutor&#125; constructors.</span></span><br><span class="line"><span class="comment">     *请注意，可以使用&#123;<span class="doctag">@link</span> ThreadPoolExecutor&#125;构造函数创</span></span><br><span class="line"><span class="comment">     建具有相似属性但不同详细信息（例如，超时参数）的池。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      JAVA基础
    
    </summary>
    
      <category term="JAVA基础" scheme="/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础" scheme="/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>关键字volatile和synchronized</title>
    <link href="/2020/05/13/%E5%85%B3%E9%94%AE%E5%AD%97volatile%E5%92%8Csynchronized/"/>
    <id>/2020/05/13/关键字volatile和synchronized/</id>
    <published>2020-05-13T03:51:19.000Z</published>
    <updated>2020-06-08T06:30:35.736Z</updated>
    
    <content type="html"><![CDATA[<p>volatile ：ˈvälətl<br>synchronized ：ˈsiNGkrəˌnaīzd</p><ul><li>JAVA内存模型（JAVA Memory Model JMM）  </li></ul><p>JAVA内存模型定义了程序中各个变量的访问规则，即JVM将共享变量从内存存取的底层细节。<br><em>主内存是线程共享的区域例如堆和方法区，而工作内存实现线程私有的，例如PC寄存器、虚拟机栈</em><br>JMM规定所有共享变量都存储在主内存中，每条线程拥有自己的工作内存（比作缓冲区的概念），线程的工作内存中保存了主内存变量的拷贝副本。线程对共享变量的操作都在工作内存中进行，工作内存在线程是私有的，其他线程无法访问，变量的传递都是通过主内存来完成。   </p><p><img src="java_memory_model.jpg" alt=""></p><p>主内存与工作内存同步的中操作：  </p><ol><li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程的独占状态；  </li><li>unlock（解锁）：作用于主内存的变量，将一个变量从lock状态解锁，释放出来的该变量才能被其他线程lock；  </li><li>read（读取）：作用于主内存的变量，将一个变量的值从主内存传输大工作内存，以便于后面的load操作使用；  </li><li>load（载入）：作用于工作内存，把read操作从主内存得到的变量值放到工作内存的变量副本中；  </li><li>use（使用）：作用于工作内存的变量，把一个工作内存中的变量值传递给执行引擎，当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作；  </li><li>assign（赋值）：作用于工作内存的变量，把一个从执行引擎收到的值赋值给工作内存的变量，当虚拟机遇到一个需要给变量赋值的字节码指令时就会执行该操作；  </li><li>store（存储）：作用于工作内存的变量，把一个工作内存中的变量的值传送到主内存中，以便于随后的write操作；  </li><li>write（写入）：作用于主内存的变量，把store操作从工作内存中的一个变量的值传送到主内存的变量中。  </li></ol><p>3个特性：<br>1.原子性（Atomicity）：原子代表不可分割的最小单位。原子性指一个操作或多个操作要么全部执行，要么就都不执行。例如银行转账操作 A账户减去10000元和B账户增加10000元必须全部执行，否则就会出现错误，这两个操作不可再分割。<br>read、load、use、assign、store、write操作都保证了原子性的操作，基本数据类型的读取大致都具有原子性。更大范围保证原子性JMM提供了lock和unlock操作，JVM提供了更高层次的字节码指令monitorenter和monitorexit来隐式使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。<br>2.可见性（Visibility）：一个线程中堆共享变量（类中的成员变量或静态变量）的修改，其他线程立即得知这个修改。<br>保证可见性的操作：<br>volatile：volatile的特殊规则保证了新值立即同步到主内存中，以及每次使用前立即从主内存中刷新。<br>synchronized：synchronized关键字在释放锁之前，必须到此变量同步回主内存中（执行了store、write操作）。<br>final：final修饰的变量，一旦完成初始化，其他线程就能看见final字段的值。<br>3.有序性（Orderly）：有序性主要涉及了指令重排序现象和“工作内存与主内存同步延迟”现象。总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。<br>为了执行的效率，有时候会发生指令重排，这在单线程中指令重排之后的输出与我们的代码逻辑输出还是一致的。但在多线程中就可能发生问题，volatile在一定程度上可以避免指令重排。</p><ul><li><p>volatile和synchronized  </p><blockquote><p>synchronized保证了原子性和可见性，JMM中synchronized块执行流程清空工作内存-&gt;在主内存中拷贝变量值到工作内存的副本中-&gt;执行完代码-&gt;将更新后的共享变量值刷新到主内存中-&gt;释放同步锁<br>volatile保证了可见性和有序性。线程中volatile修饰的变量对其他线程共享变量的修改是可立即看见的。有序性上volatile可以一定程度避免指令重排，volatile在生成指令上回家一个lock前缀，这个前缀相当于内存屏障可以避免指令重排序不能把后面的指令重排序到内存屏障之前的位置。<br>synchronized作用于代码块和方法，而volatile是变量修饰符。<br>volatile不会造成线程的阻塞,而synchronized可能会造成线程阻塞。  </p></blockquote></li><li><p>synchronized用法<br>1.（普通class）当一个线程访问对象中的synchronized(this)同步代码块时，其他试图访问这个对象的synchronized(this)同步代码块的线程将被阻塞。  </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">(String threadName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> counter = <span class="number">0</span>; counter &lt; <span class="number">5</span>; counter++) &#123;</span><br><span class="line">                    System.out.println(threadName + <span class="string">" counter is"</span> + counter);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.runTest(<span class="string">"threadA"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.runTest(<span class="string">"threadB"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br></pre></td></tr></table></figure><blockquote><p>threadA counter is0<br>threadA counter is1<br>threadA counter is2<br>threadA counter is3<br>threadA counter is4<br>threadB counter is0<br>threadB counter is1<br>threadB counter is2<br>threadB counter is3<br>threadB counter is4</p></blockquote><p>2.当一个线程访问对象的synchronized(this)代码块时，其他线程可以访问该对象的其他非同步代码块。  </p><p>3.当一个线程访问对象的synchronized(obj)代码块时,相当于给obj对象加了锁，那么访问其他试图访问obj对象的线程将会阻塞，直到该对象对obj的访问结束。synchronized(obj)可以理解为哪个线程拿到了obj的锁就可以访问同步代码块的代码。  </p><p>3.当synchronized修饰一个普通方法时，同步代码块对整个方法生效。<br>4.当synchronized修饰一个静态方法时，<em>同步锁生效的是整个类</em>。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">(String threadName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> counter = <span class="number">0</span>; counter &lt; <span class="number">5</span>; counter++) &#123;</span><br><span class="line">                System.out.println(threadName + <span class="string">" counter is"</span> + counter);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">       Test test2 = <span class="keyword">new</span> Test();</span><br><span class="line">       Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               test.runTest(<span class="string">"threadA test"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               test2.runTest(<span class="string">"threadB test2"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       threadA.start();</span><br><span class="line">       threadB.start();</span><br></pre></td></tr></table></figure><blockquote><p>threadA test counter is0<br>threadA test counter is1<br>threadA test counter is2<br>threadA test counter is3<br>threadA test counter is4<br>threadB test2 counter is0<br>threadB test2 counter is1<br>threadB test2 counter is2<br>threadB test2 counter is3<br>threadB test2 counter is4</p></blockquote><p>5.当synchronized修饰的是一个类时，场景与4相同，属于类锁。</p>]]></content>
    
    <summary type="html">
    
      JAVA基础
    
    </summary>
    
      <category term="JAVA基础" scheme="/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础" scheme="/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>join方法</title>
    <link href="/2020/05/13/join%E6%96%B9%E6%B3%95/"/>
    <id>/2020/05/13/join方法/</id>
    <published>2020-05-13T02:20:15.000Z</published>
    <updated>2020-05-16T10:47:12.448Z</updated>
    
    <content type="html"><![CDATA[<p>join()是用来保证线程间顺序调度的一个方法，是Thread类的方法。例如在ThreadA中执行了ThreadB.join(),此时ThreadA进入等待状态，直到ThreadB执行结束后才唤醒ThreadA继续执行后续的方法。<br>join()可传时间也可不传，传值下等待具体时间后唤醒，不传值要等到被调线程结束后唤醒。  </p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Package: com.litchi.demo.java</span></span><br><span class="line"><span class="comment"> * Date:    2020/5/13</span></span><br><span class="line"><span class="comment"> * Desc:    演示join方法调度线程执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liujicheng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoinTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"threadB run start"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//这里sleep为了让threadA开始执行</span></span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">1</span> &lt;&lt; <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">while</span> ((i = i &gt;&gt; <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"threadB run i="</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"threadB finish"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"threadA run start"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"threadA call threadB.join()"</span>);</span><br><span class="line">                    threadB.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"threadA continue"</span>);</span><br><span class="line">                System.out.println(<span class="string">"threadA continue"</span>);</span><br><span class="line">                System.out.println(<span class="string">"threadA finish"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="join_test_1.jpg" alt=""></p><p>如果不加join()的执行结果：<br><img src="join_test_2.jpg" alt=""></p><p><em>这里threadB.join()为什么去执行threadB，因为join()内部是用wait()实现的，所以这里把threadB看作是Object，Object.wait()就是操作当前线程去等待，也就是这里的threadB.join()使得threadA调用Object.wait()方法。</em></p><p>join()的内部实现原理其实是wait()  </p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Waits at most &#123;<span class="doctag">@code</span> millis&#125; milliseconds for this thread to</span></span><br><span class="line"><span class="comment">     * die. A timeout of &#123;<span class="doctag">@code</span> 0&#125; means to wait forever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; This implementation uses a loop of &#123;<span class="doctag">@code</span> this.wait&#125; calls</span></span><br><span class="line"><span class="comment">     * conditioned on &#123;<span class="doctag">@code</span> this.isAlive&#125;. As a thread terminates the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> this.notifyAll&#125; method is invoked. It is recommended that</span></span><br><span class="line"><span class="comment">     * applications not use &#123;<span class="doctag">@code</span> wait&#125;, &#123;<span class="doctag">@code</span> notify&#125;, or</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> notifyAll&#125; on &#123;<span class="doctag">@code</span> Thread&#125; instances.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">     *         the time to wait in milliseconds</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">     *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">     *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment">     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment">     *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>millis小于0抛出IllegalArgumentException异常；  </li><li>millis等于0循环isAlive()判断当前线程是否存活，存活就调用wait(0),把当前线程放入对象的等待集合中，直到对象线程结束才唤醒当前线程；  </li><li>millis大于0 循环isAlive()判断当前线程是否存活，存活就调用wait()传入等待时间，等到时间到后唤醒当前线程的执行。</li></ul>]]></content>
    
    <summary type="html">
    
      JAVA基础
    
    </summary>
    
      <category term="JAVA基础" scheme="/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础" scheme="/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>“sleep方法和wait方法”</title>
    <link href="/2020/05/12/sleep%E6%96%B9%E6%B3%95%E5%92%8Cwait%E6%96%B9%E6%B3%95/"/>
    <id>/2020/05/12/sleep方法和wait方法/</id>
    <published>2020-05-12T07:11:37.000Z</published>
    <updated>2020-05-16T10:47:54.555Z</updated>
    
    <content type="html"><![CDATA[<ul><li>sleep()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Causes the currently executing thread to sleep (temporarily cease</span></span><br><span class="line"><span class="comment">     * execution) for the specified number of milliseconds, subject to</span></span><br><span class="line"><span class="comment">     * the precision and accuracy of system timers and schedulers. The thread</span></span><br><span class="line"><span class="comment">     * does not lose ownership of any monitors.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">     *         the length of time to sleep in milliseconds</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">     *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">     *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment">     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment">     *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment">     * 根据系统计时器和调度程序的精度和准确性，使得当前的执行线程进入睡眠状态（暂时停止继续执行）达到指定的毫秒数。在这期间该线程不会失去任何所有权。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>sleep()是Thread类的静态方法。调用该方式使得当前线程进入指定毫秒数的睡眠状态，并且不会释放同步资源锁。sleep()需要catch InterruptedException，否则线程在被其他线程中执行对该线程的interrupt()方法，sleep()就会报InterruptedException 线程就会被终止。  </p><ul><li>wait()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Causes the current thread to wait until either another thread invokes the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> java.lang.Object#notify()&#125; method or the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> java.lang.Object#notifyAll()&#125; method for this object, or a</span></span><br><span class="line"><span class="comment">     * specified amount of time has elapsed.</span></span><br><span class="line"><span class="comment">     * 导致当前线程去等待，直到其他线程触发</span></span><br><span class="line"><span class="comment">     * java.lang.Object#notify()方法或者一个特定的时间值执</span></span><br><span class="line"><span class="comment">     * 行过去（设置的执行时间完成）</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The current thread must own this object's monitor.</span></span><br><span class="line"><span class="comment">     * 当前线程必须拥有该对象的监视器。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This method causes the current thread (call it &lt;var&gt;T&lt;/var&gt;) to</span></span><br><span class="line"><span class="comment">     * place itself in the wait set for this object and then to relinquish</span></span><br><span class="line"><span class="comment">     * any and all synchronization claims on this object. </span></span><br><span class="line"><span class="comment">     * 这个方法导致当前线程将自己放在一个对象的等待集中，并且放弃了任何的同步声明在当前对对象中。</span></span><br><span class="line"><span class="comment">     * Thread &lt;var&gt;T&lt;/var&gt;</span></span><br><span class="line"><span class="comment">     * becomes disabled for thread scheduling purposes and lies dormant</span></span><br><span class="line"><span class="comment">     * until one of four things happens:</span></span><br><span class="line"><span class="comment">     * 线程称为不可调度并处于休眠状态，直到一下四种状况发生：</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Some other thread invokes the &#123;<span class="doctag">@code</span> notify&#125; method for this</span></span><br><span class="line"><span class="comment">     * object and thread &lt;var&gt;T&lt;/var&gt; happens to be arbitrarily chosen as</span></span><br><span class="line"><span class="comment">     * the thread to be awakened.</span></span><br><span class="line"><span class="comment">     * 某些其他线程触发notify方法，对于当前对象和线程恰好被任</span></span><br><span class="line"><span class="comment">     * 意选择为要唤醒的线程。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Some other thread invokes the &#123;<span class="doctag">@code</span> </span></span><br><span class="line"><span class="comment">     * notifyAll&#125; method for this</span></span><br><span class="line"><span class="comment">     * object.</span></span><br><span class="line"><span class="comment">     * 某些其他线程触发notifyAll方法针对当前对象</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Some other thread &#123;<span class="doctag">@linkplain</span> </span></span><br><span class="line"><span class="comment">     * Thread#interrupt() interrupts&#125;</span></span><br><span class="line"><span class="comment">     * thread &lt;var&gt;T&lt;/var&gt;.</span></span><br><span class="line"><span class="comment">     * 某些其他线程触发了interrupts方法。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;The specified amount of real time has </span></span><br><span class="line"><span class="comment">     * elapsed, more or less.  If</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> timeout&#125; is zero, however, then real </span></span><br><span class="line"><span class="comment">     * time is not taken into</span></span><br><span class="line"><span class="comment">     * consideration and the thread simply waits </span></span><br><span class="line"><span class="comment">     * until notified.</span></span><br><span class="line"><span class="comment">     * 特定的时间大致过去。如果这个时间是0，则不考虑时间，线程</span></span><br><span class="line"><span class="comment">     * 只能等待通知</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * The thread &lt;var&gt;T&lt;/var&gt; is then removed from </span></span><br><span class="line"><span class="comment">     * the wait set for this</span></span><br><span class="line"><span class="comment">     * object and re-enabled for thread scheduling. </span></span><br><span class="line"><span class="comment">     * 这个线程然后从等待集中移除，并且重新能够被线程调度。</span></span><br><span class="line"><span class="comment">     * It then competes in the</span></span><br><span class="line"><span class="comment">     * usual manner with other threads for the right to synchronize on the</span></span><br><span class="line"><span class="comment">     * object; </span></span><br><span class="line"><span class="comment">     * 然后它与其他线程一样以通常的方式在对象上竞争同步的权利；</span></span><br><span class="line"><span class="comment">     * once it has gained control of the object, all </span></span><br><span class="line"><span class="comment">     * its synchronization claims on the object are</span></span><br><span class="line"><span class="comment">     *  restored to the status quo</span></span><br><span class="line"><span class="comment">     * ante - that is, to the situation as of the time that the &#123;<span class="doctag">@code</span> wait&#125;</span></span><br><span class="line"><span class="comment">     * method was invoked. </span></span><br><span class="line"><span class="comment">     * 一旦获得了对象的控制权，所有它的同步声明将恢复原状即调用方法是的情况。</span></span><br><span class="line"><span class="comment">     * Thread &lt;var&gt;T&lt;/var&gt; then returns from the</span></span><br><span class="line"><span class="comment">     * invocation of the &#123;<span class="doctag">@code</span> wait&#125; method. </span></span><br><span class="line"><span class="comment">     * 线程返回方法的调用。</span></span><br><span class="line"><span class="comment">     * Thus, on return from the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> wait&#125; method, the synchronization state of the object and of</span></span><br><span class="line"><span class="comment">     * thread &#123;<span class="doctag">@code</span> T&#125; is exactly as it was when the &#123;<span class="doctag">@code</span> wait&#125; method</span></span><br><span class="line"><span class="comment">     * was invoked.</span></span><br><span class="line"><span class="comment">     * 因此，从&#123;<span class="doctag">@code</span> wait&#125;方法返回时，对象和线程&#123;<span class="doctag">@code</span> T&#125;</span></span><br><span class="line"><span class="comment">     * 的同步状态与调用&#123;<span class="doctag">@code</span> wait&#125;方法时的状态完全相同。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * A thread can also wake up without being notified, interrupted, or</span></span><br><span class="line"><span class="comment">     * timing out, a so-called &lt;i&gt;spurious wakeup&lt;/</span></span><br><span class="line"><span class="comment">     * i&gt;.  </span></span><br><span class="line"><span class="comment">     * 线程也可以在不被通知，中断或中断的情况下唤醒</span></span><br><span class="line"><span class="comment">      *超时，即所谓的虚假唤醒。</span></span><br><span class="line"><span class="comment">     * While this will rarely</span></span><br><span class="line"><span class="comment">     * occur in practice, applications must guard </span></span><br><span class="line"><span class="comment">     * against it by testing for</span></span><br><span class="line"><span class="comment">     * the condition that should have caused the </span></span><br><span class="line"><span class="comment">     * thread to be awakened, and</span></span><br><span class="line"><span class="comment">     * continuing to wait if the condition is not </span></span><br><span class="line"><span class="comment">     * satisfied.  </span></span><br><span class="line"><span class="comment">     * 尽管在实践中这种情况很少发生，但是应用程序必须通过测试应</span></span><br><span class="line"><span class="comment">     * 该导致线程唤醒的条件来防范它，并在条件不满足时继续等待。</span></span><br><span class="line"><span class="comment">     * In other words,</span></span><br><span class="line"><span class="comment">     * waits should always occur in loops, like this </span></span><br><span class="line"><span class="comment">     * one:</span></span><br><span class="line"><span class="comment">     * 换句话说，等待应该总是在循环中发生，就像这样：</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *     synchronized (obj) &#123;</span></span><br><span class="line"><span class="comment">     *         while (&amp;lt;condition does not hold&amp;gt;)</span></span><br><span class="line"><span class="comment">     *             obj.wait(timeout);</span></span><br><span class="line"><span class="comment">     *         ... // Perform action appropriate to condition</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * (For more information on this topic, see Section 3.2.3 in Doug Lea's</span></span><br><span class="line"><span class="comment">     * "Concurrent Programming in Java (Second Edition)" (Addison-Wesley,</span></span><br><span class="line"><span class="comment">     * 2000), or Item 50 in Joshua Bloch's "Effective Java Programming</span></span><br><span class="line"><span class="comment">     * Language Guide" (Addison-Wesley, 2001).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the current thread is &#123;<span class="doctag">@linkplain</span> java.lang.Thread#interrupt()</span></span><br><span class="line"><span class="comment">     * interrupted&#125; by any thread before or while it is waiting, then an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> InterruptedException&#125; is thrown. </span></span><br><span class="line"><span class="comment">     * 如果当前线程被任何其他线程中断则将会抛出</span></span><br><span class="line"><span class="comment">     * InterruptedException</span></span><br><span class="line"><span class="comment">     *  This exception is not</span></span><br><span class="line"><span class="comment">     * thrown until the lock status of this object has been restored as</span></span><br><span class="line"><span class="comment">     * described above.</span></span><br><span class="line"><span class="comment">     * 上述的异常在对象锁定状态恢复之前不会发生。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note that the &#123;<span class="doctag">@code</span> wait&#125; method, as it </span></span><br><span class="line"><span class="comment">     * places the current thread</span></span><br><span class="line"><span class="comment">     * into the wait set for this object, unlocks </span></span><br><span class="line"><span class="comment">     * only this object; </span></span><br><span class="line"><span class="comment">     * 注意wait方法被放置在当前线程对于该独享的等待集中，解锁</span></span><br><span class="line"><span class="comment">     * 仅针对该对象</span></span><br><span class="line"><span class="comment">     * any other objects on which the current thread </span></span><br><span class="line"><span class="comment">     * may be synchronized remain locked while the </span></span><br><span class="line"><span class="comment">     * thread waits.</span></span><br><span class="line"><span class="comment">     * 在当前线程的其他对象可能在同步时保持锁定在线程等待时。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This method should only be called by a thread </span></span><br><span class="line"><span class="comment">     * that is the owner of this object's monitor. </span></span><br><span class="line"><span class="comment">     * 该方法只能由线程调用是该对象的监视器的所有者。</span></span><br><span class="line"><span class="comment">     * See the &#123;<span class="doctag">@code</span> notify&#125; method for a</span></span><br><span class="line"><span class="comment">     * description of the ways in which a thread can</span></span><br><span class="line"><span class="comment">     *  become the owner of</span></span><br><span class="line"><span class="comment">     * a monitor.</span></span><br><span class="line"><span class="comment">     *有关线程可以成为监视器所有者的方式的描述，请参见&#123;<span class="doctag">@codenotify</span>&#125;方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      timeout   the maximum time to wait in milliseconds.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException      if the value of timeout is</span></span><br><span class="line"><span class="comment">     *               negative.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment">     *               the owner of the object's monitor.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  InterruptedException if any thread interrupted the</span></span><br><span class="line"><span class="comment">     *             current thread before or while the current thread</span></span><br><span class="line"><span class="comment">     *             was waiting for a notification.  The &lt;i&gt;interrupted</span></span><br><span class="line"><span class="comment">     *             status&lt;/i&gt; of the current thread is cleared when</span></span><br><span class="line"><span class="comment">     *             this exception is thrown.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>        java.lang.Object#notify()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>        java.lang.Object#notifyAll()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>wait()是Object类的方法.主要用来协调多线程对共享资源的存取。当线程调用wait()方法时，该线程就和对象放置在等待集（或叫等待池）中，同时释放对象锁，当满足一定条件等待结束时，唤醒当前在等待集中的该线程（此时该线程与其他线程一起争夺对象的同步权）,从等待集中移除的方式有：<br>1.某些其他线程触发notify方法，对于当前对象和线程恰好被任意选择为要唤醒的线程；<br>2.某些其他线程触发notifyAll方法；<br>3.某些其他线程触发了interrupts方法；<br>4.设置的特定wait时间到了。如果这个时间是0，则不考虑时间，线程只能等待通知。  </p><p><em>其他线程调用interrupts方法中断时如果当前对象正在被其他线程占用，那么InterruptedException会在对象锁定状态恢复后抛出</em><br>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Package: com.litchi.demo.java</span></span><br><span class="line"><span class="comment"> * Date:    2020/5/12</span></span><br><span class="line"><span class="comment"> * Desc:    com.litchi.demo.java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liujicheng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> java.lang.Object resourceOne = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableA());</span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableB(threadA));</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceOne) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread A lock resourceOne"</span> + TimeUtil.getTime(System.currentTimeMillis()));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        resourceOne.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"ThreadA:"</span> + TimeUtil.getTime(System.currentTimeMillis()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RunnableB</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i = i &gt;&gt; <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceOne) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread B lock resourceOne:"</span> + TimeUtil.getTime(System.currentTimeMillis()));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Thread B request interrupt threadA:"</span> + TimeUtil.getTime(System.currentTimeMillis()));</span><br><span class="line">                        thread.interrupt();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            java.lang.Thread.sleep(<span class="number">8000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            java.lang.Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="sleep_wait_lock.jpg" alt=""></p><p>这里可以看到catch内的执行是在Thread B线程释放锁resourceOne对象后抛出的。  </p><ul><li>两者区别比较：  </li></ul><p>1.sleep()时Thread类的静态方法，wait()是Object类的方法；<br>2.sleep()只是让当前线程休眠，不会释放同步锁，资源会被持续占有，wait()会释放同步锁，会把线程放入对象的wait集合中；<br>3.sleep()可以在任何地方使用，wait()方法、notify()方法和notiftAll()方法用于协调多线程对共享数据的存取，所以只能在同步方法或者同步块中使用，否则抛出IllegalMonitorStateException；<br>4.sleep()必须传入时间，而wait()可以传，也可以不传，如果不传要通过otify()方法和notiftAll()方法唤醒。</p>]]></content>
    
    <summary type="html">
    
      JAVA基础
    
    </summary>
    
      <category term="JAVA基础" scheme="/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础" scheme="/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
